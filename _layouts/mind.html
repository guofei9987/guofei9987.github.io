<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>{{ page.title }} | {{ site.title }}</title>
    <meta name="author" content="{{ site.author.name }}">
    <link rel="stylesheet" href="/public/css/litree.css">


    <!-- LaTeX支持 -->
<link rel="stylesheet" href="/public/katex/katex.min.css">
<script defer src="/public/katex/katex.min.js"></script>
<script defer src="/public/katex/auto-render.min.js"  crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


</head>
<body>

{{ content }}


<script>
    // 最外层 的 ul，增加 litree 对象
    const outerUls = document.querySelectorAll('ul:not(ul ul)');
    // 可能有多组
    outerUls.forEach(ul => {
        ul.classList.add('litree');
    });
    
    
    
    function addStickyDivToText(node) {
      // 检查节点是否为文本节点
      if (node.nodeType === Node.TEXT_NODE) {
          if(node.textContent.trim()===''){
              // 不知道为啥会有这么多空 div，跳过就行了
              return
          }
    
        // 创建一个 <div> 元素
        const div = document.createElement('div');
        div.classList.add('sticky')
    
        // 将原始文本包裹在 <div> 元素中
        const text = node.textContent;
    
        div.textContent = text;
    
        // 用新的 <div> 元素替换原始文本节点
        node.parentNode.replaceChild(div, node);
      }
      else if (node.nodeType === Node.ELEMENT_NODE) {
        // 遍历子节点并递归调用 addStickyDivToText 函数
        const childNodes = node.childNodes;
        for (let i = 0; i < childNodes.length; i++) {
          addStickyDivToText(childNodes[i]);
        }
      }
    }
    
    // 获取所有的 <li> 元素
    // const liElements = document.querySelectorAll('li');
    const liElements = document.querySelectorAll('li:not(li li)');
    
    // 对每个 <li> 元素进行操作
    liElements.forEach((liElement) => {
      addStickyDivToText(liElement);
    });
    </script>


</body>
</html>
