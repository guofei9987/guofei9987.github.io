---
layout: post
title: 【密码学】知识体系_进行中
categories:
tags: 0x58_密码学
keywords:
description:
order: 59003
---

相关书目：
《深入浅出密码学》

## 0 一些概念


密码学要解决的问题
- 保密性 Confidentiality
- 完整性 Integrity
- 可用性 Availability


历史上的密码学
- 羊皮传书
- 藏头诗（实际上是一种隐写术）
- Caesar

![caption: 羊皮传书](/a/computer/cipher/cipher1.gif)



密码系统的组成
- 明文 plaintext
- 密文 chiphertext
- 密钥 key
- 加密算法 encipher
- 解密算法 decipher








分类1:根据明文变成密文的变换方法分类

| 类型                            | 核心思想               | 示例                     |
| ----------------------------- | ------------------ | ---------------------- |
| **替换密码 Substitution Cipher**  | 用其他符号替代明文中的符号，顺序不变 | Caesar |
| **置换密码 Transposition Cipher** | 保留原符号，但重新排列顺序      | Rail Fence |
| **乘积密码 Product Cipher**       | 结合替代与置换，以增强安全性     | DES、AES（现代密码多属此类）      |




分类2:根据 key 数量

| 类型                                | 特点                                                   | 常见算法                     |
| --------------------------------- | ---------------------------------------------------- | ------------------------ |
| **对称密码 Symmetric Cryptography**   | 加密与解密使用同一把密钥（Same Key for Encryption and Decryption） | AES、DES、SM4              |
| **非对称密码 Asymmetric Cryptography** | 加密与解密使用不同的密钥对（Different Keys: Public & Private）      | RSA、DSA、ECC、NTRU、Rainbow |



- 对称密码
    - 对称密码的一些说明
    - 密码学假定信道本身不安全，而密钥应当双方都知道
    - 因此通信之前双方需要在某个安全通道传输密码 key
- 非对称密码
    - RSA：基于整数分解
    - DSA：基于离散对数问题
    - ECC：基于椭圆曲线
    - NTRU：基于格理论，抗量子
    - Rainbow：基于多变量多项式，用于数字签名


分类3:根据明文处理方式，对称密码还分为：

| 分类                    | 加密单元                                   | 应用场景       |
| --------------------- | -------------------------------------- | ---------- |
| **分组密码 Block Cipher** | 每次处理一组固定长度的数据块（Encrypt Data in Blocks） | 主要是民用/商用<br>文件加密、HTTPS<br> DES（已不安全）、AES（目前广泛使用） |
| **流密码 Stream Cipher** | 按比特/字节连续处理（Encrypt Data as a Stream）   | 主要是军用<br>实时通信、无线传输  |


对称密码的一些说明
- 密码学假定信道本身不安全，而对称密码的密钥应当双方都知道
- 因此通信之前双方需要在某个安全通道传输密码 key

非对称密码的一些说明
- RSA：基于整数分解
- DSA：基于离散对数问题
- ECC：基于椭圆曲线
- NTRU：基于格理论，抗量子
- Rainbow：基于多变量多项式，用于数字签名



**密码编码学（Cryptography）**：研究如何做密码编码

**密码分析学（Cryptanalysis）**，是破解密码的研究，是对密码攻击
- 所用的方法：
    - 经典密码分析（Classical Cryptanalysis）
        - 数学分析法：发现加密方法内部结构的分析攻击
        - 暴力破解：测试所有可能的密钥进行破解
    - 实施攻击(ImplementationAttack)
        - 从旁道分析，如：测量处理私钥的处理器的功耗、电磁辐射、算法运行时的行为。前提是攻击者可以物理访问密码体制。
    - 社会工程攻击。行贿、勒素、跟踪或侦探
- 密码分析面临的情况
    - 仅知密文攻击（Ciphertext - only attack）。仅能获取到一些密文，尝试推导出明文或者密钥
    - 已知明文攻击（Known - plaintext attack）。除了拥有一定数量的密文外，还知道与之对应的明文。
    - 选择明文攻击（Chosen - plaintext attack）。可以任意选择明文，并获取对应的密文
    - 密文攻击（Chosen - ciphertext attack）。攻击者可以选择特定的密文，并获取这些密文对应的明文
- **密码学（Cryptology）**：就是密码编码学+密码分析学。



**Kerckhoffs 原则：一个密码系统安全，不依赖算法的保密性，只依赖密钥的保密性。**
- 否则一旦算法泄漏（很容易），整个密码系统就完蛋
- 公开算法，使得其受到广泛审查。假定某个人找到了密码系统的漏洞，对其最有利的做法是发论文，否则会被别人抢先。
- 公开算法，使公众可以信任它，而不是依赖测试机构的权威
- 密钥易于更换，算法不易更换

**密码协议**：利用密码学实现安全通信的一系列规则和步骤。例如 SSL、SSH、OAuth


**密码安全**
- **无条件安全**：在攻击者拥有无限算力的情况下，一个密码体制也是安全的，叫做 无条件安全。密码学基本不研究这个。
- **计算安全**：为了破解一个密码体制，最好的已知算法至少需要 t 个操作，叫做计算安全
    - 破解所需时间超过信息本身的有效期，或者破解的成本高于信息本身的价值
    - 存在问题：如 RSA 基于大整数因式分解，尽管因式分解算法是已知的，但我们不知道是否存在更好的因式分解算法。


## 数学基础


mod 与整数环

这个的系统组成一个环：
- $Z=\{0,1,2,...,m-1\}$
- 定义两个运算符 $+, \cdot$
    - $a+b\equiv c \mod m$
    - $a\cdot b \equiv d \mod m$


性质
- 未必存在逆元（逆元定义为 $a\cdot a^{-1} \equiv 1 \mod m$）
- 当且仅当 $\gcd(a,m)=1$ 才存在逆元



## 替换密码

### 移位密码


**凯撒密码（移位密码）** 是一种最简单的替换密码，它把字母表向后移动 k 位，末尾放开头
- 算法（环的语言）：
    - 加密：$y\equiv x + k \mod 26$
    - 解密：$x\equiv y - k \mod 26$
- 移位密码的评价：
    - 移位密码的密钥只有 25 种，因此非常不安全。
    - 它是替换密码的一种，可以使用字母频率分析法攻击它


-----------------------------


**仿射密码**，在移位密码的基础上做一些改变
- 算法：
    - 加密：$y \equiv a \cdot x + b \mod 26$
    - 解密：$x \equiv a^{-1} \cdot (y - b) \mod 26$
    - 密钥：$k = (a, b)$ ，其中 $gcd(a, 26)=1$
- 仿射密码的评价：
    - a 可能取值为 1，3，5，7，9，11，15，17，19，21，23，25
    - b 可能取值为 26 个
    - 因此密钥空间为 12x26 = 312 ，也是非常不安全


-----------------------------

**单字母表密码** 算法：
1. 维护一个字母对字母的一一映射表（这个表就是密钥）
2. 按照密钥做映射即可

攻击：
1. 表面上上不同的组合有 $26!$ 种，需要暴力遍历几百年
2. 实际上有一些高效的攻击手段
    - 字母的频率是稳定的。在密文中也如此，统计密文中的字母频率可以大致推断是什么字母
    - 类似的，连续密文也是可以统计，例如英语中，U总是跟着Q
    - 如果发现了空格，可以找到高频短单词，例如 THE、AND

### Playfair

单字母加密很容易被频率分析破解
- 多对一：分组，一次加密一组。**Playfair密码**
    - 例如，构造的映射表是：8字母到8字母的映射
    - 攻击者的词表就是 $26^8$ 大小
    - 字母频率也不明显了
- 一对多（**维吉尼亚密码**）。明文中一个字母，可能映射为多个字母


**Playfair cipher** 用2个字母映射2个字母，
- 19世纪发明的，最初为了配合电报机使用。

![caption: 惠斯通发明的电报机](/a/computer/cipher/cipher2.gif)


**Playfair cipher** 的算法：
- 密钥
    - 共25个字母（规定ij不做区分）
    - 按照惯例，密钥通常是规定某本书某一页某一位置
    - 从这一位置起，开始提取字母（丢弃重复的），得到一个长度为 25 的字母排序。
    - 这25个字母，可以写成一个 5x5 的矩阵，这就是密钥
- 分组。每两个分一组。
    - 如果某组的两个一样，则填充最后一个为 `X`
    - 如果为奇数个，则最后一位填充（padding）`X`，（现代密码的常见方法）
    - 举例。plaintext 是 `ballons`，分组为 `ba lx on sx`
- 加密规则（以下面的密码表为例）
    1. 如果双字母在同一行，则用右边的字母代替。`AR -> RM`
    2. 如果双字母在同一列，则用下面的字母代替。`MU -> CM`
    3. 如果双字母不在同一行也不在同一列，则用对角上的字母代替。`HS -> BP`，`EA -> IM`


![caption: Playfair](/a/computer/cipher/playfair.gif)


Playfair 同样可被攻击
- 词表共 $26\times 26 = 676$ 个元素，用现代计算机，只要截获几百个单词就可以很快破解
- 改进：提高分组大小，例如 8个一组，词表就是 $26^8$ 大小


-----------------------------


**维吉尼亚密码** 的思路是使映射关系不唯一。例如，一个字母有时候按照词表1映射，有时候按照词表2映射。

一个典型做法：
- 每个词表都是凯撒密码，
- 假设密码 `KEY = DECEPTIVE`，第一个字母按照 `k='D'` 的凯撒密码加密，第二个字母按照 `k='E'` 的凯撒密码加密

![caption: 维吉尼亚加密](/a/computer/cipher/vigenere.gif)

攻击方法
- 注意到维吉尼亚加密法，其 `k` 是有周期的
- 一旦知道key的长度，就很容易用字频分析
- 如何找到 key 的长度呢？在密文中找周期，周期的公约数可能就是 key 的长度（多试几次）


![caption: 维吉尼亚加密的周期分析](/a/computer/cipher/vigenere2.gif)

（这个例子是故意造了个容易找周期的情况）


---------------------

改进思路：
- key 不再使用周期性的循环使用，而是使用已解出的明文作为新的密码
- 这就是 **Autokey Cipher**


![caption: Autokey](/a/computer/cipher/autokey.gif)

攻击方法
- Plaintext 本身也用作 key，可惜它们都是有频率分布的
- 例如，字母 `E` 在 Plaintext 出现概率很高，因此在 key 中的出现概率也很高，因此 `E` 加密 `E` 的概率也很高
- 因此也可以用频率统计来攻击


综上，我们如何找一个合适的密码系统呢？核心思路就是如何屏蔽掉统计规律。



### Vernam 加密

特点：
- 加密函数和解密函数是同一个函数
- 计算性能高，只需要一个 XOR 操作
- 密码序列是一串随机数，由随机数生成器生成，但是比普通的随机数生成器要求不可预测（也就是根据已生成的随机数，不能预测未来的随机数）。



**Vernam 加密**（Vernam Cipher）基本单位是位（bit）。其算法是明文与密文逐位 `XOR` 运算
- $x_i, y_i, s_i \in \{ 0, 1 \}$
- 加密：$y_i = x_i \oplus s_i$
- 解密：$x_i = y_i \oplus s_i$
- 特点：硬件/软件实现高效，适用于实时通信；安全性取决于密钥流的不可预测性。
    - 1918年 Vernam 提出并申请专利
    - 1949年 香农证明了 **OTP 就是 无条件安全的**（无条件安全的密码体制很难设计）
    - OTP在下面介绍 
    - OTP 的缺点是密钥分发极为困难


**一次一密(OTP,One-Time Pad)** 是 Vernam 密码的一个特例：
- 密钥 长度 = 明文长度；
- 密钥 真随机；
- 密钥 只使用一次，之后立即废弃；
- 密钥 保密且双方共享。



据传言，在冷战期间白宫和克里姆林宫之间的红色电话就是使用 OTP 加密的。但没有大规模使用，它有缺陷：
1. 真随机数设备有成本
2. Alice 必须把 $\{ s_i \}$ 安全的传递到 Bob，比如写入到 CD，让一位特工做信使
3. $\{ s_i \}$ 用完后，还需要再次传递






#### 基于移位寄存器的序列密码

接上文 OTP，想到用伪随机数生成器代替真随机数生成器，来生成 $\{ s_i \}$，这样密钥就是 seed，但这个想法是 **不可行的**，解释如下：
- 随机数生成器基于线性同余发生器：$S_0 = seed, S_{i+1}\equiv A S_i + B \mod m$
- 加密方式同 OTP 
    - 加密：$y_i = x_i \oplus s_i$
    - 解密：$x_i = y_i \oplus s_i$


为什么这个方案是不可行的呢？  
- 如果攻击者 Oscar 猜出部分明文（比如文件头信息更容易猜），那么立即结合密文可以计算出 $\{ s_i \}$
- 然后解方程 $S_2 \equiv A S_1 + B \mod m; S_3 \equiv A S_2 + B \mod m$，即可得到 $A,B$
- 根据 $\gcd(S_1-S_2,m)$ 取值，可以有多解或唯一解。然后根据其它分片可以唯一得到密钥

实际上相当多的伪随机数生成器都不是密码学安全的，我们需要专门设计伪随机数生成器：例如 **线性移位寄存器（LFSR）**
- 许多序列密钥是利用 LFSR 来实现的，例如 A5/1
- 构建方法很多，这里只介绍一种


LFSR 是用一个电路实现的，这个电路中有 m 个触发器，

例如，m =3 的情况下，LFSR 用数学描述是：
- 初始化 $s_0,s_1,s_2$
- $s_{i+3} \equiv s_{i+1} + s_i \mod 2$

性质：
- 当然，它是一个周期序列
- 它的周期是多少取决于 m 和初始化的值。一个 m 位的 LFSR，有 $2^m-1$ 种非零状态，因此它最大可能的周期为 $2^m-1$


如何攻击？
- 只要 Oscar 知道度为 m 的 LFSR 的 2m 个输出位，就可以列方程来解出参数
- 可以得到 m 个线性等式进而用高斯消元法来计算参数
- 然而，它并没有丧失所有密码属性。有不少序列密码都是使用多个LFSR 的组合构建强壮的密码体制。

**Trivium**  是一个较新的序列密码，它的密钥长度为 80 位。Trivium 基于三个移位寄存器的组合。然后在得到每个寄存器的输出时使用了非线性组件。


总体来说，许多序列密码的安全性都是未知的，而且很多已经被破解了。


## 置换密码

字母不变，打乱其顺序

### 简单的置换密码


**Rail Fence密码** 先横向写，然后纵向取，得到密文。

例如，一个深度为 k 的 Rail Fence，如下（代码比文字更容易说明）

```python
plaintext = 'meetmeafterthetogapartyat8pm'
ciphertext = ''
k = 5

# （还需要padding，使其长度为 k 的整数倍）
for i in range(k):
    ciphertext += plaintext[i::k]
```

前面提到的羊皮传书就是一种 Rail Fence 密码

-------------------------------

**行置换密码**

在 Rail Fence 的基础上添加一个规则：  
纵向取的时候，按照 Key 规定的顺序取。


![caption: 行置换密码](/a/computer/cipher/rail_fence.gif)


## 转子机：古典密码的最高峰

二战期间广泛使用，是一种乘积密码


Enigma 机为例


![caption: Enigma机](/a/computer/cipher/enigma1.gif)

![caption: Enigma机](/a/computer/cipher/enigma2.gif)


![caption: Enigma机](/a/computer/cipher/enigma3.gif)



## 分组密码

强加密算法一般基于两种本原操作
- 混淆（Confusion）：使密钥和密文尽可能模糊
- 扩散（Diffusion）：一个明文符号影响多个密文符号

### DES

- 对称密码
- 迭代算法，每个分组加密16轮

### AES

- 分组长度 128，密钥长度 128/192/256
- 设计简单、代码紧凑、运行速度快
- 可以在8位CPU上运行，需要4k存储空间

## 流密码

RC4、ChaCha20 等


## 非对称密码

对称密码的缺点
- 密钥分发：需要一个安全渠道分发密钥
- 没有不可否认性：只要知道密钥，就可以加密和解密
- 用户增多时，密钥数量膨胀。n个用户互相通信，需要两两密钥，就是 n(n-1)/2 个密钥。非对称密码需要 2n 个密钥（每人公私各1个）
- 非对称密码也有其缺点，就是速度较慢。一个用法是，用非对称密码来交换“对称密码的密钥”，然后用对称密码相互通信。

非对称密码的使用（A 发送给 B）
- Bob 的公钥是公开的（例如放在主页或公告板）
- Bob 的私钥是保密的，只有自己知道
- Alice 使用 Bob 的公钥加密，然后把密文传递给 Bob
- Bob 用自己的私钥解密，得到明文


公开密钥系统的 6个要素
- 明文 Plaintext
- 公开密钥（PK, Public Key）
- 私有密钥（SK, Secret Key）
- 加密算法 encipher 
- 密文 chiphertext
- 解密算法 decipher

公开密钥算法的基本要求（A 发送给 B）
- B 容易通过计算产生一对密钥（$PK_b$，$SK_b$）
- A 容易计算产生密文，$C = E_{PK_b}(M)$
- B 容易计算解密，得到解密后的明文，$M = D_{SK_b}(C) = D_{SK_b}(E_{PK_b}(M))$
- 敌对方即使知道 PK，要确定 SK，计算上不可行
- 敌对方即使知道 PK 和 Ciphertext，要确定 Plaintext，计算上不可行
- 密钥对相互可以交换使用 $M = D_{SK_b}(E_{PK_b}(M)) = D_{PK_b}(E_{SK_b}(M))$
    - 也就是说：用公钥加密的，可以用私钥解密；用私钥加密的，可以用公钥解密
    - 前者可以用来做 **加密通信**，后者可以用来做 **数字签名**
    - 上面提到的 *容易计算*、*计算上不可行* 是有严格定义的，是根据计算复杂度定义的。





签名的需求
- 身份的认证
- 抗抵赖

**数字签名** （B 发送给 A）
- 过程
    - B 用自己的私钥加密，然后发送给 A
    - A 用 B 的公钥解密（验证签名的过程）
- **身份认证** A 用 B 得公钥把信息解密了，说明发送方只可能是 B
- **抗抵赖** A 可以用密文 + B 的公钥，找第三方裁决，很容易确定密文来自 B
- 对称密码系统无法解决这两个需求，因为 A 和 B 知道的信息一样多。


综上，非对称密码系统的使用场景：
- 加密通信。（对称密码也有这个功能）
- 交换密钥
- 数字签名
    - 身份认证
    - 抗抵赖



| |RSA|Diffie-Hellman|DSA
|--|--|--------------|----|
|保密通信 | ✅ | ❌ | ❌
|密钥交换 | ✅ | ✅ | ❌
|苏子签名 | ✅ | ❌ | ✅

### RSA 理论



RSA 的加密和解密过程
- 公钥为 (E, N)，私钥为 (D, N)
- 假设明文为数字 x
- 公钥加密 $y = (x^E)%N$
- 私钥解密 $x1 = (y^D)%N$
- 公钥解密 $y = (x^E)%N$
- 私钥加密 $x1 = (y^D)%N$

示意代码如下：
```py
# 私钥是 (E, N)，公钥为 (D, N)
# 可以私钥加密、公钥解密。也可以公钥解密、私钥加密
E = 3
N = 33
D = 7


# 工具：字符串转array
def str2arr(text):
    return [ord(i) - ord('A') for i in text]


# 工具：array转字符串
def arr2str(arr):
    return ''.join(chr(i + ord('A')) for i in arr)


# 私钥加密/解密
def encryption(x):
    return (x ** E) % N


# 公钥解密/加密
def decryption(y):
    return (y ** D) % N


text = 'HELLO'
cipher_arr = [encryption(x) for x in str2arr(text)]
ciphertext = arr2str(cipher_arr)
print('私钥加密后：', ciphertext)

decrypted_arr = [decryption(y) for y in str2arr(ciphertext)]
print('公钥解密后：', arr2str(decrypted_arr))
```


如何选择 E，D？
- 任意取两个大素数，例如 `p=3;q=11`
- `N=p*q=33`
- 欧拉函数 `T=(p-1)(q-1)=2*10=20`
- 随机选择公钥 E，使其满足：1）E为素数 2）`1<E<T` 3）E 不是 T 的因子。这里选择 E=3
- 选择私钥 D，使其满足 `(DE)%T == 1` （欧几里得算法）


## 参考

- 【国家精品课程】[复旦大学：信息安全](https://www.icourse163.org/course/FUDAN-1206357811)
