---
layout: post
title: 【进行中】密码学相关知识
categories:
tags: 0x58_密码学
keywords:
description:
order: 59003
---

相关书目：
《深入浅出密码学》

## 0

密码编码学
- 对称密码
    - 序列密码：加密后的每个位，只取决于明文对应位和密钥
    - 分组密码：分组内的每个位，都对结果有影响
    - 区别：分组密码使用广泛。序列密码小而快，但是AES等现代分组密码也很快。
- 非对称密码
- 密码协议






密码分析学（对密码攻击）
- 经典密码分析（Classical Cryptanalysis）
    - 数学分析法：发现加密方法内部结构的分析攻击
    - 暴力破解：测试所有可能的密钥进行破解
- 实施攻击(ImplementationAttack)
    - 从旁道分析，如：测量处理私钥的处理器的功耗、电磁辐射、算法运行时的行为。前提是攻击者可以物理访问密码体制。
- 社会工程攻击。行贿、勒素、跟踪或侦探


Kerckhoffs 原理：一个密码体制安全，必须在除密钥之外的整个系统是公开的前提下它是安全的。

## 替换密码

算法：
1. 维护一个字母对字母的一一映射表（就是密钥）
2. 按照密钥做映射即可

攻击：
1. 表面上上不同的组合有 $26!$ 种，需要暴力遍历几百年
2. 实际上有一些高效的攻击手段
    - 字母的频率是稳定的。在密文种也如此，统计秘文中的字母频率可以大致推断是什么字母
    - 类似的，连续秘文也是可以统计，例如英语中，U总是跟着Q
    - 如果发现了空格，可以找到高频短单词，例如 THE、AND


**凯撒密码** 是一种最简单的替换密码，它把字母表向后移动 k 位，末尾放开头

## mod 与整数环

这个的系统组成一个环：
- $Z=\{0,1,2,...,m-1\}$
- 定义两个运算符 $+, \cdot$
    - $a+b\equiv c \mod m$
    - $a\cdot b \equiv d \mod m$


性质
- 未必存在逆元（逆元定义为 $a\cdot a^{-1} \equiv 1 \mod m$）
- 当且仅当 $\gcd(a,m)=1$ 才存在逆元


## 一些不安全的密码

移位密码用环的语言表示：
- 加密：$y\equiv x + k \mod 26$
- 解密：$x\equiv y - k \mod 26$

移位密码的评价：
- 移位密码的密钥只有 26 种，因此非常不安全。
- 它是替换密码的一种，可以使用字母频率分析法

仿射密码，在移位密码的基础上做一些改变
- 加密：$y \equiv a \cdot x + b \mod 26$
- 解密：$x \equiv a^{-1} \cdot (y - b) \mod 26$
- 密钥：$k = (a, b)$ ，其中 $gcd(a, 26)=1$

仿射密码的评价：
- a 可能取值为 1，3，5，7，9，11，15，17，19，21，23，25
- b 可能取值为 26 个
- 因此密钥空间为 12x26 = 312 ，也是非常不安全


## 序列密码

明文、密文、密钥由单独的位组成，即 $x_i, y_i, s_i \in \{ 0, 1 \}$
- **加密**：$y_i = x_i + s_i \mod 2$
- **解密**：$x_i = y_i + s_i \mod 2$

特点：
- 加密函数和解密函数是同一个函数
- 计算性能高，只需要一个 XOR 操作
- 密码序列是一串随机数，由随机数生成器生成，但是比普通的随机数生成器要求不可预测（也就是根据已生成的随机数，不能预测未来的随机数）。


### 一次一密 OTP

**无条件安全**：在攻击者拥有无限计算资源的情况下，一个密码体制也是安全的，叫做 无条件安全。

无条件安全的密码体制很难设计。 **OTP 就是 无条件安全的**。

OTP 算法：
1. 使用真随机数生成器，生成密钥序列 $\{ s_i \}$
2. 只有合法的接受方才知道密钥序列
3. 每个密钥序列位 $\{ s_i \}$ 只使用一次
    - **加密**：$y_i = x_i + s_i \mod 2$
    - **解密**：$x_i = y_i + s_i \mod 2$

据传言，在冷战期间白宫和克里姆林宫之间的红色电话就是使用 OTP 加密的。但没有大规模使用，说明它有缺陷
1. 真随机数设备有些成本
2. Alice 必须把 $\{ s_i \}$ 安全的传递到 Bob，比如写入到 CD，让一位特工做信使
3. $\{ s_i \}$ 用完后，还需要再次传递



**计算安全**：为了破解一个密码体制，最好的已知算法至少需要 t 个操作，叫做计算安全。
- 存在问题，例如 RSA 基于大整数因式分解，尽管因式分解算法是已知的，但我们不知道是否存在更好的因式分解算法。


### 基于移位寄存器的序列密码

接上文 OTP，想到用伪随机数生成器代替真随机数生成器，来生成 $\{ s_i \}$，这样密钥就是 seed，但这个想法是 **不可行的**，接受如下：
- 随机数生成器基于线性同余发生器：$S_0 = seed, S_{i+1}\equiv A S_i + B \mod m$
- 加密方式同 OTP 
    - **加密**：$y_i = x_i + s_i \mod 2$
    - **解密**：$x_i = y_i + s_i \mod 2$

为什么这个方案是不可行的呢？  
- 如果攻击者 Oscar 猜出部分明文（比如文件头信息更容易猜），那么立即结合密文可以计算出 $\{ s_i \}$
- 然后解方程 $S_2 \equiv A S_1 + B \mod m; S_3 \equiv A S_2 + B \mod m$，即可得到 $A,B$
- 根据 $\gcd(S_1-S_2,m)$ 取值，可以有多解或唯一解。然后根据其它分片可以唯一得到密钥

实际上相当多的伪随机数生成器都不是密码学安全的，我们需要专门设计伪随机数生成器：例如 **线性移位寄存器（LFSR）**
- 许多序列密钥是利用 LFSR 来实现的，例如 A5/1
- 构建方法很多，这里只介绍一种


LFSR 是用一个电路实现的，这个电路中有 m 个触发器，

例如，m =3 的情况下，LFSR 用数学描述是：
- 初始化 $s_0,s_1,s_2$
- $s_{i+3} \equiv s_{i+1} + s_i \mod 2$

性质：
- 当然，它是一个周期序列
- 它的周期是多少取决于 m 和初始化的值。一个 m 位的 LFSR，有 $2^m-1$ 种非零状态，因此它最大可能的周期为 $2^m-1$


如何攻击？
- 只要 Oscar 知道度为 m 的 LFSR 的 2m 个输出位，就可以列方程来解出参数
- 可以得到 m 个线性等式进而用高斯消元法来计算参数
- 然而，它并没有丧失所有密码属性。有不少序列密码都是使用多个LFSR 的组合构建强壮的密码体制。

**Trivium**  是一个较新的序列密码，它的密钥长度为 80 位。Trivium 基于三个移位寄存器的组合。然后在得到每个寄存器的输出时使用了非线性组件。


总体来说，许多序列密码的安全性都是未知的，而且很多已经被破解了。


## 数据加密标淮与替换算法

强加密算法一般基于两种本原操作
- 混淆（Confusion）：使密钥和密文尽可能模糊
- 扩散（Diffusion）：一个明文符号影响多个密文符号

### DES

- 对称密码
- 迭代算法，每个分组加密16轮
