---
layout: post
title: ACDoubleArrayTrie
categories:
tags: 0x80_数据结构与算法
keywords:
description:
order: 591
---

## 是什么

ACDoubleArrayTrie = KMP + DoubleArrayTrie

## DoubleArrayTrie






## KMP

参考：https://zhuanlan.zhihu.com/p/83334559

## KMP算法

是一种深度优化过的字符串匹配算法
- 时间复杂度为 O(M+N)
- 关键是利用匹配失败后的信息,尽量减少模式串与主串的匹配次数


两种类型
- 精确匹配
- 近似匹配


本文用 `pat` 表示模式串，长度为 M，`txt` 表示文本串，长度为 N。
KMP 算法的任务是在 `txt` 中查找子串 `pat`，如果存在，返回这个子串的起始索引，否则返回 -1。

```
dp[j][c] = next
0 <= j < M，代表当前的状态
0 <= c < 256，代表遇到的字符（ASCII 码）
0 <= next <= M，代表下一个状态

dp[4]['A'] = 3 表示：
当前是状态 4，如果遇到字符 A，
pat 应该转移到状态 3

dp[1]['B'] = 2 表示：
当前是状态 1，如果遇到字符 B，
pat 应该转移到状态 2
```




### 暴力匹配

特点
- 时间复杂度为 O(MN)，空间复杂度为 O(1)
- 如果字符串中重复的字符比较多，该算法就显得很蠢。

![](/pictures_for_blog/algorithm/ac/KMP1.gif)


```c
#include <cstdio>


int get_len(char *s) {
    int i = 0;
    while (s[i] != 0) {
        i++;
    }
    return i;
}

// 暴力匹配
int search(char *pat, char *txt) {
    int M = get_len(pat);
    int N = get_len(txt);
    for (int i = 0; i <= N - M; i++) {
        int j;
        for (j = 0; j < M; j++) {
            if (pat[j] != txt[i + j])
                break;
        }
        // pat 全都匹配了
        if (j == M) return i;
    }
//     txt 中不存在 pat 子串
    return -1;
}


int main() {
    char pat[] = "aaab";
    char txt[] = "aaacaaab";
    int res = search(pat, txt);
    printf("%d", res);
}
```

### KMP

KMP 会花费空间来记录一些信息，在以下两种情况下很聪明


![](/pictures_for_blog/algorithm/ac/KMP2.gif)

![](/pictures_for_blog/algorithm/ac/KMP3.gif)



KMP 算法永不回退 `txt` 的指针 i，不走回头路（不会重复扫描 txt），而是借助 dp 数组中储存的信息把 pat 移到正确的位置继续匹配，时间复杂度只需 O(N)，用空间换时间，所以我认为它是一种动态规划算法。
- 如何计算 dp 呢？ 经过分析，这个 dp 数组，只和 pat 有关

因此KMP算法可以设计的很漂亮

```cpp
// 伪代码，C++
struct KMP{
  char* dp[];

  void build_kmp(char *pat){
    // 通过 pat 构建 dp 数组
    // O(M)
  }

  int search(char* txt){
    // 用 dp 匹配 txt
    // O(N)
  }
}
```


正经的 KMP 用的是一维的 next 数组，这里为了代码可读性，用二维的 dp 数组


```python
class KMP:
    def __init__(self, pat: str):
        # 构建 kmp
        # O(m)
        self.pat = pat
        m = len(pat)
        dp = [[0 for _ in range(256)] for _ in range(m)]

        # base case，遇到 pat[0] 才转移 0 -> 1，遇到其它字符停留在 0
        dp[0][ord(pat[0])] = 1

        # x 是影子状态
        x = 0
        for j in range(1, m):
            for c in range(256):
                if ord(pat[j]) == c:
                    dp[j][c] = j + 1
                else:
                    dp[j][c] = dp[x][c]

            x = dp[x][ord(pat[j])]

        self.dp = dp

    def search(self, txt):
        m, n = len(self.pat), len(txt)

        j = 0
        for i in range(n):
            j = self.dp[j][ord(txt[i])]
            if j == m:
                return i - m + 1

        return -1


kmp = KMP('aaab')

kmp.search('aaacaaab')
```



## ACDoubleArrayTrie





C 版本：

https://blog.csdn.net/glorious_dream/article/details/123539624

```c
//#include<bits/stdc++.h>
#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cmath>
#include <deque>
#include <vector>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <stack>
#include <set>


using namespace std;

inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}

//const int M = 500010;
const int M = 10;
char s[M * 2];
int fail[M], ch[M][30], bo[M], que[M];
int n;
int ans, tot = 1;

void insert(char *s) {
    int u = 1, len = strlen(s);
    for (register int i(0); i < len; i = -~i) {
        int c = s[i] - 'a';
        if (!ch[u][c]) ch[u][c] = ++tot;
        u = ch[u][c];
    }
    bo[u]++;
    return;
}

void build() {
    queue<int> q;
    fail[1] = 0;
    q.push(1);
    for (register int i(0); i < 26; i = -~i) ch[0][i] = 1;

    while (!q.empty()) {

        int u = q.front();

        q.pop();
        printf("%lu", q.size());
        for (register int i(0); i < 26; i = -~i) {

            if (!ch[u][i]) ch[u][i] = ch[fail[u]][i];
            else {
                fail[ch[u][i]] = ch[fail[u]][i];
                q.push(ch[u][i]);
            }
        }
    }
}

void find(char *s) {
    int u = 1, len = strlen(s);
    for (register int i(0); i < len; i = -~i) {
        int c = s[i] - 'a', k = ch[u][c];
        while (k && bo[k] != -1) {
            ans += bo[k];
            bo[k] = -1;
            k = fail[k];
        }
        u = ch[u][c];
    }
    return;
}

int main() {
    n = read();
    memset(ch, 0, sizeof(ch));
    for (register int i(1); i <= n; i = -~i) scanf("%s", s), insert(s);


    build();


    scanf("%s", s);
    find(s);
    printf("%d\n", ans);
    return 0;
}
```


Python版本：

```python
from collections import deque


class Queue(object):
    def __init__(self):
        self.q = deque()
        self.num = 0

    def push(self, term):
        self.q.append(term)
        self.num += 1

    def take(self):
        self.num -= 1
        return self.q.popleft()


class ACDAT:
    def __init__(self):
        # TODO: M 如何取小一些
        M = 500100
        M = 10

        self.M = M
        self.s = [0] * (M * 2)
        self.fail = [0] * M
        self.ch = [[0 for _ in range(30)] for _ in range(M)]
        self.bo = [0] * M  # 为 1 表示单词的末尾
        self.words = [None] * M  # 郭飞：用来记录对应位置上的单词

        self.que = [0] * M
        self.n = 0
        self.tot = 1

    def insert(self, word):
        # 构造 trie
        u = 1
        for i in range(len(word)):
            c = ord(word[i]) - ord('a')  # s[i] - 'a'
            if not self.ch[u][c]:
                # 如果没有这个字母的边，新建一条
                self.tot += 1
                self.ch[u][c] = self.tot
            u = self.ch[u][c]
        self.bo[u] += 1  # 这个点标记为单词的末尾
        self.words[u] = word  # 把单词记录上

    def build(self):
        q = Queue()
        self.fail[1] = 0
        q.push(1)

        # 初始化0的所有儿子都是1
        for i in range(26):
            self.ch[0][i] = 1

        while q.num:
            u = q.take()
            for i in range(26):
                if not self.ch[u][i]:
                    # 如果没有这个边，就跳到u对应的fail，复制一个一样的点
                    self.ch[u][i] = self.ch[self.fail[u]][i]
                else:
                    # 如果有这个子节点，就吧u这个点的儿子的fail边设置为u的fail边的同样的儿子
                    self.fail[self.ch[u][i]] = self.ch[self.fail[u]][i]
                    q.push(self.ch[u][i])

    def insert_and_build(self, keywords: list):
        for word in keywords:
            self.insert(word)

        self.build()

    def find(self, sentence):
        # 返回去重数量
        bo = self.bo.copy()
        ans = 0
        u = 1
        for i in range(len(sentence)):
            c = ord(sentence[i]) - ord('a')
            k = self.ch[u][c]
            while k and bo[k] != -1:
                ans += bo[k]
                bo[k] = -1
                k = self.fail[k]

            u = self.ch[u][c]
        return ans

    def find2(self, sentence):
        # 返回不去重的数量
        ans = 0
        u = 1
        for i in range(len(sentence)):
            c = ord(sentence[i]) - ord('a')
            k = self.ch[u][c]
            while k and self.bo[k] != -1:
                ans += self.bo[k]
                k = self.fail[k]

            u = self.ch[u][c]
        return ans

    def search(self, sentence):
        # 不去重，找到匹配到的 word
        ans = list()
        u = 1
        for i in range(len(sentence)):
            c = ord(sentence[i]) - ord('a')
            k = self.ch[u][c]
            while k and self.bo[k] != 0:
                ans.append(self.words[k])
                k = self.fail[k]

            u = self.ch[u][c]
        return ans


ac_dat = ACDAT()

ac_dat.insert_and_build(['ab', 'bc', 'cd'])

assert ac_dat.find('abcd') == 3
assert ac_dat.find('abc') == 2
assert ac_dat.find('ababadce') == 1
assert ac_dat.find2('abcdabcd') == 6

assert ac_dat.search("abdc") == ['ab']
assert ac_dat.search("abcd") == ['ab', 'bc', 'cd']

```
