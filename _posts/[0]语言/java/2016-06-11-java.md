---
layout: post
title: 【Java1】基本数据类型、流程控制
categories: 语言
tags:
keywords:
description:
order: 12001
---

## 知识点

Java特点
- Write once, run anywhere，跨平台能力
- 垃圾收集（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下不需要自己操心内存的分配和回收


- Java 程序执行过程。`.java`（代码）-(编译)->`.class`字节码文件-->`虚拟机`解释执行
- JDK： Java 开发工具包。包括两个组件：
    - 开发工具集，如Javac（编译器，把源程序转为字节码），
    - JRE（Java Runtime Environment）。包括JVM（Java Virtual Machine，Java虚拟机，是Java平台无关性的关键），Java核心类库和支持文件。


Java平台
- Java SE：Java 标准版，用来开发桌面程序。
- Java EE：Java 企业版，多了Web程序开发。
- Java ME：Java 微型版，用来移动设备开发。用的越来也少了。


## HelloWorld

```java
// HelloWorld.java

/**
 * @author guofei9987
 * @version 0.0.1
 * 文档型注释，用 java doc 命令自动生成文档
 */

/*
多行注释
*/

// 单行注释
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println(args[0]);
    }
}
```

```bash
javac HelloWorld.java # 用来生成 *.class 字节码
java HelloWorld Hello World # 执行代码，会输出 Hello，这是因为 Wrold 对应 args[1]
```


<!--
## 进阶知识点
对于 Java 平台的理解，可以从很多方面简明扼要地谈一下，例如：Java 语言特性，包括泛型、Lambda 等语言特性；基础类库，包括集合、IO/NIO、网络、并发、安全等基础类库。

JVM 的一些基础概念和机制，比如 Java 的类加载机制，常用版本 JDK（如 JDK 8）内嵌的 Class-Loader，例如 Bootstrap、 Application 和 Extension Class-loader；类加载大致过程：加载、验证、链接、初始化（这里参考了周志明的《深入理解 Java 虚拟机》，非常棒的 JVM 上手书籍）；自定义 Class-Loader 等。还有垃圾收集的基本原理，最常见的垃圾收集器，如 SerialGC、Parallel GC、 CMS、 G1 等，对于适用于什么样的工作负载最好也心里有数。这些都是可以扩展开的领域，我会在后面的专栏对此进行更系统的介绍。

当然还有 JDK 包含哪些工具或者 Java 领域内其他工具等，如编译器、运行时环境、安全工具、诊断和监控工具等。这些基本工具是日常工作效率的保证，对于我们工作在其他语言平台上，同样有所帮助，很多都是触类旁通的。


几个板块：
- Java 基础：Java 语言基本特性和机制
- Java 进阶：并发编程、Java 虚拟机等领域展开
- Java 应用开发扩展：从数据库编程、主流开源框架、分布式开发等，
- Java 安全基础：应用安全问题和处理方法
- Java 性能基础：掌握相关工具、方法论与基础实践。
-->






## 工具安装

- JDK 去 oracle 官网下载。https://www.oracle.com/downloads/
- IDE 去 jetbrain 官网下载 IntelliJ IDEA https://www.jetbrains.com/
- 打开IDE，右键 new->Module, 然后开始编程



## 代码规范

- 大小写敏感
- 类名：每个单词的首字母大写，例如 MyFirstJavaClass 。
- 方法名：小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
- 变量名：规范同方法名
- 源文件名：源文件名必须和类名相同后缀为.java。
- 主方法入口：所有的Java 程序由public static void main(String[] args)方法开始执行。
- 注释方法类似 C

## 基本

```java
public class Puppy{
    int puppyAge;
    public Puppy(String name){
        // 这个构造器仅有一个参数：name
        System.out.println("Passed Name is :" + name );
    }

    public void setAge( int age ){
        puppyAge = age;
    }

    public int getAge( ){
        System.out.println("Puppy's age is :" + puppyAge );
        return puppyAge;
    }

    public static void main(String []args){
        /* 创建对象 */
        Puppy myPuppy = new Puppy( "tommy" );
        /* 通过方法来设定age */
        myPuppy.setAge( 2 );
        /* 调用另一个方法获取age */
        myPuppy.getAge( );
        /*你也可以像下面这样访问成员变量 */
        System.out.println("Variable Value :" + myPuppy.puppyAge );
    }
}
```

程序入口是main

## 数据类型

### 基本数据类型


6种数字类型，1种字符类型，1种布尔类型


|数据类型|说明|字节|最小值|最大值|默认值|例子|
|--|--|--|--|--|--|--|--|
|byte|8位，有符号，以二进制补码表示，整数|1|-128（-2^7）|127（2^7-1）|0|byte a = 100，byte b = -50|
|short|16位、有符号的以二进制补码表示的整数|2|-32768（-2^15）|32767（2^15 - 1）|0|short s = 1000，short r = -20000|
|int|32位、有符号的以二进制补码表示的整数|4|-2,147,483,648（-2^31）|2,147,483,647（2^31 - 1）|0|int a = 100000, int b = -200000|
|long|64位、有符号的以二进制补码表示的整数|8|约 -9E18（-2^63）|约 9E18（2^63 -1）|0L|long a = 100000L，long b = -200000L|
|float|单精度、32位、符合IEEE 754标准的浮点数，不能用来表示精确的值，如货币|4|||0.0f|float f1 = 234.5F;|
|double|双精度、64位、符合IEEE 754标准的浮点数，不能表示精确的值，如货币|8|||0.0d|double d1 = 123.4; double d1 = 123D; double d=.2E5;|
|boolean|只有两个取值：true和false|1|||false|boolean one = true|
|char|单一的16位Unicode字符|2|'\u0000'（即为0）|'\uffff'（即为65,535）||char letter = 'A'; char ch = 65; char ch1='\u005d';|

在赋值或初始化时，可以把“小的”类型赋值给“大的”类型，反过来不行。

进制
- 八进制：0开头，如037，056
- 十六进制：0x或0X开头，如 0x12ab
- 进制也可以指定类型，如 0x123L


字符串
- `String s="";`
- 可以出现 unicode `String s="\u005d\u005fABC";`
- 可以用加号连接

```java
str.toUpperCase()
```

### 基本数据类型转换

分为自动类型转换，显式的类型转换。
- 自动类型转换：范围小的转为范围大的。
- 显式的类型转换  `double d = 12.3; float f = (float) d;`


```java
int x = 10, y = 5;
System.out.println("" + x + y); // 105，按照字符串连接
System.out.println(x + y + ""); // 先运算然后字符串连接
System.out.println(' ' + x + y); // char格式被转换为int
```


### 常量

指不能改变的量，一般用大写表示。
```java
final double PI = 3.1415927;
```

### String

默认是 null

创建
```java
String s1="字符";
String s2=new String();
String s3=new String("字符");
```

方法
```java
int length();

char charAt(int index) // 返回指定索引处的 char 值。
int compareTo(Object o) // 把这个字符串和另一个对象比较。
int compareTo(String anotherString) // 按字典顺序比较两个字符串。
int compareToIgnoreCase(String str) // 按字典顺序比较两个字符串，不考虑大小写。

String concat(String str) // 将指定字符串连接到此字符串的结尾。

boolean contentEquals(StringBuffer sb) // 当且仅当字符串与指定的StringButter有相同顺序的字符时候返回真。

boolean endsWith(String suffix) // 测试此字符串是否以指定的后缀结束。
boolean equals(Object anObject) // 将此字符串与指定的对象比较。
boolean equalsIgnoreCase(String anotherString) // 将此 String 与另一个 String 比较，不考虑大小写。

byte[] getBytes() // 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。
byte[] getBytes(String charsetName) // 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)  // 将字符从此字符串复制到目标字符数组。
int hashCode() // 返回此字符串的哈希码。

int indexOf(int ch)// 返回指定字符在此字符串中第一次出现处的索引。
int indexOf(int ch, int fromIndex) // 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。
int indexOf(String str) // 返回指定子字符串在此字符串中第一次出现处的索引。
int indexOf(String str, int fromIndex) // 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。
int lastIndexOf(int ch) // 返回指定字符在此字符串中最后一次出现处的索引。
int lastIndexOf(int ch, int fromIndex) // 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。
int lastIndexOf(String str) // 返回指定子字符串在此字符串中最右边出现处的索引。
int lastIndexOf(String str, int fromIndex) // 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。

String intern() // 返回字符串对象的规范化表示形式。


int length() // 返回此字符串的长度。

boolean matches(String regex) // 告知此字符串是否匹配给定的正则表达式。
boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) // 测试两个字符串区域是否相等。
boolean regionMatches(int toffset, String other, int ooffset, int len) // 测试两个字符串区域是否相等。

String replace(char oldChar, char newChar) // 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。
String replaceAll(String regex, String replacement) // 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。
String replaceFirst(String regex, String replacement) // 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。

String[] split(String regex) // 根据给定正则表达式的匹配拆分此字符串。
String[] split(String regex, int limit) // 根据匹配给定的正则表达式来拆分此字符串。

boolean startsWith(String prefix) // 测试此字符串是否以指定的前缀开始。
boolean startsWith(String prefix, int toffset) // 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。
CharSequence subSequence(int beginIndex, int endIndex) // 返回一个新的字符序列，它是此序列的一个子序列。


String substring(int beginIndex) // 返回一个新的字符串，它是此字符串的一个子字符串。
String substring(int beginIndex, int endIndex) // 返回一个新字符串，它是此字符串的一个子字符串。


char[] toCharArray() // 将此字符串转换为一个新的字符数组。
String toLowerCase() // 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。
String toLowerCase(Locale locale) // 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。
String toString() // 返回此对象本身（它已经是一个字符串！）。
String toUpperCase() // 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。
String toUpperCase(Locale locale) // 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。

String trim() // 去除两边的空格
```

关于 byte：
```java
String s1="JAVA 编程";
byte[] arr=s1.getBytes(StandardCharsets.UTF_8); // String 转 byte[]
for(byte i:arr)System.out.print(i+";");

// byte 转回 String
String s2=new String(arr);
System.out.println(s2);
```

更多对象
- StringBuffer 线程安全
- StringBuilder 不是线程安全的，但性能略好。而且不再是不可变对象了。


```java
StringBuilder s2=new StringBuilder("你好");

// 可以 append 各种类型
s2.append(',');
s2.append("hello!");
s2.append(1);


s2.delete(3, 8);

s2.insert(4, "HELLO!");

s2.substring(0, 4)

s2.replace
```



## 运算符


- 算术运算符
```java
+
-
*
/ // 如果分子分母都是int，结果为int
% // 求余数
int y = x++;
y = ++x; // 先自增，然后赋值
y = --x;
y = x--;
```
- 赋值运算符
```java
int x = 1; // 普通的赋值
x += 5;
x -= 5;
x *= 5;
x /= 5;
x %= 5;
```
- 关系运算符
```java
>; <; >=; <=; ==;!=;
'A'>'B' // 结果是 false，比较的是 ASCII
float f=5.0f; long l=5; f==l; // true, 只要值相等，就返回 true
```
- 逻辑运算符
```java
& // 与
&& // 与，如果第一个为 false，后面就不算了
| //或
|| //或快，如果第一个为 true，后面就不算了
! // 非
```
- 条件运算符
```java
// 语法：bool?expr1:expr2
// 例子：
int x = 1, y = 2;
int max = (x > y) ? x : y;
```
- 位运算符


## 流程控制

### 条件语句
if
```java
// if
if(a>b){
    System.out.println('yes');
}

// if-else
if(a>b){
    System.out.println('yes');
}
else{
    System.out.println('no');
}

// 多重if，只会执行一个分支
if(bool1){
  expr1;
}
else if(bool2){
  expr2;
}
else if(bool3){
  expr3;
}
else{
  exprn;
}


// 嵌套if，不多说。

// 如果没有大括号，else会匹配到最近的if
```

switch
```java
switch(bool){
  case value1:
    expr1;break;
  case value2:
    expr2;break;
  default: // default 可以省略。
    expr3;
}
```


### 循环语句
while

```java
while(bool){
  expr1;
}

// do-while 循环，至少会循环一次。
do{
  exp1;
}while(bool1); // 这里必须以分号结尾
```

for
```java
for(初始化表达式;循环条件表达式;类似n++) // 每个表达式都可以省略，可以把逻辑放到其它地方：初始化表达式可以放for循环之前，循环条件表达式可以在循环体中用break语句代替，自增表达式也可以放循环体。最省略的形式 for(;;;)
{
  expr1;
}


int sum = 0;
for (int i = 1; i <= 5; i++) {
    int n = 1;
    sum += i;
}
// 1. 这里会报错，for循环内定义的变量，作用范围只能在for循环中。
// 2. 如果 int i 在for循环外定义，就不报错，返回6.
System.out.println(i);
System.out.println(n); // 同样报错，原因同上


// 对数组for循环
String [] names ={"James", "Larry", "Tom", "Lacy"};
for(String name:names){
  System.out.println(name);
}
```



```java
// 功能不多说，只对单层循环有效。
break
continue
```




## Array

- 数组分配连续的内存空间
- 数组的长度是固定的
- 数组中的元素可以是一个自定义对象

```java
// 数组的声明
数据类型[] 数组名; // 常用的形式
数据类型 数组名[]; // 这种是为了和其它语言保持一致

// 数组的创建
// 方法1. 先声明后创建
数据类型[] 数组名;
数组名 = new 数据类型[数组长度];
// 例：
int[] arr;
arr = new int[10];
// 方法2 声明时创建
数据类型[] 数组名 = new 数据类型[数组长度]
int[] arr=new int[10];


// 数组的初始化
int[] arr = {1,2,3,4,5,6,};
```

数组的使用
```java
arr[0]; // 取数
arr.length; // 长度
arr[1] = 1; // 赋值
```

例子：
```java
int[] intArray = new int[5];
String[] strArray = new String[5];
float[] floatArray = new float[3];
char[] ch = {'a', 'b', 'c', 'd'};
```



下面展示对象构成的数组是如何使用的：

```java
// DataType.java
public class DataType {
    public int a=1;
    public String b="dataType";

}


public class Main {

    public static void main(String[] args) {
        int arraySize = 5;
        DataType[] myArray = new DataType[arraySize]; // 定义了一个空 array
        System.out.println(myArray.getClass());

        // 第一种循环
        for (int i = 0; i < myArray.length; i++) {
            myArray[i] = new DataType(); // 填充这个空 array
        }


        // 数组作为输入和输出
        DataType[] myArray1 = myArrayFunc(myArray);

        // 第二种循环： foreach 循环
        for (DataType element : myArray1) {
            System.out.println(element.a);
        }


    }

    // 数组作为函数输入值 + 数组作为函数返回值
    public static DataType[] myArrayFunc(DataType[] inputs) {
        return inputs;
    }

}
```

以上代码展示了
- 如何创建一个 array
- 如何填充一个 array
- 两种循环方法
- array 如何作为函数的输入，如何作为函数的输出


下面展示了一些 array 方法
```Java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Arrays;

public class Main {

    public static void main(String[] args) {
        int[] myArray1 = new int[5];
        int[] myArray2 = new int[5];
        for (int i = 0; i < 5; i++) {
            myArray1[i] = i;
            myArray2[i] = i;
        }

        // Arrays.equals 用来判断两个 array 是否完全相等
        boolean totalEqual = Arrays.equals(myArray1, myArray2);
        System.out.println(totalEqual);

        // Arrays.fill 用来用指定类型填充 array
        Arrays.fill(myArray1, 1);
        for (int elements : myArray1) {
            System.out.println(elements);
        }

        // Arrays.sort 用来升序排列
        Arrays.sort(myArray2);
        for (int elements : myArray2) {
            System.out.println(elements);
        }
    }
}
```





## Collection

![](/pictures_for_blog/java/list.png)  

[参考](https://www.cnblogs.com/liqiu/p/3302607.html)


- List：ArrayList
- Queue：LinkedList
- Set无序、不允许重复：HashSet
- Map：HashMap


实验发现，ArrayList，HashSet 都可以存放对象。



1. Iterator接口
```java
// 该接口允许遍历集合中的所有元素，一共有三个方法：
public boolean hasNext()：判断是否还有下一个元素。
public Object next()：取得下一个元素，注意返回值为 Object，可能需要类型转换。如果不再有可取元素，则抛出NoSuchElementException异常。在使用该方法之前，必须先使用hasNext()方法判断。
public void remove()：删除当前元素，很少用。
```
2. Collection接口
```java
// 最基本的集合接口，一个Collection代表一组Object
//
public boolean add(Object?o)：往集合中添加新元素。添加成功，返回true，否则返回false。
public Iterator iterator()：返回Iterator对象，这样就可以遍历集合中的所有元素了。
public boolean contains(Object?o)：判断集合中是否包含指定的元素。
public int size()：取得集合中元素的个数。
public void clear()：删除集合中的所有元素。
// 支持 iterator 方法：
Iterator it = collection.iterator();
while(it.hasNext()) {
    Object obj = it.next();
}
```
3. Set集合
```java
// Set 无序存放，主要有如下两个实现：HashSet和TreeSet
// HashSet 类按照哈希算法来存取集合中的对象，具有很好的存取性能。当HashSet向集合中加入一个对象时，会调用对象的hashCode()方法获取哈希码，然后根据这个哈希码进一步计算出对象在集合中的存放位置。  
// TreeSet实现了SortedSet接口，可以对集合中的元素排序。如何排序的内容请参考其他文档，这里不做详述。
```
4. List集合
```java
// List是一种有序集合，
// List允许有重复元素。当然，也有List的实现类不允许重复元素的存在。
// 同时，List还提供一个listIterator()方法，返回一个ListIterator接口对象，和Iterator接口相比，ListIterator添加元素的添加，删除，和设定等方法，还能向前或向后遍历，
```
  - ArrayList类->List
  ```java
  // 1. 动态数组，也是在内存中连续，
  // 2. 可以改变大小。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。
  // 3. 尾部插入和删除效率非常高
  // 4. 允许所有元素，包括null
  // size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。
  // ArrayList没有同步
  // 主要方法：
  public boolean add(Object?o)：添加元素
  public void add(int index, Object element)：在指定位置添加元素
  public Iterator iterator()：取得Iterator对象便于遍历所有元素
  public Object get(int?index)：根据索引获取指定位置的元素
  public Object set(int index,Object element)：替换掉指定位置的元素
  // 排序方法：
  Collections.sort(List list)：对List的元素进行自然排序
  Collections.sort(List list, Comparator comparator)：对List中的元素进行客户化排序
  ```
  - LinkedList类->List
  ```java
  // 允许null元素。
  // 提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。
  // LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：
  List list = Collections.synchronizedList(new LinkedList(...));
  ```
5. Map
```Java
// Map是一种把键对象和值对象进行映射的集合，它的每一个元素都包含一对键对象和值对象。
// 向Map添加元素时，必须提供键对象和值对象。
// 从Map中检索元素时，只要给出键对象，就可以返回对应的值对象。
// 键对象不能重复，但值对象可以重复。
// Map有两种常见的实现类：HashMap 和 TreeMap
public Object put(Object key, Object value)：插入元素
public Object get(Object?key)：根据键对象获取值对象
public Set keySet()：取得所有键对象集合
public Collection values()：取得所有值对象集合
public Set entrySet()：取得Map.Entry对象集合，一个Map.Entry代表一个Map中的元素
```
  - HashMap
  ```Java
    // HashMap按照哈希算法来存取键对象，有很好的存取性能。
    // 和HashSet一样，要求当两个键对象通过equals()方法比较结果为 true 时，这两个键对象的 hashCode() 方法返回的哈希码也一样。
  ```
  - TreeMap
  ```Java
  // TreeMap实现了SortedMap接口，能对键对象进行排序。同TreeSet一样，TreeMap也支持自然排序和客户化排序两种方式。
  // 要求实现 Comparable 接口，并且 comparedTo() 和 euqals() 的结果一致
  ```



关于[List性能](https://www.cnblogs.com/liqiu/archive/2013/05/06/3063926.html)：
1. ArrayList 基于动态数组的数据结构，LinkedList 基于链表
2. 对于 get 和 set，ArrayList优于LinkedList，因为ArrayList可以随机定位，而LinkedList要移动指针一步一步的移动到节点处。
3. 对于新增和删除操作add和remove，LinkeList比较占优势，只需要对指针进行修改即可，而ArrayList要移动数据来填补被删除的对象的空间。





### ArrayList

构造
```Java
import java.util.ArrayList;
import java.util.Arrays;

// 新建一个空的
ArrayList arr1 = new ArrayList();
// 新建，并指定初始容量为3
ArrayList arr2 = new ArrayList(3);

// 从 Array 新建
String[] arr = {"a", "b", "c"};
ArrayList arrLst = new ArrayList(Arrays.asList(arr));
```



增
```java
arrLst.add("d"); // 添加，返回 boolean
arrLst.add(1,"d"); // 添加到指定位置

arrLst.addAll(Arrays.asList("1", "2", "3")); // 把另一个 Collection 中的元素添加进去
boolean isSucceed = arrLst.addAll(1, Arrays.asList("1", "2", "3"));
```

删
```Java
arrLst.clear(); // 清空
arrLst.remove("b"); // 移除某个元素，
// 如果有重复元素，只会移除一个
// 如果成功移除，返回 true；否则返回 false
arrLst.remove(1); // 移除 index = 1 的某个元素
```

改
```Java
arrLst.set(1,"x");
```

查
```Java
arrLst.get(1); // 获取某个 index 对应的元素
arrLst.contains("b"); // 是否包含
arrLst.isEmpty(); // 是否为空
```

其它
```Java
arrLst.size(); // 类似 lenght
arrLst.clone();


String[] arr= (String[]) arrLst.toArray(); // 转为数组
Iterator // 迭代器方法
```

list 接口
```java
arrLst.indexOf(1); // 返回某个值
arrLst.indexOf("b"); // 返回某个对象在list中的位置，重复的返回第一个
arrLst.sort(Comparator.naturalOrder()); // 排序
```


例子：
```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


public class Main {
    public static void main(String[] args) {
        List<Integer> myArray = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            myArray.add(i);
        }
        System.out.println(myArray);

        Iterator<Integer> nameIterator = myArray.iterator();

        // remove
        while (nameIterator.hasNext()) {
            Integer a = nameIterator.next();
            System.out.println(a);
            if (a == 3) {
                nameIterator.remove();
            }
            System.out.println(myArray);
        }

        // forEachRemaining()方法对集合中尚未由迭代器访问的每个元素执行操作。
        // 迭代器是一次性对象。不能重置。要再次遍历，需要创建一个新的Iterator。
        Iterator<Integer> nameIterator2 = myArray.iterator();
        nameIterator2.forEachRemaining(System.out::println);
    }
}
```

以上代码展示了
- 2种借用 iterator 的遍历方法
- remove 方法



### LikedList

用链表实现的，使用方式与 ArrayList 差不多，下面只记不一样的地方

构造
```Java
LinkedList<String> linkedListTmp = new LinkedList<>();
LinkedList<String> linkedList = new LinkedList<>(Arrays.asList("a", "b", "c"));
```

增
```Java
// add, addAll 跟上面一样
public void addFirst(E e)，添加到第一个元素；
public void addLast(E e)，添加到最后一个元素；
```


删
```Java
// clear, remove 同上
linkedList.removeFirst();
linkedList.removeLast();
```

改，`set`

查
```Java
// contrains, get, indexOf 同上
linkedList.getLast();
linkedList.getFirst()
```








### HashSet

- 无序
- 不允许重复
- 底层是 HashMap

```java
HashSet<String> hashSet1 = new HashSet<String>(3);

// 来自 Set 接口方法
hashSet1.add("a");
hashSet1.clear();
hashSet1.contains("b"); // 返回 boolean 类型
hashSet1.containsAll(hashSet2); // 是否是子集，返回 boolean 类型
hashSet1.equals(hashSet2); // 元素是否相等
hashSet1.isEmpty()
hashSet1.remove("c")

hashSet1.size()


iterator
toArray //转数组
```

集合操作：
```java
// 并集，结果存到 s1
s1.add(s2);
// 交集，结果存到 s1
s1.retainAll(s2);
// 差集，结果存到 s1
s1.removeAll(s2);

// boolean 类型，是否是子集
s2.containsAll(s1)
```



```java
// Notice.java
public class Notice {
    public String name;
    public String contents;
    public Notice(String name,String contents){
        this.name=name;
        this.contents=contents;

    }
    public String toString(){
        return this.name+" 公告板显示："+this.contents;
    }
}


import java.util.HashSet; // HashSet
import java.util.LinkedHashSet; // 有序的 HashSet
import java.util.Set;


Notice n1 = new Notice("统计系通知","考试进行中");
Notice n2 = new Notice("数学院通知","考试周");
Notice n3 = new Notice("数学院通知","考试周");
Set s1 = new HashSet();
s1.add(n1); // 1. 元素可以是自定义的对象
s1.add(n2);
s1.add(n3);

System.out.println(s1); // 2. 默认按照对象本身来做去重，因此有3个元素。
// 如果想自定义去重，可以重写 hashCode() 和 equals()
```

为了改变 HashSet 的去重逻辑，可以重写 `hashCode()` 和 `equals()`

```java
// Notice.java
public class Notice {
    public String name;
    public String contents;
    public int duration;

    public Notice(String name, String contents, int duration) {
        this.name = name;
        this.contents = contents;
        this.duration = duration;

    }

    public String toString() {
        return this.name + " 公告板显示：" + this.contents;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + duration;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + ((contents == null) ? 0 : contents.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if(obj.getClass()== Notice.class){
            Notice n_tmp=(Notice) obj;
            return (n_tmp.name.equals(name))&&(n_tmp.duration==duration)&&(n_tmp.contents.equals(contents));
        }
        return false;
    }

}



Notice n1 = new Notice("统计系通知","考试进行中",1);
Notice n2 = new Notice("数学院通知","考试周",2);
Notice n3 = new Notice("数学院通知","考试周",2);
Set<Notice> s1 = new HashSet<Notice>(); // 1. 泛型。为了防止类不一致导致的错误
s1.add(n1);
s1.add(n2);
s1.add(n3);

System.out.println(s1); // 2. 这样，就只剩下2个元素了。
```



### HashMap


```java
HashMap<String,Integer> hashMap= new HashMap<>();

hashMap.put("key1",1); // 添加
hashMap.putAll(hashMap2);  // 批量添加

hashMap.get("key1"); // 获取

hashMap.replace("key1", 2); // 修改

hashMap.remove("key1"); // 删除

hashMap.clear();


hashMap.containsKey("key1"); // 是否包含
hashMap.containsValue("key1"); // 是否包含

hashMap.size()

hashMap.remove("key1"); // 返回 key1 对应的 value，并将其移除


Set<String> keySet= hashMap.keySet();  // 返回 key
Collection valueSet = hashMap.values();  // 返回 value
System.out.println(valueSet);


entrySet() // 返回所有键值对
```

### 其它类型

```Java
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
```

[TreeMap](https://www.jianshu.com/p/3e80eccce918)





## 参考资料

https://www.w3cschool.cn/java/
