---
layout: post
title: 【Java】入门笔记2
categories: 语言
tags:
keywords:
description:
order: 1014
---

## 面向对象

### 方法

```java
public/protected/private stastic void/int methodName(int inp){
  return inp
}
```

案例：

```java
public class HelloWorld {
    // 1. 无参数无返回值方法
    public void printStar() {
        System.out.println("*********");
    }
    // 2. 有参数有返回值方法
    public float myFunc(float a,float b){
        printStar(); // 3. 不在主方法中调用方法，就可以不用 new 一个
        return a+b;
    }

    public static void main(String[] args) {
        // 4. 在main中调用方法：
        HelloWorld helloWorld = new HelloWorld();
        helloWorld.printStar();
        float c= helloWorld.myFunc(1.2f,1.5f);
        System.out.println(c);
        helloWorld.printStar();
    }
}
```




#### 重载
方法的重载：方法名相同，但入参列表不同。  
```Java
// 一个重载的例子
public class D {
    public void func(int a) {
        System.out.println("int");
    }

    public void func(String a) {
        System.out.println("String");
    }

    public static void main(String[] args) {
        D d = new D();
        d.func(1);
        d.func("1");
    }
}
```

#### 可变参数类型
可变参数列表
```java
public class HelloWorld {
    public int get_sum(int... n) { // 可变参数列表
        int sum = 0;
        for (int i : n) {
            sum += i;
        }
        return sum;
    }

    public static void main(String[] args) {
        HelloWorld helloWord = new HelloWorld();
        System.out.println(helloWord.get_sum(1));
        System.out.println(helloWord.get_sum(1, 2, 3));
    }
}
```

可变参数类型2
```java
public class HelloWorld {
    public boolean isIn(int a, int... n) { // 可变参数必须放到最后。这个n可以传入数组，因此不能再写一个同名方法重载另一个n是数组的方法了。
        for (int i : n) {
            if (a == i) {
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        HelloWorld helloWord = new HelloWorld();
        System.out.println(helloWord.isIn(1, 1, 2, 3, 4));
        System.out.println(helloWord.isIn(5, 1, 2, 3));
    }
}
```

可变参数列表：
- 可变参数必须放到最后。
- 可变参数位置的可以传入数组。因此不能再写一个同名方法重载另一个n是数组的方法了（因为已经有了这样一个方法了）。
- 多个同名方法同时满足时，可变参数最后被调用。例如，两个方法 `func(int a, int b)`, `func(int... a)`，那么调用 `func(1,2)` 会优先调用第一个。


方法的传值问题：在方法中改变一个变量的值，方法外会怎样？
- （与 Python 一样）
- 如果传入int等，方法中改变值后，方法外不变
- 如果传入数组，方法外会跟着变
- 如果传入自定义对象，方法外会跟着变


## 初始化

```java
// 下面是一个声明+初始化对象的语言。
Cat one = new Cat();
```

以上语句完成了下面3给步骤
1. 声明一个对象：在栈里面开辟一个空间，内容为 null
2. 初始化一个对象：在堆里面开辟一个空间，初始化一个对象。
3. 通过赋值操作，把栈和堆关联起来：堆空间的内存号存入到栈空间。

### 构造方法

- 构造方法的方法名必须与类名相同
- 构造方法没有返回值
- 构造方法可以有参数或无参数
- 构造方法只能在实例化时被调用。不能在其它地方被调用，不能被普通方法调用。
- 如果没有显式指定构造方法，会自动指定一个无入参的构造方法
- 构造方法可以多态
- 构造方法可以用相互调用
- （不推荐）可以写一个同名的普通方法，使用不会有语法错误，但不推荐这么干。
- this关键词


```java

package com.guofei.learnjava;

public class Cat {
    // 属性：
    String name;
    int month;
    double weight;
    String species = "中华田园猫";

    public Cat() { // 无参数的构造方法
        System.out.println("无参构造一个猫"); // 构造方法不能有返回值
    }

    // 构造方法可以多态
    public Cat(String name) { // 有参数的构造方法
        this(); // 构造方法可以相互调用，必须放第一行
        System.out.println("有参构造一个猫");
        this.name = name; // （没啥用：如果不加this，会自动寻找最近的name赋值，就不是属性那个name，改名也可以解决此问题）
        this.speak(); // 构造方法可以引用普通方法。这里 this 可以省略
    }

    //方法
    public void speak() {
        System.out.println(name + ": 喵喵喵");
    }
}
```

使用：(下面两个会执行不同的构造方法)
```java
Cat one = new Cat();
Cat two = new Cat("花花");
```

## 封装

隐藏某些信息，以接口的方式提供给外界使用。
- 属性设为 private
- 创建 getter/setter 方法，方法名如 `setName`
- 在 getter/setter 中做属性访问控制
- 如果构造函数中给隐藏的属性赋值了，建议调用set方法赋值，以复用变量检查的代码。
- getter/setter 可以分别省略，以达到只读/只写效果

```java

public class Cat {
    private String name;
    private int month;
    public void setMonth(int month) {
        if (month <= 0) {
            System.out.println("年龄不能为负");
        } else {
            this.month = month;
        }
    }
    public int getMonth() {
        return this.month;
    }
}
```

##







## 继承
```java
// A.java
public class A {
    private int i;
    protected int j;

    public void func1() {
        System.out.println("Class A");

    }
}



// B.java
public class B extends A {
    public int z;

    public void func2(){
        super.func1(); // 注意这个 super 方法
        System.out.println("Class B");

    }

}

// C.java
public class C {

    public static void main(String []args){
        A a=new A();
        B b=new B();

        System.out.println("Hello world!");
        System.out.println(a instanceof A);
        System.out.println(b instanceof B);
        b.func1();

    }
}
```

- 重写 (Override)：子类可以写一个同名的方法，覆盖掉父类的同名方法。
    - 参数列表与被重写方法的参数列表必须完全相同。
    - 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
    - 子类方法的访问权限必须大于或等于父类方法的访问权限。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
    - 声明为 final 的方法不能被重写。
    - 声明为 static 的方法不能被重写，但是能够被再次声明。
    - 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
    - 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
    - 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
    - 构造方法不能被重写。
    - 如果不能继承一个方法，则不能重写这个方法。
    - 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 重载 (overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。


## 包

命名规则：
- 小写
- 按照域名倒叙

包文件管理，例如，我们创建了一个 `Cat` 类，然后想要另创建一个机器猫也叫 `Cat`. 这就需要另建一个包。

建立两个package，分别是如下内容：
```java
// com.guofei.animal
package com.guofei.animal;

public class Cat {
    public Cat(){
        System.out.println("宠物猫来了！");
    }
}

// com.guofei.robot
package com.guofei.robot;

public class Cat {
    public Cat(){
        System.out.println("机器猫来了！");
    }
}
```

调包有以下几种：

```java
import com.guofei.robot.Cat; // 方法1:加载指定类
import com.guofei.animal.*; // 方法2:加载所有类，会被精确指定的（上一条语句）覆盖，这个覆盖与 import 的顺序无关

// 方法3:使用时指定：
com.guofei.animal.Cat cat2=new com.guofei.animal.Cat();

// 一个坑：import 只能找到指定目录下的类，而找不到子文件夹的类。
```
