---
layout: post
title: 【Matlab】全汇总
categories: Matlab
tags:
keywords:
description:
order: 11001
---

*写了 8 年 Matlab，历经大大小小一百多个项目，留下这个 1.2 万字的笔记*

## 1. 统计

### 1.1 描述性统计

基本操作：  
画图后，点tool  点datastatistics 点save to workspace
```matlab
[值，行号]=max(x,[],1)
[值，列号]=max(x,[],2)
sum(x,1),sum(x,2),sum(x,3);min;max;mean同理
```

排序
```matlab
[sA,index] = sort(A,'descend',dim)
```


描述性统计量
```matlab
median %中位数   
mode %众数  
var     
std %标准差    
range %极差
var %方差，返回的是每一列的var
std %标准差   
moment %中心距

mean %平均值  
nanmean %忽略nan的平均数
geomean %几何平均
harmmean %调和平均

kurtosis(x) %峰度   
skewness %偏度

%分位数：
Q1=prctile(w,25);Q3=prctile(w,75);


cov() %协方差，返回协方差矩阵
corrcoef() %协方差
```

绘图
- 箱图
```matlab
Boxplot (x,notch1,sym1,vert)
Notch1=1凹口notch=0矩形
Sym1='* '    sym1='+'
Vert=0%水平
```
- cdf图
```matlab
x=random('unif',0,1,500,1);
[f,x0]=ecdf(x)
plot(x0,f)
% 等价于这段代码：
[h,stat]=cdfplot(x)%  统计量
```
- gscatter：类似plotpv的效果，但是可以取0,1以外的值，也可以取多个值
```matlab
x=1:100;x=x'
y=3*x+random('norm',10,100,100,1)
ind=[ones(25,1);0*ones(25,1);2*ones(50,1)];
gscatter(x,y,ind)
```
- plotpv
```matlab
plotpv(p,t)
```



核密度估计
```matlab

[f,xi]=ksdensity(x)%xi等分100份,f对应核密度估计
f=ksdensity(x,xi)%xi处的核密度估计值f
ksdensity(...)%只画图
....
```

其它图

```matlab
histfit  条形图，带拟合的

y=normpdf(x,mean(s),std(s));plot(x,y);   %画正态分布图

normplot        wblplot
qqplot
pareto%帕累托图
gscatter%散度图
tabulate(x)%频率表
cdfplot(x)%cdf图
normspec([10 inf],mu,sigma)
probplot&qqplot
QQ图(按分位数画图)
PP图(按累积概率画图)

fanplot
```



```
probplot(x)
probplot(distribution,Y)
```

### 1.2 假设检验

均值检验
```matlab
[h,sig,ci,stats]=ztest(x,mu,sigma,alpha)  %已知sigma未知mu。h=0,sig>0.05认为均值相等
[h,sig,ci,stats]= ttest(x,mu,0.05)   %单样本T检验。h=0,sig>0.05均值相等
ttest2(x,y)                    %独立样本T检验
ttest(x,y,alpha)             %配对样本T检验=ttest（x-y）
```

方差检验
```matlab
vartest(x,var)     %单样本方差检验
vartest2(x,y)      %独立样本方差检验
```

方差分析
```matlab
anova1              %实际上是三个以上的组的均值检验
[p,table,stats]=anova1(X)          %
[...]=anova1(X,group)           %group可以是矩阵或元胞

anova2              %双因素方差分析
anova2(data,rep)   %rep=1,每组1个数字,rep=2，每组2个数字
```

分布检验
```matlab
h =jbtest(x)，[h,p,jbstat,cv] =jbtest(x,alpha) % Jarque-Bera检验
h =kstest(x)            %Kolmogorov-Smirnov检验
h =lillietest(x)，[h,p,lstat,cv]=lillietest(x,alpha)。%Lilliefors检验
```
另外还有一种方法：首先对于数据进行标准化：Z = ZSCORE(X)，然后在进行2）的Kolmogorov-Smirnov检验，检验是否为标准正态分布，类似于对于方法2）的改进
```matlab
x=random('norm',0,1,200,1);
distname='norm';
pdca = fitdist(x,distname);
[h,p,ksstat,cv]  = kstest(x,'CDF',pdca);
%h=0接受原假设，认为服从'norm'分布
```




### 1.3 随机变量

分布的生成：
```matlab
pdf('name',X,A,B,C)%概率密度函数
cdf（'name',X,A,B,C）%累积分布函数，
random('name',A,B,C,m,n)%随机生成数字
icdf('name',x,A,B,C)              %cdf的反函数
mle('name',X,alpha)              %参数估计 mle('bino',n,alpha,N)比较特殊
```

|Mle:|||
|--|--|--|
||phat = mle('name',data)|分布函数名为dist的最大似然估计
||[phat,pci] = mle('name',data)|置信度为95%的参数估计和置信区间
||[phat,pci] = mle('name',data,alpha)|返回水平α的最大似然估计值和置信区间
||[phat,pci] = mle('name',data,alpha,p1)|仅用于二项分布，pl为试验总次数

class方式生成：
```matlab
pd = makedist(distname,Name,Value)
pd = fitdist(x,distname,'By',groupvar,Name,Value)：已知数据求参数（点估计）
% mle：已知数据求参数（极大似然估计）
```

pd的方法:

|方法|	举例|	备注|
|--|--|--|
|ProbDistUnivParam|||		
|pdf		|||
|cdf	|pd.cdf(1)||
|icdf	|pd.icdf(0.5)||
|iqr	|pd.iqr()|	IQR：3/4距差|
|mean 		|||
|median		|||
|std/var		|||
|random		|||
|paramci|	???||


随机种子：
```matlab
rng(seed)%seed是种子，正整数
rng('shuffle')%种子与当前时间有关
rng(seed, generator)%generator时，迭代的算法
rng('default')%seed=0,generator='twister'时的情况
```


randperm(N)随机排列

### 1.4 排列组合



1. 求n的阶乘
```matlab
factorial(n)
gamma(n+1)
v='n!'; vpa(v)
```
2. 求组合(数)
```matlab
combntns(x,m)    %列举出从n个元素中取出m个元素的组合。其中，x是含有n个元素的向量。
nchoosek(n,m)    %从n各元素中取m个元素的所有组合数。
nchoosek(x,m)    %从向量x中取m个元素的组合
```
3. 求排列(数)
```matlab
perms(x)         %给出向量x的所有排列。
prod(n:m)        %求排列数：m*(m-1)*(m-2)*…*(n+1)*n
prod(1:2:2n-1)    %求(2n-1)!!
prod(2:2:2n)        %求(2n)!!
prod(A)                %对矩阵A的各列求积
prod(A,dim)         %dim=1（默认）；dim=2，对矩阵A的各行求积（等价于(prod(A'))'）
```
4. 函数 cumprod() 累积求积函数：
```matlab
cumprod(n:m)        %输出一个向量[n n*(n+1) n(n+1)(n+2) … n(n+1)(n+2)…(m-1)m]
cumprod(A)           % 若A为矩阵：输出同维数的矩阵，按列累积求积
cumprod(A,dim)   % A为矩阵，dim=1或2，dim=1，默认，与上面一样；dim=2，按行累积求积。
```


列出排列组合：

```matlab
randperm(6)  %随机全排列
b = perms([1 1 1 0 0 0]) $全排列
b=nchoosek([1 1 1 0 0 0],3) $全组合
b = perms([1 1 1 0 0 0]);     %列出[1 1 1 0 0 0]所有的排列，此时就是6的全排列等于720
b = unique(b,'rows');     %找出所有排列中的唯一值，共20个
```


### 1.5 多元线性回归

```matlab
[b,bint,r,rint,stats]=regress(y,x,alpha)   (调整x为x=[ones(size(x),x)])  
b:系数，bint：系数的置信区间  
r:残差，rint：残差的置信区间  
stats：用于检验显著性，包含：相关系数的平方R^2，F，F对应的p(p<alpha时，方程显著)，残差的方差（前两个越大越好，后两个越小越好）  
```

```matlab
rcoplot(r,rint) %画残差和置信区间,可以找出异常点  
```


#### 1.5.1 多项式回归
```matlab
[p,S]=polyfit(x,y,m)%m是次幂  p是系数，S是误差矩阵  
polytool(x,y,m,alpha)%画图  
Y=polyval(p,x) 求预测值  
[Y,delta]=polyconf(p,x,S,alpha),预测值和置信区间Y±delta  
多元二次回归  
rstool(x,y,'model',alpha)  
%linear:线性  
%purequadration纯二次  
%interaction纯交叉  
%quadratic以上的和  
```

#### 1.5.2 非线性回归
```matlab
[beta,r,J]=nlinfit(X,y,FUN,beta0)   %高斯牛顿法的非线性最小二乘拟合
     beta是拟合系数，r是残差，J是雅克比矩阵 FUN是匿名函数/m文件函数
  r' * r就是残差平方和
funtion y=fun(a,x)
```

```matlab
ci=nlparci(beta,r,J,alpha)           %根据上一条的结果，得出置信区间
nlintool(X,y,FUN,alpha)           %!!!功能强大的画图工具！！！

函数  nlpredci                %y预测y值

格式  ypred = nlpredci(FUN,inputs,beta,r,J)   % ypred 为预测值，FUN与前面相同，beta为给出的适当参数，r为残差，J为Jacobian矩阵，inputs为非线性函数中的独立变量的矩阵值。

[ypred,delta] = nlpredci(FUN,inputs,beta,r,J)    %delta为非线性最小二乘法估计的置信区间长度的一半，当r长度超过beta的长度并且J的列满秩时，置信区间的计算是有效的。[ypred-delta,ypred+delta]为置信度为95%的不同步置信区间。

ypred = nlpredci(FUN,inputs,beta,r,J,alpha,'simopt','predopt')   %控制置信区间的类型，置信度为100(1-alpha)%。'simopt' = 'on' 或'off' (默认值)分别表示同步或不同步置信区间。'predopt'='curve' (默认值) 表示输入函数值的置信区间， 'predopt'='observation' 表示新响应值的置信区间。nlpredci可以用nlinfit函数的输出作为其输入。

!!!nlpredci   nlintool   spss线性回归，预测结果都不一样
```

#### 1.5.3 逐步回归
逐步回归用来解决共线性问题  

```matlab
step(x,y,inmodel,alpha)
h = refcurve(p)   %画图：在图中加入一条多项式曲线
```

tool工具回归
plot后，tool→basic fitting

#### 1.5.4 多重共线性问题

后果：
1、参数估计值β3的方差增大  
r23是x2, x3的共线性系数  
var（β3）=σ^2/Σx2^2/(1-r23^2)=.../(1-r23^2)  
VIF（方差扩大因子） =1/(1-r23^2)  

2、参数区间估计时，置信区间变大  
3、对系数进行t检验时，由于方差变大，会使得t值变小，从而使得本应否定“系数为0”的原假设被错误的接受  
4、R^2很高，F检验的显著性也很高，参数的t检验却不通过。  

总结：参数估计值方差增大，置信区间增大。方程通过检验，系数不通过检验。  


检验：VIF法，接近1说明共线性很弱，超过10说明共线性严重

补救：
1. 剔除变量法（简单粗暴）
2. 增加样本容量（很多时候，多重共线性是因为样本量太小）
3. 变换模型形式（用一阶差分回归，diff）
4. 逐步回归法：  
step1：对每一个解释变量和被解释变量做回归，以贡献最大为基础  
step2：逐个引入新变量，  
        if 引入后改进了R^2和F检验，且其它解释变量的t检验显著，保留该变量  
        elseif 引入后不改进R^2和F检验，且其它解释变量的t检验显著，认为是多余的  
        elseif 引入后不改进R^2和F检验，且其它解释变量的t检验变得不显著，认为有严重的多重共线性  


以下补救直接改变了OLS：
5. 岭回归法（是一种有偏估计）
6. 主成分法
7. 偏最小二乘法


#### 1.5.5 异方差
定义：误差项的方差是变化的（与解释变量有关）
后果：
。。。


#### 1.5.6 自相关
定义：误差项之间纯在相关关系
原因：
1、经济系统的惯性
2、经济活动的滞后效应
3、数据处理造成的相关（插值、平滑化等）
4、蛛网现象
5、模型偏差（省略了某个重要变量）


### 1.6 PCA
主成份分析  
[COEFF,latent,explained] = pcacov(V)  
where,  
V是协方差矩阵 p-by-p  
COEFF是主成份变换矩阵  
latent是特征值  
explained贡献率  

[COEFF,SCORE,latent,tsquare] = princomp(X)  
where,  
X是原始数据  
SCORE是每个样本每个主成份的得分  
tsquare是每个数据点的HotellingT2统计量  

```matlab
clear
clc
X=[
76.5	81.5	76.0	75.8	71.7
70.6	73.0	67.6	68.1	78.5
90.7	87.3	91.0	81.5	80.0
77.5	73.6	70.9	69.8	74.8
85.6	68.5	70.0	62.2	76.5
85.0	79.2	80.3	84.4	76.5
94.0	94.0	87.5	89.5	92.0
84.6	66.9	68.8	64.8	66.4
57.7	60.4	57.4	60.8	65.0
70.0	69.2	71.7	64.9	68.9
];
%%
%pcacov

num_variables=size(X,2);
V=cov(X);
[COEFF,latent,explained] =pcacov(V);%核心代码！！！
%COEFF转换矩阵，latent特征值，explained累积

%%
%可视化展示
row_names=cell(num_variables+1,1);
column_names=cell(1,num_variables);
for i=2:num_variables+1
row_names{i}=['X',num2str(i)];

end
for i=1:num_variables
column_names{i}=['PRIN',num2str(i)];
end
disp('---------------协方差矩阵--------------')
disp(V)
disp('---------------特征值------------------')
fprintf('特征值    累积\n')
disp([latent,explained])
disp('-----------------特征向量------------------')
disp([row_names,[column_names;mat2cell(COEFF,ones(1,5),ones(1,5))]])



%%
%直接输入原始数据
[COEFF,SCORE,latent,tsquare] = princomp(X)



%%
%注意：
%得出的COEFF和SCORE可能对应的行/列同时加上一个负号，也对
%X=X+100得出的结论也完全相同
%X=X/100得出的COEFF也相同
%计算SCORE时，每一项要减去均值，例如：
%[X(:,1)-mean(X(:,1)),X(:,2)-mean(X(:,2)),X(:,3)-mean(X(:,3)),X(:,4)-mean(X(:,4)),X(:,5)-mean(X(:,5))]*COEFF
%上式与SCORE完全相同

```


### 1.7 FA
```matlab
[lambda,psi,T,stats,F] = factoran(X,m)
X:n*d，样本容量n，d维
m：返回m个公共因子
lambda：d*m 第(i,j)个元素为第j个因子在第i个变量上的载荷(或系数)
psi：特定方差的最大似然估计
T：包含以下字段：（H0：公共因子个数为m）
loglike    最大对数似然函数
dfe       误差自由度((d-m)^2-(d+m))/2
chisq    H0的近似卡方统计量
p           H0的右侧显著性水平  p小说明m太少

[lambda,psi,T]=factoran(X,2,'xtype','covariance','delta',0,'rotate','none')
```

## 2. 代数

### 2.1 矩阵

```
dot（x,y）内积
cross（x，y）外积
std 标准差
等差数列：x=start_val:step:stop_val
X=linspace(start_val,stop_val,n)
等比数列：x=logspace(start_val,stop_val,n)
从10^a到10^b的等比


Size（x）=[行数，列数]
Length（x）=行列数中最大的一个
Numel（x）=总元素个数

Zores
Ones
Eye[m,n]  主对角线上是1的m*n矩阵
Diag（）一维变两维、两维变一维
 blkdiag(a1,a2,a3,a4)分块对角矩阵

Rand（）
Magic（）


B=reshap（A，a,b）
Transpose    非共轭转置
Ctranspose    共轭转置
rank 秩
Inv逆矩阵，pinv广义逆矩阵
rot90（A）逆时针转
rot90（A，k）逆时针转k次
Fliplr(a)  左右翻转 flipud(b)上下翻转
flipdim（A,k）k=1 上下翻转，k=2左右翻转
diag（v，k）一维变二维，第k条对角线是v
diag（X，k）二维变一维，提取第k条对角线
blkdiag（A,B,C）多个矩阵拼成对角矩阵
kron(A,B),把B乘以A的每个元素

+—*/^矩阵运算
.* 和./和.^是对应元素的运算

Det（）计算行列式
Rank（）秩
Orth（）标准正交基

```

### 2.2 矩阵代数

```
det    行列式（方阵）
inv  逆（方阵）
pinv 伪逆
rank 秩
norm 范数（方阵）
cond 条件数（方阵）
eigs特征值
eig  特征值和特征向量（方阵）
poly 特征多项式（方阵）
```

- orth  标准正交基  b=orth(a),```那么：b'*b=eye(rank(a))```
- lu    LU分解  [L,U]=lu(a),
```L*U=a  L是下三角矩阵的置换矩阵U是上三角矩阵
[L,U,P]=lu(a) % L*U=P*a ，L是下三角，U是上三角
```
- chol  Cholesky分解,
```
R=chol(a) % R'*R=a,R是上三角矩阵，a必须是正定矩阵(先用eig检验)
```
- qr    QR分解    [Q,R]=qr(a)   Q是正交矩阵，R是上三角矩阵，Q*R=a
- qz    QZ分解
- svd   SVD奇异值分解  
```
s=svd(a)s是奇异值组成的列向量
[U,S,V]=svd(a),a=U*S*V',U和V是正交矩阵，S是对角矩阵
```
- schur  schur分解，[U,T]=schur(a),U正交,T上三角,a=U*T*U'
- diag  提取矩阵对角线
- trace  迹
- tril  矩阵的下三角部分
- triu  矩阵的上三角部分


还有

```
rref([A,b])解方程   高斯消元法
null(A)  Ax=0的正交基础解
null(A,'r')  Ax=0的整数基础解
```

```matlab
A=compan(u)  
%u是多项式系统向量
%A的特征值是u的特征根

H=hadamard(n)
```

## 3. 分析

### 3.1 符号计算

符号计算
- 定义符号：
```
syms a b
```
- 赋值:
```
subs(a+b,{a,b},{3,4})
subs(f,old,new)
eg:subs(f,[a,b,c],[x1,2,3])
sub(f,k,[1:4])
```
- eval和double：把符号变成数字
- 运算
```
compose(f,g)  复合函数f（g（x））
finverse（f，v）反函数
```
- 导数和积分
```
diff(S,v,n)n阶导数
int(S,v)不定积分
int(S,v,a,b)定积分
```
- 极限
```
limit(S,x,s)
limit(S,a)
limit(S,x,a,'right')
limit(S,x,a,'left')
```
- 级数和
```
symsum(S)
symsum(S,v)
symsum(S,v,a,b)
symsum(S,a,b)
```
- 泰勒展开
```
taylor(S)
taylor(S,n)
taylor(S,n,x,a)
```

### 3.2 微积分


```matlab
limit（y,x,1,’right’）  极限

diff(f)%求导
diff(f,v)%求导，v是自变量
diff(f,n)%n阶导数
diff(f,'v',n)%

diff(X)%矩阵差分
diff(X,n)%矩阵n阶差分diff(diff(X))是二阶
diff(X,n,dim)

int(s)%不定积分
int(s,v)%不定积分，v是自变量
int(f,x,-1,1)         定积分

q=dblquad(fun,xmin,xmax,ymin,ymax)%二重积分
q=triplequad(fun,xmin,xmax,ymin,ymax)%三重积分

symsum（f,n,0,50）  求和公式


%梯度和方向导数
FX=gradient(F)


taylor（f，3，x，1）  %x-1的三阶泰勒展开
  taylor(log(x),x,'ExpansionPoint',1,'Order',4)
taylortool%图和工具：泰勒工具！！！

以下用匿名函数做
fzero（f,2）    %零点
fminbnd(f,0,2)    %极小值点
```

几种求积分的方法
1. trapz（y）梯形法
```matlab
dt=0.01
z=trapz(y) * dt % y是向量，dt是步长
Q = quad(FUN,A,B,TOL,TRACE)
```
2. quad辛普生法
```matlab
fun1
quad（'fun1',0,1）
```
3. quadl自适应lobatto法，适用于平滑、高精度情况
```matlab
qual1('fun1',0,1)
```
4. quadgk自适应GK方法，高精度、震荡情况.可计算广义积分
```matlab
dblquad(fun,xmin,xmax,ymin,ymax) % 二重积分
triplequad(fun,xmin,xmax,ymin,ymax,zmin,zmax) % 三重积分
```


### 3.3 多项式
```matlab
r=roots(p)%解方程
p=poly(r)%用解创建多项式
  poly（A）%返回特征多项式
polyval(p,x0)%多项式某点的值
conv(p1,p2)%多项式乘法
[q,r]=deconv(v,u)%多项式除法，q是商，u是余式
k=deconv(p)%多项式微分
k=deconv(a,b)%计算conv(a,b)的微分
[q,d]=polyder(a,b)%计算a/b的微分=q/d

residue
```






### 3.4 解方程
```matlab
% 方法1
x=fsolve(@fun,x0)     （最小二乘法）
其中fun可以是一个m文件、一个句柄

% 方法2：solve()（在符号函数中使用）
[x,y]=solve('x^2+(y-100)^2-89^2','x^2+y^2-10000');
x=double(x),y=double(y)

% 方法3：求根
fzero、roots
```
### 3.5 微分方程

1、通解
```matlab
dsolve('','')
% D2x代表二阶导数，Dx(0)代表初始解

[x,y,z]=dsolve('Dx=2*x-3*y+3*z','Dy=4*x-5*y+3*z','Dz=4*x-4*y+2*z','t')
x=simplify(x);y=simplify(y);z=simplify(z);

dsolve('x*Dy+2*y-exp(x)=0','y(1)=2*exp(1)','x')
```

2、数值解
```matlab
% 统一公式
[T,Y]=solver(@fun,tspan,y0)
[T,Y]=solver(@fun,tspan,y0,options)
options=odeset()
```

<table class="tableizer-table">
<thead><tr class="tableizer-firstrow"><th>名称</th><th>特点</th><th>说明</th></tr></thead><tbody>
 <tr><td>ode45</td><td>单步法，4、5阶龙格-库塔方法，精度中</td><td>首选，普遍</td></tr>
 <tr><td>ode23</td><td>单步，2、3阶龙格-库塔法，精度低</td><td>&nbsp;</td></tr>
 <tr><td>ode113</td><td>多步，Adams法，精度高</td><td>快</td></tr>
 <tr><td>ode23t</td><td>梯形</td><td>适度刚性情况</td></tr>
 <tr><td>ode15s</td><td>多步，Gear's反向数值积分，精度中</td><td>ode45失效时</td></tr>
 <tr><td>ode23s</td><td>单步，二阶Rosebrock算法，精度低</td><td>&nbsp;</td></tr>
 <tr><td>ode23tb</td><td>梯形，精度低</td><td>&nbsp;</td></tr>
 <tr><td>ode15i</td><td>可变秩，精度低</td><td>完全隐式微分方程</td></tr>
</tbody></table>



3、pdetool

### 3.6 复变函数
```matlab
real % 实部
imag % 虚部
conj % 共轭
abs % 模
angle % 辐角

[X,Y] = pol2cart(TH,R) % 极坐标转直角坐标
```

### 3.7 插值


1. 一维插值
```matlab
yi=interp1(X,Y,xi,method)
pp=interp1(X,Y,method,'pp')
method='nearest'/'linear'/'spline'/'cubic'
```
2. 傅里叶插值
```
（适用于周期函数）
yi=interpft(y,n)%把向量y扩展成n个
```
3. 二维插值
```
Zi=interp2(X,Y,Z,Xi,Yi,method,extrapval)
interp3
interpn
ndgrid%n维网格  与meshgrid类似
```
4. 三维插值：
```
插值1：
[X,Y]=meshgrid(,)   %x,y,z是非网格数据
Z=griddata(x,y,z,X,Y,’linear’)  %用残缺数据，插值成网格数据’linear’/’cubic’ /’nearest’
mesh(X,Y,Z)
插值2：
[X,Y]=meshgrid(,);
F=TriScatteredInterp(x,y,z); Z=F(X,Y);mesh(X,Y,Z)
```
5. 三次样条
```
csape 给定约束的三次样条
csapi 插值生成三次样条
csaps  平滑生成三次样条
cscvn  内插参数的三次样条
ppmak 分段多项式样条
spapi 插值生成B样条
spaps B样条平滑处理
spap2 最小二乘法B样条
spcrv 均匀划分的B样条
spmak B样条
rpmak 有理样条
rsmak 标准几何形状有理样条
stmak 整理成st形式
tpaps 模版平滑样条
rscvn 分段双圆弧hermite插值
```

### 3.8 傅里叶分析

```
fft一维傅里叶变换
fft2二维傅里叶变换
fftn  N维傅立叶变换

逆变换：
ifft
ifft2
iffn


abs幅值
angle相位角
unwrap增减2*pi使相位角差不超过pi

傅里叶变换（连续情况用符号计算）
F=fourier(f)
F=fourier(f,v)%F(v)
F=fourier(f,u,v)%F(v),f(u)
```

案例：
```
syms x k
f=cos(x)
f1=fourier(f)
f2=int(f.*exp(k.*t))
```


一套傅里叶代码：
```
%fft傅里叶样板
%%
%生成数据
clear
close all
t=0:0.01:200;
y=cos(50*2*pi*t)+0.5*cos(30*2*pi*t)+0.5*cos(70*2*pi*t);

%%
%傅里叶分析
nf=500;%采样点
fy=fft(y,nf);
mfy=abs(fy);


mfy=mfy/nf;ft=100*[1:nf]/nf;%100是采样频率  nf是傅里叶的采样点

%%
%画图：频域、相位角
subplot(2,2,1)
plot(t,y)
subplot(2,2,2)
plot(ft,mfy)%幅值
subplot(2,2,3)
afy=angle(fy);
uafy=unwrap(afy);%相位角
plot(ft,afy,'r*',ft,afy,'r')

subplot(2,2,4)
plot(ft,uafy,'go',ft,uafy,'g')

```

一套小波分析的代码：
```
%小波分析
%%
%生成信号，并展示
clear;clc;close all;
f1=5;f2=10;%频率1,2
fs=2*(f1+f2);
Ts=1/fs;%采样间隔
N=12%采样点数
n=1:N
y=sin(2*pi*f1*n*Ts)+sin(2*pi*f2*n*Ts);
figure(1)
subplot(2,1,1)
plot(y)
title('两个正弦信号')
subplot(2,1,2)
stem(abs(fft(y)))
title('两信号频谱')

%%
%定义滤波器
h=wfilters('db6','l');%低通
g=wfilters('db6','h');%高通
h=[h,zeros(1,N-length(h))];
g=[g,zeros(1,N-length(g))];%补零
figure(2)
subplot(2,1,1)
stem(abs(fft(h)))
title('低通滤波器')
subplot(2,1,2)
stem(abs(fft(g)))
title('高通滤波器')

%%
%Mallet分解算法
figure(3)
sig1=ifft(fft(y).*fft(h));%低通(低频分量)
sig2=ifft(fft(y).*fft(g));%高通(高频分量)
subplot(2,2,1)
plot(real(sig1));
title('分解信号1')
subplot(2,2,3)
plot(real(sig2))
title('分解信号2')
subplot(2,2,2)
stem(abs(fft(sig1)))
title('分解信号1频谱')
subplot(2,2,4)
stem(abs(fft(sig2)))
title('分解信号2频谱')
%%
%Mallet重构算法
sig1=dyaddown(sig1);%2抽取
sig2=dyaddown(sig2);%2抽取
sig1=dyadup(sig1);%2插值
sig2=dyadup(sig2);%2插值
sig1=sig1(1,[1:N]);%去掉最后一个0
sig2=sig2(1,[1:N]);%去掉最后一个0
hr=h(end:-1:1);%重构低通
gr=g(end:-1:1)%重构高通
hr=circshift(hr',1)';%位置调整圆周右移一格
gr=circshift(gr',1)';%位置调整圆周右移一格
sig1=ifft(fft(hr).*fft(sig1));%低频
sig2=ifft(fft(gr).*fft(sig2));%高频
sig=sig1+sig2;%源信号

figure(4)
subplot(2,2,1)
plot(real(sig1))
title('重构低频信号')
subplot(2,2,3)
plot(real(sig2))
title('重构高频信号')
subplot(2,2,2)
stem(abs(fft(sig1)));
title('重构低频信号频谱')
subplot(2,2,4)
stem(abs(fft(sig1)));
title('重构高频信号频谱')
figure(5)
plot(real(sig),'r')
hold on
plot(y)
legend('重构信号','原始信号')
title('重构信号与原始信号比较')
```

### 3.9 最优化

1. 一维优化问题fminbnd  
方法：黄金分割法（迅速缩小极值区间），抛物线法（提高解得精度）    
场景：一维，有边界   
min(F(x))  
s.t.x1<x<x2  
```
[x,fval,exitflag,output]=fminbnd('myfun',x1,x2,options)

1. FunValCheck:  
on 目标函数为复数或NaN时显示出错信息  
off 不显示出错信息

2. exitflag:
1 优化成功
0 迭代到最大(MaxFunEvals,MacIter)退出
-1用户自定义函数退出
-2边界调教不协调(x1>x2)
```
2. 无约束优化问题fminsearh  
方法：所用算法是单纯形搜索法，不需要计算梯度   
场景：无约束，多维，有梯度  
模型：min(F(x))  
代码：
```matlab
[x,fval,exitflag,output] = fminbnd('myfun',x0,options)
1. FunValCheck:
  on 目标函数为复数或NaN时显示出错信息
  off 不显示出错信息
2. OutputFcn 用户自定义的输出函数，它将在每个迭代步调用
3. PlotFcns   用户自定义的画图函数，它将在每个迭代步调用
4. exitflags  
  1  求解成功
  0  ...
  -1 ...
```
3. 无约束优化问题fminunc
```matlab
方法：所用算法是搜索法和梯度法结合
模型：min(F(x))
代码:
[x,fval,exitflag,output,grad,hessian]=fminunc('myfun',x0,options)
grad是x点的梯度：
[∂f/x1,∂f/x2,...,∂f/xn]
hessian矩阵：
[∂^2/x1^2,∂^2/x1x2,...,...]
```
4. 0-1规划
```matlab
bintprog???
模型：
min C'X
s.t. A*X<=b
      Aeq*X=beq
      xi=0或1
代码：[x,fval,exitflag,output]=bint('fun',A,b,Aeq,beq,x0,options)
```
5. 极小极大fminmax
```matlab
模型：
min(x)max(i){Fi(x)}
s.t.
{
A*X<=b
Aeq*x=beq
c(x)<=0
ceq(x)=0
lb<=x<=ub
}
[x,fval,maxfval,exitflag,output,lambda]=fminmax('fun',x0,A,b,Aeq,beq,lb,ub,nonlcon,options)
options指定选项：
Derivative:比较用户提供的梯度和有限差分法得出的梯度
Diagnostic:显示诊断信息
DiffMaxChange:有限差分法求梯度时自变量的最大改变量
DiffMinChange:有限差分法求梯度时自变量的最小该变量
GradConstr:约束函数的梯度
GradObj:目标函数的梯度
```
6. 约束优化问题fmincon
```matlab
[x,fval,exitflag,output,lambda,grad,hessian]=fmincon('fun',x0,A,b,Aeq,beq,lb,ub,nonlcon,options)
lambda: x处的拉格朗日乘子
grad: x处的梯度
hessian: x处的海森矩阵
```
7. 非线性最小二乘问题lsqnonlin
```
min(f(x)^2=f1(x)^2+f2(x)^2+...+fn(x)^2)
[x,resnorm,residual,exitflag,output,lambda,jacobian]=lsqnonlin('fun',x0,lb,ub,options)
```
8. 线性规划linprog
```
[x,fval,exitflag,output,lambda]=linprog('fun',A,b,Aeq,beq,lb,ub,x0,options)
```
9. 二次规划quadprog
```
模型：
$min (1/2*x'* H * x+c'x)$  
s.t.  
{  
Aeq*x=beq  
A*x>=b  
}  
代码：  
[x,fval,exitflag,output,lambda] = quadprog(H,f,A,b,Aeq,beq,lb,ub,x0,options)  
```
10. 目标到达问题
```
模型：  
[x,fval,attainfactor,exitflag,output,lambda] = fgoalattain(fun,x0,goal,weight,A,b,Aeq,beq,lb,ub,nonlcon,options)
```
11. optimset
```matlab
options=optimset('param1',value1,'param2','value2',...)
options=optimset%生成一个空optimset结构体
options = optimset(options,'Display', 'off');%输入旧的options
% optimset的内容:
1、Display  信息显示
off 不显示迭代信息
iter 显示每次的迭代信息
final 显示最终结果
notify 不收敛时才显示
2、MaxFunEvals 允许函数计算的最大次数，取正整数
3、MaxIter 允许最大迭代次数，取正整数
4、TolFun 函数值精度，取正整数
5、TolX 自变量精度，取正整数
% 输出的内容:
1、x  最优的x
2、fval 最优x对应的函数值
3、exitflag   用来评价最优化效果
1、一阶最优性条件满足容许范围
2、X的变化小于容许范围
3、目标函数的变化小于容许范围
4、重要搜索方向小于规定的容许范围并且约束违背小于options.TolCon
5、重要方向导数小于规定的容许范围并且约束违背小于options.TolCon
0、到达最大迭代次数或到达函数评价
-1、算法由输出函数终止
-2、无可行点
4、output 一个含多个参数的结构体
Iteraction  迭代次数
Algorithm  所用算法
FuncCount 函数评价次数
```
12. GUI界面:optimtool

## 4. 文件系统
保存：
```
save filename x -ascii -double
```

### 4.1. 文件夹操作

- `x=dir`返回一个结构体，包含当前文件夹的所有信息
- `pwd` 返回当前文件夹所在完整目录、
- `ls`返回一个多列char,包含当前文件夹的内容
- `mkdir/rmdir` 建文件夹/删文件夹   成功返回1
- `copyfile/movefile` 复制/移动
- `addpath(路径)`，把路径临时添加到可用列表中（重启后失效）
- `rmpath(路径)`，把路径中可用列表中删除
- `addpath(genpath(pwd))`;%把当前全部目录都add
- `fullfile` ：用于将若干字符串连接成一个完整的路径
- `fileparts`：fileparts用于将一个完整的文件名分割成4部分：路径，文件名，扩展名。例如：
```
f=fullfile('D:','Matlab','example.txt');
[pathstr,name,ext]=fileparts(f)
% pathstr=D:\Matlab name=example ext=.txt versn=’’
```
- 其它文件夹操作
`filesep` 用于返回当前平台的目录分隔符，Windows是反斜杠(\)，Linux是斜杠(/)。
- `pathsep` 返回当前平台的路径分隔符。Windows是分号(;)，Linux是冒号(:)。
- `exist` 可以用于判断目录或者文件是否存在，不同的返回值有不同的含义。例如：
```
>> f=fullfile('D:','Matlab','example.txt');
>>exist(f)
ans=2
>>exist('D:\Matlab')
ans =7
```
- `which` 可以通过一个函数或脚本名称得到它的完整路径,同时还能处理函数重载的情况，例如：
```
>> which abs(0)
C:\MATLAB7\toolbox\matlab\elfun\@double\abs.bi  % double method
>> which abs(single(0))
C:\MATLAB7\toolbox\matlab\elfun\@single\abs.bi  % single method
```
- `isdir` 判断一个路径是否代表了一个目录，例如：
```
>> p='D:\Matlab';
>> f=fullfile(p,'example.txt');
>> isp=isdir(p)
isp=1
>> isf=isdir(f)
isf=0
```
- `cd` 用于切换当前工作目录。例如：
```
>>cd('c:/toolbox/matlab/demos')        %切换当前工作目录到demos
>>cd ..        %切换当前工作目录到matlab
```
- `pwd`:返回当前工作目录的路径。例如：
```
>> pwd
ans =C:\MATLAB7\work
```
- `path`:用于对搜索路径的操作。例如：
```
<<path        %查询当前所有的搜索路径（MATLABPATH）
<<p=path                %把当前的搜索路径存在字符串变量p中
<<path(‘newpath’)                %将当前搜索路径设置为newpath
<<path(path,’newpath’)        %向路径添加一个新目录newpath
<<path(’newpath’, path)        %向当前搜索路径预加一个新目录nespath
```
- `what`:用于显示出某目录下存在哪些matlab文件；若输入完整路径，可列出指定目录下的文件。
```
<<what
<<what dirname
<<what(‘dirname’)
其中dirname是要查找的路径的名字，路径在matlab的搜索路径内时，没有必要输入全名，只输入最后或最后两级就够了。
```


### 4.2 二进制读写
1. fscanf
```
%s   !!!问题：空格丢失
%c   ！！！没有上述问题，返回的是带空格和回车的char
**可用于SQL语句的读写！**
```
2. fget
```
fgetl;%不返回换行符，是m-文件,调用fgets
fgets%返回换行符，是build-in，可以指定字符数量
```
3. textsan(最常用)
```
适合读入大文件
可以从任何位置开始读入
**有很多变种，请doc后深入阅读**
C = textscan(fileID,formatSpec,N)
C = textscan(str,formatSpec,N)
%3.1f  表示算上小数点，读入3位，小数点后1位
*1d
`*`表示跳过这个，不放到输出里面
% 还有很多，详见帮助
```
4. fread
读入的是ASCII码
5. importdata('test1.txt')
6. textread
```
[a,b,c]=textread('filename','format');
逐渐被textscan取代
调用了dataread函数
C = textscan(fileID,formatSpec,N)
C = textscan(str,formatSpec,N)
```
7. dlmread和dlmwrite
```
dlmread调用fread
mat=dlmread('filename','\t')
dlmwrite调用fwrite
```
8. csvread,csvwirte
```
csvread调用dlmread
csvwrite调用dlmwrite
```



### 4.3 声音

傅里叶分析：
```Matlab
[y,Fs,bits]=wavread('cricket.wav');%读出信号，采样率和采样位数。
y=y(:,1);%我这里假设你的声音是双声道，我只取单声道作分析，如果你想分析另外一个声道，请改成y=y(:,2)
sigLength=length(y);
Y = fft(y,sigLength);
Pyy = Y.* conj(Y) / sigLength;
halflength=floor(sigLength/2);
f=Fs*(0:halflength)/sigLength;
figure;plot(f,Pyy(1:halflength+1));xlabel('Frequency(Hz)');
t=(0:sigLength-1)/Fs;
figure;plot(t,y);xlabel('Time(s)');
```

去噪：
1. 如果噪声是特定频率的周期噪声（periodic noise），比如说50hz，那么你可以用matlab的filter，作一个低通、高通、带通或者带阻滤波。
2. 如果声音是高斯白噪声。那就用自适应滤波（adaptive filter,wiener filter）。这里涉及到对噪声的采样、计算特征值以及决定阶数的问题。
3. 幸好我们可以“耍赖”——用cool editor。用它打开wav文件，用鼠标把一段噪声圈起来，采样，然后直接选择去噪就可以了。各大网站有介绍。

例子：matlab去除50hz噪声。
```
我用电脑录了一段声音，里面有50hz的周期噪声（因为受交流电干扰）。而我自己的声音频率最低是90hz。我使用了一个10阶butterworth高通滤波器，边带是70hz(介于50跟90之间)。
问题是，这不能直接用。因为声音文件的采样率是22k，70相对于22k来说太小了。所以我得先把我的声音欠采样，然后再滤波，然后再插值。程序如下。
[k,Fs,bits]=wavread('mywav.wav');
k=k(:,1);
y_temp=k(1:90000);
dfactor=3;
y=decimate(y_temp,dfactor);
[b,a] = butter(10,70/(Fs/(dfactor*2)),'high');
y=filter(b,a,y);
y=interp(y,dfactor);
sigLength=length(y);
Y = fft(y,sigLength);
Pyy = Y.* conj(Y) / sigLength;
halflength=floor(sigLength/2);
f=Fs*(0:halflength)/sigLength;
figure;plot(f,Pyy(1:halflength+1));xlabel('Frequency(Hz)');
sigLength=length(y_temp);
Y = fft(y_temp,sigLength);
Pyy = Y.* conj(Y) / sigLength;
halflength=floor(sigLength/2);
f=Fs*(0:halflength)/sigLength;
figure;plot(f,Pyy(1:halflength+1));xlabel('Frequency(Hz)');
t=(0:sigLength-1)/Fs;
figure;plot(t,y,t,y_temp);xlabel('Time(s)');
wavplay(y,Fs);
wavplay(y_temp,Fs);
```

回放：使用wavplay函数
```
wavplay(y,Fs)；
```

### 4.4 图像

读入图像
```
y=imread('文件名')

A = imread(filename)
A = imread(filename,fmt)
A = imread(___,idx)
A = imread(___,Name,Value)
[A,map] = imread(___)
[A,map,transparency] = imread(___)
imshow(X,map)
```

idx：动图中的图片序号例如：
```Matlab
A = imread('corn.tif','PixelRegion',{[1,2],[2,5]});
```
表示读入1~2和2~5

显示图像
- 方法1
```
imshow(A)%A是矩阵
imshow('pic.png')%直接显示图片文件
```
- 方法2
```
% imshow会自动拉伸，image不会自动拉伸
image(A)
```
- 方法3(索引图像)
```
image(X);
colormap(map);
% 也可以这样：
imshow(X,map)
```
- 方法4（灰度图像）
```
imshow(I,32)%32阶灰度
imshow(I,[low,high])%自定义调色板
```

rgb2gray
```
I=rgb2gray(A)
```

图像写入文件
```
imwrite(imgGray,'gray.jpg')
```


数据结构：
1. 真彩色：RGB的M*N*3矩阵，0~255整数
2. 索引图像  索引矩阵+调色板


### 4.5 动画

1. 动画生成：句柄方式
```
set(h,'erasemode',erasemode)%h是需要执行动画图像的句柄，一般都是由line或者plot创建
for i=1:n
    set(h,'xdata',xdata,'ydta',ydata)%更新图像的坐标数据
    drawnow%刷新屏幕后再执行下一条，如果不用drawnow，刷新和下一条语句将会同步执行
end
```
2. 动画保存：保存到变量和文件中
```
for j=1:n
    %这里输入我们的绘图命令
    M(j) = getframe;
end
%%
movie(M)
%关于getframe：
getframe(gcf), getframe(gca),getframe(h,rect)
[left bottom width height]
%movie：显示到屏幕
movie(M,n,fps)
%RGB转M
M=IMmovie(RGB)
%单帧显示方法
image(M(1).cdata)
```
3. 保存到gif的方法
```
for i=1:30
    im=frame2im(M(i));
    [I,map]=rgb2ind(im,256);
    if i==1
        imwrite(I,map,'out.gif','gif','loopcount',inf)
    else
        imwrite(I,map,'out.gif','gif','writemode','append')
    end
end
```

### 4.6 Excel

```
[num,txt,raw,custom] = xlsread(filename,sheet,xlRange,'basic',processFcn)

xlswrite(filename,A,sheet,xlRange)
filename = 'testdata.xlsx';
A = {'Time','Temperature'; 12,98; 13,99; 14,97};
sheet = 2;
xlRange = 'E1';
xlswrite(filename,A,sheet,xlRange)
```



### 4.7 SQL

配置：
```
1. 安装mysql_installer_community_V5.6.21.1.msi  
2. 将mysql-connector-java-5.1.33-bin.jar文件拷贝到......\MATLAB\R2015b\java\jar\toolbox  
3. 到......\MATLAB\R2015b\toolbox\local目录下，找到classpath.txt文件，打开，并添加用来加载mysql的jdbc驱动语句：  
$matlabroot/java/jar/toolbox/mysql-connector-java-5.1.33-bin.jar  
4. 重新打开MATLAB即可  
```



使用：

```
%代码功能：从txt中读入sql语句，执行sql语句

file_name='sql_all.txt';
bid=fopen(file_name,'r');
sql_sq=fscanf(bid,'%c');
fclose(bid);
conn = database('tennis','root','1234','com.mysql.jdbc.Driver','jdbc:mysql://localhost:3306/');
ATP=fetch(conn,sql_sq)
```

### 4.8 压缩

- zip
- unzip:解压ZIP到当前文件夹，并返回文件名列表
```
unzip(zipfilename)
unzip(zipfilename,outputdir)
filenames = unzip(zipfilename,outputdir)
```
- gzip:把文件压缩为.gz格式
```
gzip(files)
gzip(files,outputdir)
filenames = gzip(...)
```
- gunzip 解压.gz到当前文件夹(GNU)
```
gunzip(files)
gunzip(files,outputdir)
gunzip(url, ...)
filenames = gunzip(...)
```
- tar 支持 .tgz或.tar
```
tar(tarfilename,files)
tar(tarfilename,files,rootfolder)
entrynames = tar(...)
tar('backup.tgz','.');
```
- untar


### 4.9 各种print

1. Print: 把函数图形保存成图片
```
用法：先plot，然后
print('-dpng','文件名.png')
-dbmp：保存为bmp格式
-djpeg：保存为jpeg格式
-dpng：保存为png格式
-dpcx：保存为pcx格式
-dpdf：保存为pdf格式
-dtiff：保存为tiff格式
```

2. fopen：文件打开
```
fid = fopen('filename','permission')
fid: (正整数)：表示文件打开成功，文件代号是N.
fid=-1 : 表示文件打开不成功。
permission:
r读取,必须存在
w 写入，不存在则创建，存在则覆盖
a 写入，创建，存在则不覆盖而是添加
r+ 读+写，不存在则不创建
w+ 读+写，创建，覆盖
a+ 读+写，创建，不覆盖而是添加（追加式打开）
 W 写，无自动刷新功能
A 读,无自动刷新功能
```
3. fclose：用完记得关闭
4. 二进制读写
```
fread   二进制读
fwrite  二进制写
ftell    返回文件位置指针
fseek  移动文件位置指针
```
5. 文本读写：fprintf，fscanf
```
fprintf %把数据写入文本文件中
fprintf(bid,format,data)
%c 单个字符
%d 有符号十进制数（%i也可以）
%u 无符号十进制数
%f 浮点数（%8.4f表示对浮点数取8位宽度，同时4位小数）
%o 无符号八进制数
%s  字符串
%x 小写a-f的十六进制数
%X 大小a-f的十六进制数
fscanf(fid,format,size)
```
6. 屏幕显示
```
fprintf%显示在屏幕上
```

### 4.a 网页

网页读写：
```
url=['http://dc.simuwang.com/product/HF00000AJV.html']
XML_data=urlread(url);
fid=fopen('kline.txt','w');
fwrite(fid,XML_data);
fclose(fid)
```

用默认浏览器打开网页：
```
web('http://www.ilovematlab.cn/forum-238-1.html','-browser')
```

ftp
```
f = ftp(host,username,password)
```

## 5. 数据结构


显示数据类型
```
class(x)
```

基本类型  
- double  
- single  
- 整型：uint8, uint16, uint32, uint64, int8, int16, int32, int64  

### 5.1 cell
```
cellfun(@myfun1,my_cell)
%逐行计算，放回mat

mat2cell(my_mat,[1,1,1,1],[1,1,1,1])
%后两个矩阵是cell每格的矩阵大小
```

### 5.2 struct

```
fieldnames(s)%返回字段名
getfield(s,fieldname)%相当于s.fieldname
setfield(s,fieldname,v)%相当于s.fieldname=v
rmfield(s,fieldname)%删除字段
isfield(s,fieldname)%判断是否是字段
isstruct(s)%判断是否是struct
orderfields%给字段排序
```

stuctfun

### 5.3 table

方式1:读取文件生成table
```
T = readtable(FILENAME,'FileType',FILETYPE)
% .txt, .dat, .csv, .xls, .xlsx, .xlsb, .xlsm, .xltm, .xltx, .ods:
'ReadVariableNames'     0/1  第一行是否是变量名
'ReadRowNames'    0/1 第一列是否是行名
'TreatAsEmpty'   string 或 cell of string 如果某cell为空，用什么代替
'Sheet'      
'Range'   
'basic'
```

方式2：直接构造
```
T = table(var1,...,varN,Name,Value) % name='RowNames'或'VariableNames'
% 变量可以是多种对象，例如：
T = table(categorical({'M';'F';'M'}),[45;32;34],... {'NY';'CA';'MA'},logical([1;0;0]),...'VariableNames',{'Gender''Age''State''Vote'})
```


方式3：array2table
```
T = array2table(my_array,Name,Value)
% my_array可以是matrix或cell
% name = 'RowNames'或'VariableNames'
```


取table中的数据
```
% 1. 返回matrix或cell
T.v1

% 2. 返回matrix或cell
T.v2(3)
T.v2([4,3])

% 3. 返回table:
T(1,1)
T(:,2)
T([3,2],:)

% 4. 用变量名返回table
T('c','v3')
T('c',:)
T(:,'v3')
T(:,{'v1','v3'})
```

修改
```
% 删除
T('c',:)=[]

% 添加列：赋值法
T.new_variables=[4;5;6;7];%添加mat
T.new_variables={6;4;7;8};%添加cell

% 添加列：合并法
T_new=[T_add,T]

% 添加行：合并法
T_new=[T_add;T]
```

保存
```
writeable(nasdaq,'mydata.csv')  
writetable(T,'mydata.txt','Delimiter',' ')
```

互相转化
```
table2array
struct2table
```

varfun:基于 table 的函数
```
B = varfun(@myfun,A, 'PARAM1',val1, 'PARAM2',val2, ...)

```
- `@myfun`：输入是A.var1，输出是一个matrix或cell，进而合并到B中
- 'InputVariables'：所需要计算的列。值：
  1. 列名（字符串）     例如：{'variable2','variable3'}
  2. 列号（数字）      例如：[3,2]
  3. 逻辑矩阵         例如：logical([0,1,0,1,0,0])
- 'GroupingVariables'。分组计算，当分组时，@myfun的输入变为每组的列
- 'OutputFormat'。输出格式：'uniform', 'table', 'cell'
- 'ErrorHandler' 。错误时，运行@myfun2

rowfun：行函数，比varfun应用场景更广泛
```
B = rowfun(@myfun,A, 'PARAM1',val1, 'PARAM2',val2, ...)
```
- `@myfun`: function [y1,y2,y3]=myfun(x1,x2,x3,x4)，每次读入一行
- 'GroupingVariables'。如果有这个值，@myfun的输入是mi*ni的变量，而不是单纯的一行了
- 'OutputVariableNames'，输出格式：'uniform', 'table', 'cell'



基于 table 的排序函数
```
 B = sortrows(A,VARS,MODE)
```
- 当vars='RowNames'，意思是按行名排序
- MODE is 'ascend' (the default) or 'descend'


连接
```
[C,IB] = join(A, B, 'PARAM1',val1, 'PARAM2',val2, ...)

'Keys':共同的列名
'LeftKeys'  'RightKeys'  左表和右表
'LeftVariables'  C表中包括A表中的那些字段
'RightVariables'
'KeepOneCopy'
```


innerjoin
```
[C,IA,IB] = innerjoin(A, B, 'PARAM1',val1, 'PARAM2',val2, ...)
'Keys', 'LeftKeys', 'RightKeys'
'LeftVariables'   'RightVariables'


[C,IA,IB] = outerjoin(A, B, 'PARAM1',val1, 'PARAM2',val2, ...)
'Keys', 'LeftKeys', 'RightKeys'
'MergeKeys'
'LeftVariables', 'RightVariables'
'Type' = 'full', 'left', or 'right'
```


其它
```
size

intersect 交集。返回两表中的相同的行，返回table  
setxor 差集
ismember 查询表A中的行是否在表B中也出现，回逻辑向量  
setdiff 查询两表之间的差异，返回table  
unique 返回的表中没有相同的行  
sextor 两个集合交集的非  
union 两个集合的并  
join 自然连接  
innterjoin 内连接  
outerjoin 外连接  

Data organization的操作  
summary 返回table的基本信息  
stack 把table的各列摞成一列  
unstack 把table的某一列展开成为若干列  
ismissing 找到table中那些没有赋值的项，返回logical index  
standizeMissing 给未赋值项赋默认值  
```


stack&unstack
```
Storm = [3;3;1;3;1;1;4;2;4;2;4;2];
Town = {'T1';'T3';'T1';'T2';'T2';'T3';...
    'T2';'T1';'T3';'T3';'T1';'T2'};
Snowfall = [0;3;5;5;9;10;12;13;15;16;17;21];
T = table(Storm,Town,Snowfall)
W = unstack(T,'Snowfall','Town')


[W,it] = unstack(T,'Price','Stock','AggregationFunction',@mean)
```

### 5.4 字符串

字符串格式清洗

```
char(hex2dex())     %unicode转汉字
[data1,data2,data3,data4]=textread('myfile.txt','%n%n%n%n','delimiter', ',')
 findstr(str1,str2)%查找

%unicode转汉字2
ind=findstr(k,'\u');
dd=[k(i+2),k(i+3),k(i+4),k(i+5)];
    out_put(c)=char(hex2dec(dd));
    c=c+1;
```

ascii码  
```
char（）   数字转字符  元胞转字符
abs（）      字符转ascii码
```

时间：
```
现在时间：
date      %字符串
now      %连续数字时间
clock      %向量时间

datestr()   %转字符串     datenum()    %转数字    datevec()     %转向量
datenum(‘20150101’,’yyyymmdd ’)
yyyymmdd HH:MM:SS
```

进制：
```
bin二进制 hex十六进制   dec十进制
base2dec（数据，进制）
dec2base(你的数，进制，位数)
```

元胞函数
```
cellfun（@（x）{你的函数 }，元胞）
```

矩阵转元胞
```
n = 10;
a = rand(n);
acell = mat2cell(a,ones(n,1),ones(n,1));
```
元胞合并
```
[a,b]
```

```
rats（1.5）小数转换成分数，并变成字符格式
num2str(11,'%02d')转换字符串自动加0
```

字符串

```
C = textscan(str,formatSpec,N)


K = strfind(TEXT,PATTERN)
s = 'How much wood would a woodchuck chuck?';
      strfind(s,'a')    returns  21
      strfind('a',s)    returns  []
      strfind(s,'wood') returns  [10 23]
      strfind(s,'Wood') returns  []
      strfind(s,' ')    returns  [4 9 14 20 22 32]


TF = strcmp(S,C) % 比较两个字符串是否完全相等，是，返回真，否则，返回假
% strncmp    比较两个字符串前n个字符是否相等，是，返回真，否则，返回假
% strcmpi    比较两个字符串是否完全相等，忽略字母大小写
% strncmpi   比较两个字符串前n个字符是否相等，忽略字母大小写
% isletter  检测字符串中每个字符时否属于英文字母
% isspace    检测字符串中每个字符是否属于格式字符（空格，回车，制表，换行符等）
% isstrprop  检测字符每一个字符是否属于指定的范围
```


```
a='  a';b='b  b';c='cccc';m=''
% 获取字符串长度
length(a)     
% 连接两个字符串,每个字符串最右边的空格被裁切
d=strcat(a,c)  
length(d)

% 连接多行字符串,每行长度可不等，自动把非最长字符串最右边补空格
% 使与最长字符串相等，会忽略空字符串
e=strvcat(a,b,m)
size(e)

% char连接，空字符串会被空格填满
f=char(a,b,m)
size(f)

% 字符串替换和查找   
% strrep(str1,str2,str3)
% 把str1中所有的str2字串用str3来替换，区分大小写

% strfind(str,patten) 查找str中是否有pattern，返回出现位置，没有出现返回空数组
% findstr(str1,str2)   查找str1和str2中，较短字符串在较长字符串中出现的位置，没有出现返回空数组
% strmatch(patten,str) 检查patten是否和str最左侧部分一致
% strtok(str,char)     返回str中由char指定的字符串前的部分和之后的部分，
mm='youqwelcome';
[mm1,mm2]=strtok(mm,'q')
% blanks(n)            创建有n个空格组成的字符串
% deblank(str)          裁切字符串的尾部空格
% strtrim(str)          裁切字符串的开头和尾部的空格，制表，回车符
% lower(str)           将字符串中的字母转换成小写
% upper(str)            将字符串中的字母转换成大写  
% sort(str)              按照字符的ASCII值对字符串排序
% num2str         将数字转换为数字字符串
% str2num          将数字字符串转换为数字
% mat2str          将数组转换成字符串
% int2str          把数值数组转换为整数数字组成的字符数组

CELL数组中的字符串比较：
c=cell(2,1);
c(1,1)=cellstr('xxx');
c(2,1)=cellstr('yyyyyyy');
strcmp(c{1,1},c{2,1});

isequal   Test arrays for equality, 可用来比较两个字符数组是否相同。
```


### 5.5 正则表达式

regexp——用于对字符串进行查找；
regexpi——用于对字符串进行查找，但不区分大小写；
regexprep——用于对字符串进行查找并替换。


[o11,o22,o33]=regexpi(str,expression,'start','end','match')

**str可以是cell，这时natgout也是元胞**

```
[match,noMatch] = regexp(str,expression,'match','split')
combinedStr = strjoin(noMatch,match)%'split'的逆运算
```

## 6. 可视化

### 6.1 画图
Plot

- 线形
```
-	实线
-.	点画线
--	虚线
：	点线
```
- 颜色
```
r	红,g	绿,B	蓝,C	蓝绿,M	洋红,Y	黄,K	黑,w	白
```
- 点
```
+,o,*,.,X,S	方格,D	菱形,^v<>	三角形（4个方向）,P	五边形,h	六边形,
```
- 其它配置
```
'LineWidth' 线宽
'MarkerEdgecolor' 标记点框色
'markerfacecolor' 标记点填充色
'Markersize' 标记点大小
```
- Axis
- 范围       
```
[Xmin,Xmax,Ymin,Ymax]
auto 自动调整区间
manual 冻结
tight用户数据范围为坐标轴范围比例
```
- 高低长宽
```
Equal等比例
square方形
normal 自动
```


set：用来改各种配置
```
set(gca,'xtick',[0:0.5:2])   坐标轴刻度
set(gca,'xticklabel',{'hua','ha','ni','s','r'}) 坐标轴刻度名
set(gca,'FontName','Times New Roman','FontSize',14)设置坐标轴刻度字体名称，大小‘FontWeight’,’bold’ 加粗 ‘FontAngle’,’italic’ 斜体
对字体的设置也可以用在, xlabel, ylabel等中
set(gcf,'toolbar','none')
set(gcf,'color','red')
set(gca,'xcolor','red')
set(gca,'ylim',[ymin,ymax]); %其中ymin，和ymax是y轴刻度的上下限
set(gca,'XLim',[0.01 1000]);%X轴范围
set(gca,'XMinorTick','on');% 小刻度
set(gca,'XTick',[0.01 0.1 1 10 100 1000]);
set(gca,'XGrid','on');  %网格
set(gca,'XMinorGrid','off');%小线网格
cursor on %允许选择数据点
xlabel('dd','rotation',30) %旋转坐标轴名字
text(x,y,'string')%标注点
```

图例
```
legend('a','Location','best') 图例位置放在最佳位置
LEGEND(string1,string2,string3, ...)
location后面的属性可以是：。。。
```
eg:
```
legend([b,x],'Carrots','Peas','Peppers','Green Beans')%b,x是句柄
Axis on    axis off隐藏坐标轴
Box on    box off 隐藏边界线
```
```
semilogx
semilogy
loglog
annotation('arrow',[0.1 0.2],[0.1 0.9])   %画向量看help:line/arrow/doublearrowtextarrow/rectangle/
subplot（2，2，i）；plot(,);title(‘标题’);xlaber;ylaber
[AX,H1,H2]=plotyy(X1,Y1,X2,Y2)画双坐标图
AX(1)表示左坐标轴set(AX(1),’xtick’,[])
AX(2)表示右坐标轴
H1 左线set(H1,’linestyle’,’填入线’,’color’,’填入颜色’)
H2 右线
```


其它绘图
```
polar(theta,rho) 极坐标绘图
[x,y]=pol2cart(theta,rho)%极坐标转直角坐标
datetick('x','yyyymmdd')   %x轴变日期
hist(x,20)  直方图 20格
b=hist(x,20)  返回每一格的数量
bar(x);bar(x,y); 柱状图
barh垂直柱状图
bar3 bar3h%三维图
pie %饼图
contour(x,y,z,4) %画4条等高线
[c,h]=contour(x,y,z,[4,1.6])% 画指定等高线    clabel(c,h)  %并标注
contourf（）%画等高线并涂色
scatter(x,y,s,c)    %类似motion art的散点图
scatter3
stem火柴杆 stem3
compass罗盘图；复数向量图
feather羽毛图；
quiver向量图
[U,V,W]=surfnorm(X,Y,Z)%产生向量数据
quiver3(X,Y,Z,U,V,W,0.3)
comet comet3%彗星图
comet(x,y,p)  x,y是列向量，p是尾巴长度
ribbon%彩带图
stairs
rose
errorbar
area%区域图
convhull%凸包图
```

三维图：
```
Plot3(x,y,z);
[X,Y]=meshgrid(x,y);plot3(X,Y,Z)
surf(X,Y,Z)
rotate3d on
mesh     网状图    waterfall(x,y,z);瀑布图 waterfall(x',y',z');  瀑布图（y方向）
meshc(x,y,z);网状图+等高图  meshz 带底座的图   surfc(x,y,z); 曲面图与等高线
contour3(peaks, 20); 曲面在三度空间中的等高线  
contour(peaks, 20); 等高线在XY平面的投影
[C,h]=contour(...)返回等高矩阵C和句柄h
clabel(C)添加等高矩阵标签
```



网格插值1：
```
[X,Y]=meshgrid(,)   %x,y,z是非网格数据
Z=griddata(x,y,z,X,Y,’linear’)  %用残缺数据，插值成网格数据’linear’/’cubic’ /’nearest’
mesh(X,Y,Z)
```
插值2：
```
[X,Y]=meshgrid(,);
F=TriScatterInterp(x,y,z); Z=F(X,Y);mesh(X,Y,Z)
patch（X,Y,Z,C） 三维板
fill(X,Y,C) 二维板填充
fill3(X,Y,Z,C)三维板
patch的属性:
'XData' 'YData' 'ZData'
vertices faces
marker 'o',linestyle '-.',linewidth线宽，
```

匿名函数绘图：
```
ezplot3(funx,funy,funz);ezplot(funx,funy,funz,[tmin,tmax])
ezplot3(…,’animate’)                %动画
ezplot3(axes_handles,…);h=ezplot3(…)

ezmesh(fun,[xmin,xmax,ymin,ymax]);fun(x,y)
ezmesh(funx,funy,funz);参数方程funx(s,t),funy(s,t),funz(s,t)
ezsurf同理

Grid on
Rotate3d on
```

向量场图：
```
[X,Y]=meshgrid(-3:0.4:3);Z=-3*X.^2-Y.^2;
[U,V,W]=surfnorm(X,Y,Z);%计算法向量
quiver3(X,Y,Z,U,V,W,0.2)
```

动画制作：
1、set法
2、Z=peaks
```
for i=1:20
  surf(sin(i)*Z,Z)
  F(i)=getframe
end
movie(F)
```

图像存储：
```
x=1:10;
y=2.*x;
plot(x,y);
result=getframe(gcf);%getframe(gca),movie(result,30)
image(result.cdata);
colormap(result.colormap);
save result;
```


rotate(h,[0,0,1]),60)沿向量旋转

```Matlab
x = 0:.2:12;
plot(x,bessel(1,x),x,bessel(2,x),x,bessel(3,x));
legend('First','Second','Third');
legend('First','Second','Third','Location','NorthEastOutside')
b = bar(rand(10,5),'stacked'); colormap(summer); hold on
x = plot(1:10,5*rand(10,1),'marker','square','markersize',12,...
        'markeredgecolor','y','markerfacecolor',[.6 0 .6],...
         'linestyle','-','color','r','linewidth',2);
hold off
legend([b,x],'Carrots','Peas','Peppers','Green Beans',...
          'Cucumbers','Eggplant')
text（x,y,'点1'）
```

plotmatrix


### 6.2 句柄方式
- gcf ：返回当前figure对象的句柄
- gca：返回当前axes对象的句柄
- gco：返回当前鼠标点击的句柄
- shg：把当前窗口放到最前端


关于gcf：
figure中有用的属性：
    Position：位置
    CurrentPoint：鼠标位置
    Color：颜色
    ToolBar，MenuBar：工具栏是否显示，  'none'

关于gca:
axes(axes_handle)%把axes_handle置为当前句柄
axes_handle=axes()%当前figure上建立一个axes

subplot()也是返回gca

axes中有用的属性：
```
Box：上和右框‘on’,'off'
XGrid，YGrid：网格线‘on’,'off'
XMinorGrid，YMinorGrid：网格线（更密的）‘on’,'off'

Xlim：范围
 XlimMode：自动/手动
XScale：log/linear


Color：颜色
XColor  YColor   ZColor：轴的颜色

Position：在figure中的位置，取值为0~1
OuterPosition：同上，留空白，取值0~1，Position和OuterPosition同时变化

CameraPosition：三维视角

Visible：是否可见
```

line对象
- 由plot生成
- 由polar生成极坐标（实际上是调用了axes和plot）


Text对象
1. 由text生成
2. 由title('string')生成，这时是标题
3. 由xlabel('string')生成，这时是轴标记
4. 由gtext('string')生成，这时是鼠标互动

颜色，底色，旋转。。。

Legend对象
- Box
- Color。。。多种颜色


Bar对象
- Horizontal：水平放置


### 6.3 计算几何

点与多边形的包含关系
```
[in,on]=inpolygon(X,Y,xv,yv)
```
X,Y:待判断点  
xv,yv:多边形顶点  
in判断是否在区域内，on判断是否在边界上  

矩形的集合运算
```
rectangle('position',A)%画图
area=rectint(A,B)%算交集面积
A:n*4,B:m*4,一行值为：[x,y,width,height]
area:n*m,
'curvature',[1,i]%i介于0-1，表示边角圆滑化
```


计算凸包
```
k=convhull(x,y)%返回编号
n维凸包convhulln(X)
```

Delaunay剖分
```
TRI=delaunay(x,y)
triplot(TRI,x,y)
figure
trisurf(TRI,x,y,zeros(size(x)))%三维曲面
figure
trimesh(TRI,x,y,zeros(size(x)))%三维网格
```

三维Delaunay剖分
```
T=delaunay3(x,y,z)
%n维
T=delaunayn(X)
```


最临近搜索
```
K=dsearch(x,y,TRI,xi,yi)
```


生成圆柱
```
% r是母线
[x,y,z]=cylinder(r,5)
mesh(x,y,z)
```

### 6.4 gui

常用控件：
- h=msgbox('message','title',icon) %icon可以是none/error/help/warn/custom
- h=inputdlg('message','title',N)%N是行数
h=inputdlg({'m1','m2'},'info',1,{'mm','nn'})%多输入框
- h=waitxbar(x,h,’message’)%进度条
- bu=questdlg('内容','题目','按键1','按键2','按键1')  %选择对话框
- 打开文件
```
[FileName,PathName] = uigetfile('*.m','Select the M-file');    %打开文件的对话框
filename = uigetfile
[FileName,PathName,FilterIndex] = uigetfile(FilterSpec)
[FileName,PathName,FilterIndex] = uigetfile(FilterSpec,DialogTitle)
[FileName,PathName,FilterIndex] = uigetfile(FilterSpec,DialogTitle,DefaultName)
[FileName,PathName,FilterIndex] = uigetfile(...,'MultiSelect',selectmode)%选择多个文件
```
- uigetdir %打开文件夹
- uigetpref
- uiimport%import数据
- uiload%调用mat
- uiputfile%保存文件
- uisave%保存mat
- c=uisetcolor([r g b])% 选色对话框，默认是[r g b]
- uisetfont
- helpdlg%类似msgbox，单多了个图标
- ButtonName = questdlg(Question, Title, 'No')%多按钮对话框
ButtonName = questdlg(Question, Title, Btn1, Btn2, DEFAULT);
```
ButtonName = questdlg('What is your favorite color?', ...
                       'Color Question', ...
                       'Red', 'Green', 'Blue', 'Green');
   switch ButtonName,
     case 'Red',
      disp('Your favorite color is Red');
     case 'Blue',
      disp('Your favorite color is Blue.')
      case 'Green',
       disp('Your favorite color is Green.');
   end
```
- imageview(S)
- movieview%放动画
- soundview%放声音


在gui中插入多个图  
```
axes(handles.axes1);  
cla;  
```

输出鼠标坐标  
```
currPt = get(gca, 'CurrentPoint');
xb = currPt(1,1);
yb = currPt(1,2);
```


uitable改颜色的一种方法：
```
<html><BODY bgcolor="green">CSLO</BODY></html>
```


回调函数
```
Menu Editor  
Context Editor  
```

my_gui(varargin)：每次触发控件后，此主函数会运行。  
varargin包含4个变量：  
- ['触发控件的回调函数名',hObject,eventdata,handles]  
- hObject是当前对象的句柄  
- eventdata是附加参数  
- handles，结构体，包含当前gui所有对象的句柄和用户定义的数据  

get(hObject,'value')  


一些callback：
- figure上的callback
```
CreateFcn  
DeleteFcn  
ButtonDownFcn:左，中，右键；但左键可能冲突时，左键无效  
WindowButtonDownFcn  
WindowButtonMotionFcn  
WindowButtonUpFcn  
WindowKeyPressFcn  
WindowKeyReleaseFcn  
WindowScrollWheelFcn  
KeyPressFcn  
KeyReleaseFcn  
SizeChangedFcn:改变figure大小时，调用这个  
CloseRequestFcn:关闭GUI时，调用这个  
% 例如，把CloseRequestFcn中的delete(hObject)删掉，GUI就无法关闭了  
```
- 控件上的callback  
```
callback  
CreateFcn  
DeleteFcn:控件关闭时触发  
ButtonDownFcn:右键点击  
KeyPressFcn:当前控件获得焦点，并且有按键按下时执行  
```
- table控件上多了2个  
```
CellEditCallback  
CellSelectionCallback  
```

gui之间如何传递数据？

GUI内部传递数据：
- 方法1，用global
- 方法2，用handle。 写入：`handles.F=6;guidata(hObject,handles);`. 读取： `F=handles.F`
- 方法3：用application. 写入：`data.a=100;  setappdata(hObject,'my_data',data)`. 读取：`data=getappdata(handles.pushbutton1,'my_data')`
  - setappdata：设定或创建结构体数据  
  - getappdata：访问数据  
  - isappdata：判断是否存在  
  - rmappdata：删除  



GUI之间传递数据：
- 方法1，用global
- 方法2，用application（同上）
- 方法3，用变量空间（不推荐）， `assignin('base','a',a)
; a=evalin('caller','a') %'caller'是主函数的workspace`



多界面:
```
h=gcf;  
wenjian;  
close(h);  
```

http://blog.sina.com.cn/s/blog_630c70530100ies5.html  
http://blog.csdn.net/iuway/article/details/7845516  
http://blog.sina.com.cn/s/blog_4d633dc70100o58b.html  
http://blog.sina.com.cn/s/blog_4b1260cb0100khzd.html  
http://www.cnblogs.com/nktblog/archive/2012/05/04/2482875.html  






## 7. 其它



### 7.1 MapReduce
```
ds = datastore('airlinesmall.csv','TreatAsMissing','NA');

ds.SelectedVariableNames = 'ArrDelay';%只选择ArrDelay列

read(ds)
readall(ds)
preview(ds)%预览

function maxArrivalDelayMapper (data, info, intermKVStore)
partMax = max(data.ArrDelay);
add(intermKVStore, 'PartialMaxArrivalDelay',partMax);

function maxArrivalDelayReducer(intermKey, intermValIter, outKVStore)
maxVal = -inf;
while hasnext(intermValIter)
   maxVal = max(getnext(intermValIter), maxVal);
end
add(outKVStore,'MaxArrivalDelay',maxVal);
```


### 7.2 期权

```
[Call,Put]=blsprice(s,k,r,t,sigma,0)
[CallTheta,putTheta]=blstheta
Vega=blsvega
[CallRho, putRho]=blsrho
Gamma=blsgamma


blsimpv(price,strike,rate,time,value,limit,yield,tolerance,class)%欧式隐含波动率
(标的物价格，执行价格，利率，年时间，期权费)
blkimpv%期货期权隐含波动率
期货套保的有效性=1-套保后的方差/不套保的方差

k=NAP(0.08,r);
```

### 7.3 时间序列
```
[h,p_value,tstat]=adftest(b)

h=0表示不平稳
概率值p_value>0.05表示不平稳
tstat是检验值
```

### 7.4 常用工具箱
最优：optimization  
统计：statistics  
偏微分方程：partial differential equation  

金融:financial  
金融衍生：financial derivation  
固定收益：fixed-income  

信号处理：signal processing  
小波分析：wavelet  
滤波  

控制系统：control system  
系统辨法：wavelet  
鲁棒控制：robust control  

符号数学：Symbolic  
神经网络Neural network  

数字图像处理  

simulink  

### 7.5 通用命令

调用顺序：  
①变量。调用优先级最高。MATLAB搜索工作空间是否存在同名变量，如有则停止搜索。②子函数。③私有函数。④类构造函数。⑤重载方法。⑥当前目录中的同名函数。⑦搜索路径中其他目录中的函数。调用优先级最低。如果函数不在搜索路径中，则不能被调用。如果查询同名函数中究竟哪个函数被调用了，用which函数查询。例如：
> which zoom


生成p文件pcode（）
```
format long g  %关闭科学计数法  
format rat%结果用分数表示  
```
执行字符串：
```
eval（’命令’）；[a1,a2,…]=eval(‘命令’)；   
evalc（‘命令’）；[T,a1,a2,…]=eval(‘命令’)   
evalin   
```

```
Exit/quit  
常数：pi，inf,nan,i  
```


### 7.6 数学运算
```
Round（）四舍五入，fix（）舍去小数，向0取整  
Floor（）舍去正小数，ceil（）加入正小数  

abs()
sign 符号函数  
gcd最大公因子  
lcm最小公倍数  
norm欧式距离  
prod求积（sum）  
cumsum累积和  
cumprod累积积  

rat(x)化为分数  
rats(x)化为多项式分数  
```

复数相关
```
angle(z)  
real(z)  
imag(z)  
conj(z)  

mod 求模  
rem 余数  
```




cat(1,A,B)%沿着第1维度拼接  
blkdiag(A,B,C)%创建对角阵块  



### 7.7 高级通用命令
`nargin` 和 `nargout` 表示输入和输出的参数数目  

`varargin` 和 `varargout` 把实际函数调用的各个参数封装成一个元胞数组  
```
(1)function [out1,out2]=my1(a,b,varargin)  
(2)function [out1,out2,varargout]=my2(a,b)  
```

### 7.8 函数句柄
可以让代码简洁
- functions(@myfun)，返回一个结构体，包含函数的信息  
- func2str
- str2func
- save/load
- isa(myfun,'function_handle') 判断
- feval(myfun,x)，执行。feval(myfun,x1,x2,...)  
  1. myfun可以是函数句柄  
  2. myfun可以是m文件，这时要用'myfun'形式  

### 7.9 其它命令
continue 进入下次循环  
break   退出循环  
return 退出整个程序  

TAB 命令自动补全  
ctrl+I 自动调整缩进  
%%分段运行  

assignin('base','a',a)  
a=evalin('caller','a')  
'caller'是主函数的workspace  

eps   一个极小数，用来防止分母为0,例如sin(eps)/eps，而不用sin(0)/0  

clc%擦除一页  
clear all%清除base  
clf%清除figure中的内容  
close all  

```
t=cuptime
statement
cputime-t
```
用来测试耗用cpu时间

`tic;toc`测试的是实际执行命令的时间

memory 返回一个结构体，记录内存使用情况


## 书推荐

1. 【强烈推荐】matlab与数学试验 国防工业出版社
全面介绍了matlab的各种应用，值得注意的是：数值积分试验，微分方程试验，随机模拟实验，加密方法试验，分形模拟试验，遗传算法试验
2. 傅里叶变换及其应用    布雷斯威尔  西安交通大学出版社      好书！包含拉普拉斯变换，扩散方程，成像技术等，值得看！！
3. 数理统计及其在数学建模中的实践（done）
4. matlab入门到精通：符号计算，电路模拟，simulink
5. 精通matlab，计算篇（插值，傅立叶分析，偏微分方程），计算实例
6. 数理统计与数据分析
7. matlab实用指南（上下）电子工业出版社   书比较薄，比较深
