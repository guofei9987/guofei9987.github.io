---
layout: post
title: 【Matlab3】符号计算、微积分、方程、插值、傅里叶分析、最优化
categories: Matlab
tags:
keywords:
description:
order: 11003
---

## 3. 分析

### 3.1 符号计算

符号计算
- 定义符号：
```
syms a b
```
- 赋值:
```
subs(a+b,{a,b},{3,4})
subs(f,old,new)
eg:subs(f,[a,b,c],[x1,2,3])
sub(f,k,[1:4])
```
- eval和double：把符号变成数字
- 运算
```
compose(f,g)  复合函数f（g（x））
finverse（f，v）反函数
```
- 导数和积分
```
diff(S,v,n)n阶导数
int(S,v)不定积分
int(S,v,a,b)定积分
```
- 极限
```
limit(S,x,s)
limit(S,a)
limit(S,x,a,'right')
limit(S,x,a,'left')
```
- 级数和
```
symsum(S)
symsum(S,v)
symsum(S,v,a,b)
symsum(S,a,b)
```
- 泰勒展开
```
taylor(S)
taylor(S,n)
taylor(S,n,x,a)
```

### 3.2 微积分


```matlab
limit（y,x,1,’right’）  极限

diff(f)%求导
diff(f,v)%求导，v是自变量
diff(f,n)%n阶导数
diff(f,'v',n)%

diff(X)%矩阵差分
diff(X,n)%矩阵n阶差分diff(diff(X))是二阶
diff(X,n,dim)

int(s)%不定积分
int(s,v)%不定积分，v是自变量
int(f,x,-1,1)         定积分

q=dblquad(fun,xmin,xmax,ymin,ymax)%二重积分
q=triplequad(fun,xmin,xmax,ymin,ymax)%三重积分

symsum（f,n,0,50）  求和公式


%梯度和方向导数
FX=gradient(F)


taylor（f，3，x，1）  %x-1的三阶泰勒展开
  taylor(log(x),x,'ExpansionPoint',1,'Order',4)
taylortool%图和工具：泰勒工具！！！

以下用匿名函数做
fzero（f,2）    %零点
fminbnd(f,0,2)    %极小值点
```

几种求积分的方法
1. trapz（y）梯形法
```matlab
dt=0.01
z=trapz(y) * dt % y是向量，dt是步长
Q = quad(FUN,A,B,TOL,TRACE)
```
2. quad辛普生法
```matlab
fun1
quad（'fun1',0,1）
```
3. quadl自适应lobatto法，适用于平滑、高精度情况
```matlab
qual1('fun1',0,1)
```
4. quadgk自适应GK方法，高精度、震荡情况.可计算广义积分
```matlab
dblquad(fun,xmin,xmax,ymin,ymax) % 二重积分
triplequad(fun,xmin,xmax,ymin,ymax,zmin,zmax) % 三重积分
```


### 3.3 多项式
```matlab
r=roots(p)%解方程
p=poly(r)%用解创建多项式
  poly（A）%返回特征多项式
polyval(p,x0)%多项式某点的值
conv(p1,p2)%多项式乘法
[q,r]=deconv(v,u)%多项式除法，q是商，u是余式
k=deconv(p)%多项式微分
k=deconv(a,b)%计算conv(a,b)的微分
[q,d]=polyder(a,b)%计算a/b的微分=q/d

residue
```






### 3.4 解方程
```matlab
% 方法1
x=fsolve(@fun,x0)     （最小二乘法）
其中fun可以是一个m文件、一个句柄

% 方法2：solve()（在符号函数中使用）
[x,y]=solve('x^2+(y-100)^2-89^2','x^2+y^2-10000');
x=double(x),y=double(y)

% 方法3：求根
fzero、roots
```
### 3.5 微分方程

1、通解
```matlab
dsolve('','')
% D2x代表二阶导数，Dx(0)代表初始解

[x,y,z]=dsolve('Dx=2*x-3*y+3*z','Dy=4*x-5*y+3*z','Dz=4*x-4*y+2*z','t')
x=simplify(x);y=simplify(y);z=simplify(z);

dsolve('x*Dy+2*y-exp(x)=0','y(1)=2*exp(1)','x')
```

2、数值解
```matlab
% 统一公式
[T,Y]=solver(@fun,tspan,y0)
[T,Y]=solver(@fun,tspan,y0,options)
options=odeset()
```

<table class="tableizer-table">
<thead><tr class="tableizer-firstrow"><th>名称</th><th>特点</th><th>说明</th></tr></thead><tbody>
 <tr><td>ode45</td><td>单步法，4、5阶龙格-库塔方法，精度中</td><td>首选，普遍</td></tr>
 <tr><td>ode23</td><td>单步，2、3阶龙格-库塔法，精度低</td><td>&nbsp;</td></tr>
 <tr><td>ode113</td><td>多步，Adams法，精度高</td><td>快</td></tr>
 <tr><td>ode23t</td><td>梯形</td><td>适度刚性情况</td></tr>
 <tr><td>ode15s</td><td>多步，Gear's反向数值积分，精度中</td><td>ode45失效时</td></tr>
 <tr><td>ode23s</td><td>单步，二阶Rosebrock算法，精度低</td><td>&nbsp;</td></tr>
 <tr><td>ode23tb</td><td>梯形，精度低</td><td>&nbsp;</td></tr>
 <tr><td>ode15i</td><td>可变秩，精度低</td><td>完全隐式微分方程</td></tr>
</tbody></table>



3、pdetool

### 3.6 复变函数
```matlab
real % 实部
imag % 虚部
conj % 共轭
abs % 模
angle % 辐角

[X,Y] = pol2cart(TH,R) % 极坐标转直角坐标
```

### 3.7 插值


1. 一维插值
```matlab
yi=interp1(X,Y,xi,method)
pp=interp1(X,Y,method,'pp')
method='nearest'/'linear'/'spline'/'cubic'
```
2. 傅里叶插值
```
（适用于周期函数）
yi=interpft(y,n)%把向量y扩展成n个
```
3. 二维插值
```
Zi=interp2(X,Y,Z,Xi,Yi,method,extrapval)
interp3
interpn
ndgrid%n维网格  与meshgrid类似
```
4. 三维插值：
```
插值1：
[X,Y]=meshgrid(,)   %x,y,z是非网格数据
Z=griddata(x,y,z,X,Y,’linear’)  %用残缺数据，插值成网格数据’linear’/’cubic’ /’nearest’
mesh(X,Y,Z)
插值2：
[X,Y]=meshgrid(,);
F=TriScatteredInterp(x,y,z); Z=F(X,Y);mesh(X,Y,Z)
```
5. 三次样条
```
csape 给定约束的三次样条
csapi 插值生成三次样条
csaps  平滑生成三次样条
cscvn  内插参数的三次样条
ppmak 分段多项式样条
spapi 插值生成B样条
spaps B样条平滑处理
spap2 最小二乘法B样条
spcrv 均匀划分的B样条
spmak B样条
rpmak 有理样条
rsmak 标准几何形状有理样条
stmak 整理成st形式
tpaps 模版平滑样条
rscvn 分段双圆弧hermite插值
```

### 3.8 傅里叶分析

```
fft一维傅里叶变换
fft2二维傅里叶变换
fftn  N维傅立叶变换

逆变换：
ifft
ifft2
iffn


abs幅值
angle相位角
unwrap增减2*pi使相位角差不超过pi

傅里叶变换（连续情况用符号计算）
F=fourier(f)
F=fourier(f,v)%F(v)
F=fourier(f,u,v)%F(v),f(u)
```

案例：
```
syms x k
f=cos(x)
f1=fourier(f)
f2=int(f.*exp(k.*t))
```


一套傅里叶代码：
```
%fft傅里叶样板
%%
%生成数据
clear
close all
t=0:0.01:200;
y=cos(50*2*pi*t)+0.5*cos(30*2*pi*t)+0.5*cos(70*2*pi*t);

%%
%傅里叶分析
nf=500;%采样点
fy=fft(y,nf);
mfy=abs(fy);


mfy=mfy/nf;ft=100*[1:nf]/nf;%100是采样频率  nf是傅里叶的采样点

%%
%画图：频域、相位角
subplot(2,2,1)
plot(t,y)
subplot(2,2,2)
plot(ft,mfy)%幅值
subplot(2,2,3)
afy=angle(fy);
uafy=unwrap(afy);%相位角
plot(ft,afy,'r*',ft,afy,'r')

subplot(2,2,4)
plot(ft,uafy,'go',ft,uafy,'g')

```

一套小波分析的代码：
```
%小波分析
%%
%生成信号，并展示
clear;clc;close all;
f1=5;f2=10;%频率1,2
fs=2*(f1+f2);
Ts=1/fs;%采样间隔
N=12%采样点数
n=1:N
y=sin(2*pi*f1*n*Ts)+sin(2*pi*f2*n*Ts);
figure(1)
subplot(2,1,1)
plot(y)
title('两个正弦信号')
subplot(2,1,2)
stem(abs(fft(y)))
title('两信号频谱')

%%
%定义滤波器
h=wfilters('db6','l');%低通
g=wfilters('db6','h');%高通
h=[h,zeros(1,N-length(h))];
g=[g,zeros(1,N-length(g))];%补零
figure(2)
subplot(2,1,1)
stem(abs(fft(h)))
title('低通滤波器')
subplot(2,1,2)
stem(abs(fft(g)))
title('高通滤波器')

%%
%Mallet分解算法
figure(3)
sig1=ifft(fft(y).*fft(h));%低通(低频分量)
sig2=ifft(fft(y).*fft(g));%高通(高频分量)
subplot(2,2,1)
plot(real(sig1));
title('分解信号1')
subplot(2,2,3)
plot(real(sig2))
title('分解信号2')
subplot(2,2,2)
stem(abs(fft(sig1)))
title('分解信号1频谱')
subplot(2,2,4)
stem(abs(fft(sig2)))
title('分解信号2频谱')
%%
%Mallet重构算法
sig1=dyaddown(sig1);%2抽取
sig2=dyaddown(sig2);%2抽取
sig1=dyadup(sig1);%2插值
sig2=dyadup(sig2);%2插值
sig1=sig1(1,[1:N]);%去掉最后一个0
sig2=sig2(1,[1:N]);%去掉最后一个0
hr=h(end:-1:1);%重构低通
gr=g(end:-1:1)%重构高通
hr=circshift(hr',1)';%位置调整圆周右移一格
gr=circshift(gr',1)';%位置调整圆周右移一格
sig1=ifft(fft(hr).*fft(sig1));%低频
sig2=ifft(fft(gr).*fft(sig2));%高频
sig=sig1+sig2;%源信号

figure(4)
subplot(2,2,1)
plot(real(sig1))
title('重构低频信号')
subplot(2,2,3)
plot(real(sig2))
title('重构高频信号')
subplot(2,2,2)
stem(abs(fft(sig1)));
title('重构低频信号频谱')
subplot(2,2,4)
stem(abs(fft(sig1)));
title('重构高频信号频谱')
figure(5)
plot(real(sig),'r')
hold on
plot(y)
legend('重构信号','原始信号')
title('重构信号与原始信号比较')
```

### 3.9 最优化

1. 一维优化问题fminbnd  
方法：黄金分割法（迅速缩小极值区间），抛物线法（提高解得精度）    
场景：一维，有边界   
min(F(x))  
s.t.x1<x<x2  
```
[x,fval,exitflag,output]=fminbnd('myfun',x1,x2,options)

1. FunValCheck:  
on 目标函数为复数或NaN时显示出错信息  
off 不显示出错信息

2. exitflag:
1 优化成功
0 迭代到最大(MaxFunEvals,MacIter)退出
-1用户自定义函数退出
-2边界调教不协调(x1>x2)
```
2. 无约束优化问题fminsearh  
方法：所用算法是单纯形搜索法，不需要计算梯度   
场景：无约束，多维，有梯度  
模型：min(F(x))  
代码：
```matlab
[x,fval,exitflag,output] = fminbnd('myfun',x0,options)
1. FunValCheck:
  on 目标函数为复数或NaN时显示出错信息
  off 不显示出错信息
2. OutputFcn 用户自定义的输出函数，它将在每个迭代步调用
3. PlotFcns   用户自定义的画图函数，它将在每个迭代步调用
4. exitflags  
  1  求解成功
  0  ...
  -1 ...
```
3. 无约束优化问题fminunc
```matlab
方法：所用算法是搜索法和梯度法结合
模型：min(F(x))
代码:
[x,fval,exitflag,output,grad,hessian]=fminunc('myfun',x0,options)
grad是x点的梯度：
[∂f/x1,∂f/x2,...,∂f/xn]
hessian矩阵：
[∂^2/x1^2,∂^2/x1x2,...,...]
```
4. 0-1规划
```matlab
bintprog???
模型：
min C'X
s.t. A*X<=b
      Aeq*X=beq
      xi=0或1
代码：[x,fval,exitflag,output]=bint('fun',A,b,Aeq,beq,x0,options)
```
5. 极小极大fminmax
```matlab
模型：
min(x)max(i){Fi(x)}
s.t.
{
A*X<=b
Aeq*x=beq
c(x)<=0
ceq(x)=0
lb<=x<=ub
}
[x,fval,maxfval,exitflag,output,lambda]=fminmax('fun',x0,A,b,Aeq,beq,lb,ub,nonlcon,options)
options指定选项：
Derivative:比较用户提供的梯度和有限差分法得出的梯度
Diagnostic:显示诊断信息
DiffMaxChange:有限差分法求梯度时自变量的最大改变量
DiffMinChange:有限差分法求梯度时自变量的最小该变量
GradConstr:约束函数的梯度
GradObj:目标函数的梯度
```
6. 约束优化问题fmincon
```matlab
[x,fval,exitflag,output,lambda,grad,hessian]=fmincon('fun',x0,A,b,Aeq,beq,lb,ub,nonlcon,options)
lambda: x处的拉格朗日乘子
grad: x处的梯度
hessian: x处的海森矩阵
```
7. 非线性最小二乘问题lsqnonlin
```
min(f(x)^2=f1(x)^2+f2(x)^2+...+fn(x)^2)
[x,resnorm,residual,exitflag,output,lambda,jacobian]=lsqnonlin('fun',x0,lb,ub,options)
```
8. 线性规划linprog
```
[x,fval,exitflag,output,lambda]=linprog('fun',A,b,Aeq,beq,lb,ub,x0,options)
```
9. 二次规划quadprog
```
模型：
$min (1/2*x'* H * x+c'x)$  
s.t.  
{  
Aeq*x=beq  
A*x>=b  
}  
代码：  
[x,fval,exitflag,output,lambda] = quadprog(H,f,A,b,Aeq,beq,lb,ub,x0,options)  
```
10. 目标到达问题
```
模型：  
[x,fval,attainfactor,exitflag,output,lambda] = fgoalattain(fun,x0,goal,weight,A,b,Aeq,beq,lb,ub,nonlcon,options)
```
11. optimset
```matlab
options=optimset('param1',value1,'param2','value2',...)
options=optimset%生成一个空optimset结构体
options = optimset(options,'Display', 'off');%输入旧的options
% optimset的内容:
1、Display  信息显示
off 不显示迭代信息
iter 显示每次的迭代信息
final 显示最终结果
notify 不收敛时才显示
2、MaxFunEvals 允许函数计算的最大次数，取正整数
3、MaxIter 允许最大迭代次数，取正整数
4、TolFun 函数值精度，取正整数
5、TolX 自变量精度，取正整数
% 输出的内容:
1、x  最优的x
2、fval 最优x对应的函数值
3、exitflag   用来评价最优化效果
1、一阶最优性条件满足容许范围
2、X的变化小于容许范围
3、目标函数的变化小于容许范围
4、重要搜索方向小于规定的容许范围并且约束违背小于options.TolCon
5、重要方向导数小于规定的容许范围并且约束违背小于options.TolCon
0、到达最大迭代次数或到达函数评价
-1、算法由输出函数终止
-2、无可行点
4、output 一个含多个参数的结构体
Iteraction  迭代次数
Algorithm  所用算法
FuncCount 函数评价次数
```
12. GUI界面:optimtool




## 书推荐

1. 【强烈推荐】matlab与数学试验 国防工业出版社
全面介绍了matlab的各种应用，值得注意的是：数值积分试验，微分方程试验，随机模拟实验，加密方法试验，分形模拟试验，遗传算法试验
2. 傅里叶变换及其应用    布雷斯威尔  西安交通大学出版社      好书！包含拉普拉斯变换，扩散方程，成像技术等，值得看！！
3. 数理统计及其在数学建模中的实践（done）
4. matlab入门到精通：符号计算，电路模拟，simulink
5. 精通matlab，计算篇（插值，傅立叶分析，偏微分方程），计算实例
6. 数理统计与数据分析
7. matlab实用指南（上下）电子工业出版社   书比较薄，比较深
