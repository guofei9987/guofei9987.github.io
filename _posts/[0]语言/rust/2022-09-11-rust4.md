---
layout: post
title: 【Rust4】trait
categories: 语言
tags:
keywords:
description:
order: 11204
---











## 面向对象

参考 https://rustwiki.org/zh-CN/book/ch10-02-traits.html

```Rust
use std::time::SystemTime;

pub trait MyTrait {
    // 1. 这个相当于抽象方法，继承的时候必须实现出来
    fn my_func1(&self) -> String;
    // 2. 下面这个是具体的方法，继承的时候无需再实现一遍
    fn my_func2(&self) -> String {
        format!("Running my func2 in Mytrait")
    }
}

// 第一个类，继承 MyTrait
pub struct MyClass1 {
    pub data1: String,
    pub data2: String,
}

impl MyTrait for MyClass1 {
    fn my_func1(&self) -> String {
        format!("Running my_func1 in Myclass1")
    }
}

// 第二个类，继承 MyTrait
pub struct MyClass2 {
    pub data3: String,
}

impl MyTrait for MyClass2 {
    fn my_func1(&self) -> String {
        format!("Running my_func1 in {}", self.data3)
    }
}

// 3. 如何用 MyTrait 作为类型。如何返回一个 MyTrait 类型
pub fn usage1(obj1: &impl MyTrait, obj2: &impl MyTrait) -> impl MyTrait {
    println!("input {},{} and  as MyTrait in usage", obj1.my_func1(), obj2.my_func1());
    return MyClass2 { data3: String::from("class3") };
}


// 4. 上面是个语法糖，下面这个是原始写法。这个写法严格限制每个 T 必须是同一个 Classs
pub fn usage2<T: MyTrait, U: MyTrait>(obj1: &T, obj2: &U) {
    println!("input {},{} and  as MyTrait", obj1.my_func1(), obj2.my_func1());
    // return MyClass2 {};
}

fn main() {
    let obj1 = MyClass1 {
        data1: String::from("my class1"),
        data2: String::from("data2"),
    };

    // 对应1，重写抽象方法
    println!("{}", obj1.my_func1());
    // 对应2，重写具体方法
    println!("{}", obj1.my_func2());


    // 对应3，MyTrait 类型作为函数的输入/输出
    let obj2 = MyClass2 { data3: String::from("my class2") };
    let obj3 = usage1(&obj1, &obj2);
    println!("obj3: {}", obj3.my_func1());

    // 对应4
    usage2(&obj1, &obj2);
}
```




？？？trait 作为参数，trait作为返回值


##  常见 trait

- 实现 `std::io::Write` 的值可以执行写字节操作；
- 实现 `std::iter::Iterator` 的值可以产生值的序列；
- 实现 `std::clone::Clone` 的值可以在内存中克隆自身；
- 实现 `std::fmt::Debug` 的值可以使用 `println!()` 的 `{:?}` 格式说明符打印出来。


例子
- `std::fs::File` 实现了 `Write` 特型，可以将字节写入本地文件。`std::net::TcpStream` 则是将字节写入网络连接。`Vec<u8>` 同样实现了 `Write`。在字节向量上每次调用 `.write()`，都可以在向量末尾追加一些数据。
- `Range<i32>` 实现了 `Iterator` 特型，与切片、散列表等相关的其他爹大气类型也实现了这个特型。
- 除了 `TcpStream` 这种不仅仅表示内存中数据的类型外，大多数标准库类型都实现了 `Clone` 特型。
- 大多数标准库都支持 `Debug` 特型。
- `Clone` 和 `Iterator` 方法，默认一直在作用域中。其它需要导入


## 泛型

```
fn run_query<M: Mapper + Serialize, R: Reducer + Serialize>(data: &DataSet, map: M, reduce: R) -> Results { ... }
```


## 可以给已有的类增加特型

```
trait MyTrait {
    fn is_a_to_t(&self) -> bool;
}

impl MyTrait for char {
    fn is_a_to_t(&self) -> bool {
        if *self >= 'a' && *self <= 't' {
            return true;
        }
        false
    }
}

fn main() {
    let a = 'c';
    println!("{}", a.is_a_to_t());
}
```

## 子 trait

```
// 使用 MyTrait2 的 类，还必须实现 MyTrait 里面的方法
pub trait MyTrait2: MyTrait {
    fn my_fun3(&self) -> String;
}
```

## 常用
### Iterator

实现 `for i in obj` 的功能

下面这个例子，可以让每个i是一个字符串格式的数字

```Rust
use std::fmt::format;
use std::iter::Iterator;

struct MyClass {
    data: Vec<i32>,
    idx: usize,
}

impl Iterator for MyClass {
    // 下面这两个是必须的
    type Item = String;// 类型声明

    fn next(&mut self) -> Option<Self::Item> {
        if self.idx < self.data.len() {
            self.idx += 1;
            return Some(format!("iter to {}\n", self.data[self.idx - 1]));
        }
        None
    }

//     以及其它一些方法
}


fn main() {
    let a = MyClass { data: vec![1, 2, 3, 4, 5], idx: 0 };
    for x in a {
        print!("{}", x); // x 是 String
    }
}
```


### 操作符重载

|        类别        |            特型              |                 操作符              |
|:------------------:|:--------------------------------:|:--------------------------:|
| 一元操作符         | `std::ops::Neg` <br> `std::ops::Not` | `-x` <br> `!x` |
| 算术操作符         | `std::ops::Add` <br> `std::ops::Sub` <br> `std::ops::Mul` <br> `std::ops::Div` <br> `std::ops::Rem` | `x + y` <br> `x - y` <br> `x * y` <br> `x / y` <br> `x % y`  |
| 位操作符           | `std::ops::BitAnd` <br> `std::ops::BitOr` <br>`std::ops::BitXor` <br> `std::ops::Shl`<br> `std::ops::Shr`  | `x & y` <br> `x - y` <br> `x * y` <br> `x / y` <br> `x % y` |
| 复合赋值算术操作符 | `std::ops::AddAssign` <br> `std::ops::SubAssign` <br> `std::ops::MulAssign` <br> `std::ops::DivAssign` <br> `std::ops::RemAssign` | `x += y` <br> `x -= y` <br> `x *= y` <br> `x /= y` <br> `x %= y`  |
| 复合赋值位操作符   | `std::ops::BitAndAssign` <br> `std::ops::BitOrAssign` <br> `std::ops::BitXorAssing` <br> `std::ops::ShlAssign` <br> `std::ops::ShrAssign` | `x &= y` <br> x  |
| 比较               | `std::cmp::PartialEq` <br>` std::cmp::PartialOrd` | `x == y`、`x != y` 分别对应 `eq(), ne()` <br> `x < y`、`x <= y`、`x > y`、`x >= y` |
| 索引               | `std::ops::Index` <br> ` std::ops::IndexMut`  | `x[y]`、`&x[y]` <br> `x[y] = z`、`&mut x[y]`  |



举例


```Rust
// 代码效果：自定义 -obj 是个什么逻辑
struct MyClass {
    data: Vec<i32>,
}

impl std::ops::Neg for MyClass {
    type Output = MyClass;

    fn neg(self) -> Self::Output {
        let mut data2 = self.data.clone();
        data2.reverse();
        MyClass { data: data2 }
    }
}


fn main() {
    let obj = MyClass { data: vec![1, 2, 3] };
    let obj2 = -obj;
    println!("{:?}", obj2.data);
    // [3, 2, 1]
}
```


参考：https://blog.csdn.net/feiyanaffection/article/details/125574733


### 常用 trait


<table><thead><tr><th>特型</th><th>简介</th></tr></thead><tbody><tr><td><code>Drop</code></td><td>解构函数。清除值时 Rust 自动运行的清除代码</td></tr><tr><td><code>Sized</code></td><td>标记特型，针对编译时可以知道大小的类型（而不是像切片那样动态大小的类型）</td></tr><tr><td><code>Clone</code></td><td>针对支持克隆值的类型</td></tr><tr><td><code>Copy</code></td><td>标记特型，针对可以简单地对内存中包含的值进行逐字节复制来克隆的类型</td></tr><tr><td><code>Deref</code> 与 <code>DerefMut</code></td><td>智能指针类型的特型</td></tr><tr><td><code>Default</code></td><td>针对有合理 “默认值” 的类型</td></tr><tr><td><code>AsRef</code> 与 <code>AsMut</code></td><td>转换特型，借用某种类型的引用</td></tr><tr><td><code>Borrow</code> 与 <code>BorrowMut</code></td><td>转换特型，类似 <code>AsRef</code> 与 <code>AsMut</code>，但额外保证一致的散列、顺序和相等</td></tr><tr><td><code>From</code> 与 <code>Into</code></td><td>转换特型，将某种类型的值转换为另一种类型</td></tr><tr><td><code>ToOwned</code></td><td>转换特型，将引用转换为所有值</td></tr></tbody></table>

说明
- `Drop` 和 `Copy` 只能有一个
- ??? https://blog.csdn.net/feiyanaffection/article/details/125574787/


## 迭代器相关

### 迭代器的开启

`drain` 方法：把迭代器分为两部分

```
use std::iter::FromIterator;

let mut outer = "Earth".to_string();
let inner = String::from_iter(outer.drain(1..4));

assert_eq!(outer, "Eh");
assert_eq!(inner, "art");
```

这里不写迭代器怎么构造出来，写一下应用
- map
- filter
- flat_map：匿名函数返回的是一个 vec，把这个 vec 摊平，成为最终结果


scan 类似 map，但不同的是：
- 有一个初始值
- 匿名函数额外接受这个可修改的值
- 返回 Option，从而可提前终止迭代

scan 的例子
```
let iter = (0..10).scan(0, |sum, item| {
    *sum += item;
    if *sum > 10 {
        None
    } else {
        Some(item * item)
    }
});

assert_eq!(iter.collection::<Vec<i32>>(), vec![0, 1, 4, 9, 16]);
```


- take：接受n个 `v.into_iter().take(3)`
- take_while：第一次false时，返回None，之后都返回 None `take_while(|item| *item < 3)`
- skip
- skip_while
- fuse：使得第一次出现 None后，之后都是强制为 None
- rev：反转
    - 这个代码相当于头尾双指针：`it=v.iter();it.next_back();it.next()`
- enumerate：`for (idx,item) in b.into_iter().enumerate(){...}`
- chain：把两个迭代器横向（按顺序）粘合到一起，形成一条链
- zip：把两个迭代器纵向粘合到一起，形成一组数据对
    - 结果长度取最少的那个
    - 举例：
```
let v: Vec<_> = (0..).zip("ABCD".chars()).collect();
assert_eq!(v, vec![0, 'A'], [1, 'B'], (2, 'C'), (3, 'D'));
```
- cycle：无休止的循环
    - 例子 `let v: Vec<_> = (0..5).cycle().take(100).collect();`




比较复杂的
- peekable：不消费下一项的情况下探测下一项，并把它放到 next 中
- inspect
- by_ref
- cloned


### 迭代器的消费

简单累计
- sum
- count
- product
- max/min：
    - 返回 Option 对象
    - `f32,f64` 只实现了 `std::cmp::PartialOrd`，没有实现 `std::cmp::Ord`，因此不能使用上述两个方法
    - 作用于 HashMap 类型时，最值的标准按照 key 来，而不是 value
- max_by/min_by：后接一个函数
```Rust
use std::cmp::{PartialOrd, Ordering};
// 这里的双引用，是因为 num.iter() 会产生引用，然后 max_by 又会产生一次引用
fn cmp(lhs: &&f64, rhs: &&f64) -> Ordering {
    lhs.partial_cmp(rhs).unwrap()
}
let numbers = [1.0, 4.0, 2.0];
assert_eq!(numbers.iter().max_by(cmp), Some(&4.0));
assert_eq!(numbers.iter().min_by(cmp), Some(&1.0));
```
- max_by 还可以用于 HashMap
```
let res = populations.into_iter().
    max_by(|item1,item2|(&item1.1).cmp(&item2.1));
```
- 各种比较：从迭代器取值比较，知道可以做出决定
    - `eq`,`ne`
    - `lt,le,gt,ge`
    - `cmp,partial_cmp`
```
let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 2];
println!("{}", v1.into_iter().eq(v2.into_iter()))
```
- max_by_key/min_by_key：用于 HashMap
- any/all：后接匿名函数 `"Iterator".chars().any(char::is_uppercase);`
- fold：自定义累计操作
```
let a = [5, 6, 7, 8, 9, 10];
assert_eq!(a.iter().fold(0, |n, _| n + 1),  6);       // 实现count
assert_eq!(a.iter().fold(0, |n, i| n + i),  45);      // 实现sum
assert_eq!(a.iter().fold(1, |n, i| n * i),  151200);  // 实现product
assert_eq!(a.iter().fold(i32::min_value(), |m, &i| std::cmp::max(m, i)), 10);//实现max
```

取数类

- nth(n)：返回n对应的项
    - 如果n超了，返回None
    - 不会取得迭代器的所有权，因此可以多次调用
- last()：最后一个
- find(func)：第一个true


### collect

- collect
- FromIterator
- `std::iter::Extend`：一个集合拼接另一个集合
- partition：把迭代器分成两个集合（注意，不是分成两个迭代器，因为那样有权限问题）
```
let v: Vec<i32> = (0..10).into_iter().collect();
let (even, odd): (Vec<i32>, Vec<i32>) = v.into_iter().partition(|item| item % 2 == 0);
```


### 应用

可以自定义迭代器，例如自定义一个二叉树伤的迭代器

https://blog.csdn.net/feiyanaffection/article/details/125574968
