---
layout: post
title: 【Rust3】实战笔记
categories: 语言
tags:
keywords:
description:
order: 11203
---

## collector相关的一些用法

vec 的遍历可以用 enumerate

```rust
for (idx, val) in vec1.iter().enumerate() {
idx as i32;
}
```


filter 和 map

```
let num = vec![1, 2, 3, 4, 5];
let evens = num.into_iter().filter(|x| *x * 2 == 0);
let evens_square = evens.clone().map(|x| x * x);

let res1 = evens.collect::<Vec<_>>();
let res2 = evens_square.collect::<Vec<_>>();
println!("{:?},{:?}", res1, res2);
```




## 实战

这个抄的，`& *` 没搞懂

```Rust
use std::collections::HashMap;
impl Solution {
    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
        let mut map: HashMap<i32, i32> = HashMap::new();
        for (idx, n) in nums.iter().enumerate() {
            match map.get(&(target - *n)) {
                Some(&v) => return vec![v, idx as i32],
                None => map.insert(*n, idx as i32),
            };
        }
        vec![]
    }
}
```

下面这个自己写的（似乎很多地方不需要借用）

```Rust
use std::collections::HashMap;
pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
    let mut hash_map: HashMap<i32, i32> = HashMap::new();

    for (idx, val) in nums.iter().enumerate() {
        if hash_map.contains_key(val) {
            return vec![hash_map[val], idx as i32];
        }
        hash_map.insert(target - val, idx as i32);
    }
    return Vec::new();
}
```


## Rust的特点

对版本放心，借助 cargo，可以同时调用不同版本的包。

编译
- 一次编译，跨平台到处运行。得益于 LLVM
- 增量编译。只增量编译修改过的部分

核心库
- 最核心的部分，与标准库有重复。
    - 基础的 trait：Copy、Debug、Display、Option
    - 基本类型，bool、char、i8～i32/u8～u32/f8～f32、str、array、slice、tuple、pointer
    - 常见数据结构 String、Vec、HashMap、Rc、Arc、Boc
    - 常见宏定义 `print!, assert!, panic!, vec!`
- `#![no_std]`


标准库

包 crate
- 第三方包在 `crates.io` 上
- 文档自动发布到 `docs.rs` 上


内存表达式相关
- 本地变量
- 静态变量
- `*expr`
- `vec[idx]`
- 字段引用 `obj.field`
- 上面的组合




## 1

https://leetcode.cn/problems/remove-duplicates-from-sorted-array/


这个 beat 100%

```
impl Solution {
    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {
        let mut p1 = 0;
        let mut p2 = 1;
        while p2 < nums.len() {
            if nums[p2] == nums[p1] {} else {
                p1 += 1;
                nums[p1] = nums[p2];
            }
            p2 += 1;
        }
        p1 += 1;
        return p1 as i32;
    }
}
```

这个就只能beat 20%，把`!(nums[p2] == nums[p1])` 换成 `nums[p2] != nums[p1]`，也是同样结果

```
impl Solution {
    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {
        let mut p1 = 0;
        let mut p2 = 1;
        while p2 < nums.len() {
            if !(nums[p2] == nums[p1]) {
                p1 += 1;
                nums[p1] = nums[p2];
            }
            p2 += 1;
        }
        p1 += 1;
        return p1 as i32;
    }
}
```

猜测：
1. not运算比 else 分支要消耗很多资源
2. `!=` 这个符号实际上也是not运算
