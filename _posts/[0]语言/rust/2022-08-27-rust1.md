---
layout: post
title: 【Rust】初学 笔记
categories: 语言
tags:
keywords:
description:
order: 19001
---







```bash
# 编译
rustc main.rs

# 运行
./main
```


cargo:系统和包管理器

```bash
cargo --version

# 创建一个新的cargo项目
cargo new learn_rust_project

# 编译
cargo build

# 编译并运行代码
cargo run
```



## 基本语法

```rust
// 加上 mut 是可变的(mutable)，不加是不可变的
let mut guess = String::new();


io::stdin()
    .read_line(&mut guess)
    .expect("Failed to read line");

//
println!("You guessed: {}", guess);
```

导入别的项目
```text
rand = "0.8.3"
// Crates.io 是 Rust 生态

```



猜数字的代码
```rust
use std::cmp::Ordering;
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the num!");

    let secret_num = rand::thread_rng().gen_range(1..101);

    println!("secret num is {}", secret_num);


    loop {
        println!("Please input you guess:");

        //？？？为啥要在loop中定义
        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");


        // let guess: u32 = guess.trim().parse().expect("Please type a number!");
        // 用 match，而不是 expect，匹配抛出的错误，并做相应的处理
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("pleas input a num!");
                continue;
            }
        };


        println!("You guessed: {}", guess);


        match guess.cmp(&secret_num) {
            Ordering::Less => println!("Too small"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```


## 变量


变量类型
- 可变变量 `let mut x = 1`
- 不可变变量 `let x = 1`
- 常量 `const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`
    - 运行的整个过程中有效

### 遮蔽

遮蔽
```rust
fn main() {
    let x = 5;
// x = 5
    let x = x + 1;
    // x = 6

    {
        let x = x * 2;
        // x = 12
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
    // 内部遮蔽结束，这里 x = 6
}
```

遮蔽2
```rust
// 不同类型可以遮蔽 1）必须不能加 mut，2）必须是不同类型
let x = "abcd";
let x = x.len();
```


### 数据类型
- rust是静态类型，必须编译时知道所有变量的类型

整型


|  长度  | 有符号类型 | 无符号类型 |
|:------:|:----------:|:----------:|
| 8 位   | i8         | u8         |
| 16 位  | i16        | u16        |
| 32 位  | i32        | u32        |
| 64 位  | i64        | u64        |
| 128 位 | i128       | u128       |
| arch   | isize      | usize      |


- 浮点型 `f32`, `f64`
- bool类型 `bool`
- 元组
    - 赋值： `let tup: (i32, f64, u8) = (500, 6.4, 1);`
    - 取值1：`let (x, y, z) = tup;`
    - 取值2： `let y = tup.1;`
- 数组
    - 赋值 `let a: [i32; 5] = [1, 2, 3, 4, 5];`
    - 赋值2: `let a = [3; 5];` 这是3重复5次
    - 取值：`a[0]`


### 结构体

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    // 不允许单独一个字段可变，只能整体全都可变
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    // 这样改字段值
    user1.email = String::from("anotheremail@example.com");
}
```

简写1
```rust
let email = String::from("123@qq.com");
let username = Strin::from("name");

let mut user2 = User {
  // 简写：email:email,
    email,
    username,
    active: true,
    sign_in_count: 2,
};
```

简写2:复制别的值进来
```rust
let user3 = User {
    email: String::from("321@"),
    ..user1
};
// user1就不能用了，因为它的 username 已经移动过来了
// 不过 active 和 sign_in_count
```

元组结构体:没有字段名的结构体

```rust
struct Color(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
}
```

没有字段的结构体
```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

### 结构体的方法

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // &self 是 self: &Self 的缩写
    // 这里的 &self 指的是 rectangle: &Rectangle
    // 加 & 是因为不想获取所有权，只希望读，而不希望写
    fn area(&self) -> u32 {
        self.width * self.height;
    }
}
```

方法和字段可以同名
```
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn width(&self)->bool{
        self.width>0
    }
}
```

impl 也可以不接一个方法
```
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
```


### 枚举 enum

```
#![allow(unused)]

fn main() {
    enum IpAddrKind {
        // 可以是不同类型
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let four = IpAddrKind::V4;

    // IpAddrKind 可以像一个类型一样使用
    let six: IpAddrKind = IpAddrKind::V6(String::from("::1"));
}
```

match

```
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

match 中的 othor

```
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
}
```

如果 other 没用，可以用下划线代替

```
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
}
```

到 other 后什么也不做
```
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
}
```


## collections-vector

```
fn main() {
    // 如何创建1
    let mut v1: Vec<i32> = Vec::new();
    // 如何创建2
    let v2 = vec![1, 2, 3];

    // push
    v1.push(5);
    v1.push(6);

    // 删?

    // 改
    v1[1] = 9;
    println!("{:?}", v1);

    // 查
    let a = v1.get(0);
    // Some 类型
    // index 超出的话，为 None 类型
    let a2 = v1.get(100);

    let b = v1[0];
    let c = &v1[0];
    println!("{:?},{:?},{},{}", a, a2, b, c);


    v1.push(30);
    // println!("{:?}", a); // 上面 push 时被借用了，所以这里会报错


    println!("{:?}", v1);

    // 循环遍历
    for i in v2 {
        println!("{}", i);
    }

    // 如何在循环遍历中改它们
    for i in &mut v1 {
        *i += 50;
    }
    println!("{:?}", v1);
}
```


## collections-string

```
fn main() {
    // 如何创建1
    let mut s1: String = String::new();

    // 如何创建2
    let s2_1: &str = "hello, world!";
    let s2: String = s2_1.to_string();

    // 如何创建3
    let s3: String = String::from("hello");

    // t添加
    s1.push('a');
    let s_append = "abb";
    s1.push_str(s_append);

    println!("{}", s1);

    // 用 format连接
    let s_total: String = format!("{}-{}-{}", s1, s2, s3);
    println!("{}", s_total);
}
```


索引
- String实际上是 `Vec<u8>`，所以 `len()` 对应的是 Vec 的长度
- 不要用 `&s[0..9]` 或者 `s[0]`，遇到中文等会 panic


遍历字符串

```rust
fn main() {
    let s = String::from("你好rust语言");

    // 遍历字符
    for i in s.chars() {
        println!("{}", i);
    }

    // 这个是遍历 ascii 值，都在 0～255 之间
    for i in s.bytes() {
        println!("{}", i);
    }
}
```

## collections-hash map



```
use std::collections::HashMap;

fn main() {
    // 新建
    let mut hash_map = HashMap::new();

    // 新建2（实战中往往要这么用）
    let keys = vec![String::from("blue"), String::from("red")];
    let values = vec![10, 30];
    let hash_map2: HashMap<_, _> = keys.iter().zip(values.iter()).collect();
    println!("{:?}", hash_map2);


    // 增&改
    hash_map.insert(String::from("Blue"), 10);
    hash_map.insert(String::from("Red"), 20);
    // 注：insert 之后，HashMap 将获得所有权
    // 查重复 insert 同一个 key 将覆盖


    // 查1
    let val_opt: Option<&i32> = hash_map.get("Blue");
    // 返回一个 Option
    let _b = match val_opt {
        Some(x) => println!("x={}", x),
        None => println!("None")
    };

    // 查2
    for (key, val) in &hash_map {
        println!("k:v = {}:{}", key, val);
    }

    // 改2：循环中改

    for (key, val) in &mut hash_map {
        println!("k:v = {}:{}", key, val);
        *val += 100;
    }


    // 删
    hash_map.remove("red1");


    println!("{:?}", hash_map);
}
```






## 控制流程

```rust

let y = {
    let x = 3;
    x + 1
};
// y=4，因为代码块最后一句是它的返回值

// 函数的最后一句也是返回值，但最后一句不要加分号
fn my_func(x: i32) -> i32 {
    x + 1
}
```

if 语句
```rust
// 1. 不会自动转换为 bool 值，必须手动转换
if x < 0 {
    println!("x<0")
} else if x < 1 {
    println!("0<=x<1")
} else { println!("x>=1") }
```

if 用于赋值

```rust
let age = 20;
// 每个分支必须都是相同类型
let sex = if age > 18 { "adult" } else { "child" };
```



loop：不停的执行

1. 可以与break，continue连用
```rust
let mut x = 1;
loop {
    x = x + 1;
    if x > 20 {
        break;
    } else if x % 3 == 0 { continue; }
    println!("{}", x);
}
```
2. break 可以像 return 一样使用，然后赋值
```rust
let mut cnt = 1;
let res = loop {
    cnt += 1;
    if cnt > 10 {
        break "end";
    }
};
```

while 条件循环

```
while cnt < 10 {
    cnt += 1;
}
```

for 循环
```
let lst = [10, 20, 30, 40, 50];

for element in lst {
    println!("the value is: {}", element);
}


for num in (1..4).rev() {
    println!("{}", num);
}
```

## 所有权

所有权让 Rust 无需 GC

内存管理的方式
- 垃圾回收机制，不断寻找不再使用的内存
- 开发者写明内存分配和释放
- Rust：所有权机制

所有权规则
- 每一个值都有一个 owner （变量）
- 值在任一时刻有且只有一个所有者。
- 当owner（变量）离开作用域，这个值将被丢弃。


## 智能指针

简单的是用 Box 实现的，Box 允许你把值放到堆上，而不是栈上。

```
fn main() {
    let b = Box::new(5);
    println!("b = {}", b)
}
```





## 特性参考代码

下面用 `&` 防止被借用，这样main函数可以继续使用 rect

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect)
    );
}

fn area(rect: &Rectangle) -> u32 {
    rect.width * rect.height
}
```

打印结构体
```
// 1. 需要加上下面这行
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect = Rectangle {
        width: 30,
        height: 50,
    };
    println!("Rect is {:?}", rect);
    // 下面这个格式更好看
    println!("Rect is {:#?}", rect);
}
```
结果：

```
Rect is Rectangle { width: 30, height: 50 }
Rect is Rectangle {
    width: 30,
    height: 50,
}
```






## 参考

https://rustwiki.org/zh-CN/book/ch03-05-control-flow.html
