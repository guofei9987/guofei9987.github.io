---
layout: post
title: 【Rust1】基本语法
categories: 语言
tags:
keywords:
description:
order: 11201
---







```bash
# 编译
rustc main.rs

# 运行
./main
```


cargo:系统和包管理器

```bash
cargo --version

# 创建一个新的cargo项目
cargo new learn_rust_project

# 编译
cargo build

# 编译并运行代码
cargo run

# 编译并发布，
# 1）生成到 target/release 下，而不是 target/debug下
# 2）会做更深的优化
cargo build --release


# cargo 会优先搜索 cargo.lock 中的版本，以实现每次都用同一个版本的包。如果强制刷新 cargo.lock ：
cargo update


# 下载所用的包的相关帮助，并打开
cargo doc --open
```



## 基本语法

```rust
// 加上 mut 是可变的(mutable)，不加是不可变的
let mut guess = String::new();


io::stdin()
    .read_line(&mut guess)
    .expect("Failed to read line");

//
println!("You guessed: {}", guess);
```

导入别的项目
```text
rand = "0.8.3"
// Crates.io 是 Rust 生态

```



猜数字
```rust
use std::cmp::Ordering;
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the num!");

    let secret_num = rand::thread_rng().gen_range(1..101);

    println!("secret num is {}", secret_num);


    loop {
        println!("Please input you guess:");

        //？？？为啥要在loop中定义
        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");


        // let guess: u32 = guess.trim().parse().expect("Please type a number!");
        // 用 match，而不是 expect，匹配抛出的错误，并做相应的处理
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("pleas input a num!");
                continue;
            }
        };


        println!("You guessed: {}", guess);


        match guess.cmp(&secret_num) {
            Ordering::Less => println!("Too small"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```


## 变量


变量类型
- 可变变量 `let mut x = 1`
- 不可变变量 `let x = 1`
- 常量 `const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`
    - 运行的整个过程中有效

### 遮蔽

遮蔽
```rust
fn main() {
    let x = 5;
// x = 5
    let x = x + 1;
    // x = 6

    {
        let x = x * 2;
        // x = 12
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
    // 内部遮蔽结束，这里 x = 6
}
```

遮蔽2
```rust
// 可以重新绑定
let mut x = "abcd";
let x="aaa";
let mut x = x.len();
```


### 数据类型
- rust是静态类型，必须编译时知道所有变量的类型

整型


|  长度  | 有符号类型 | 无符号类型 |
|:------:|:----------:|:----------:|
| 8 位   | i8         | u8         |
| 16 位  | i16        | u16        |
| 32 位  | i32        | u32        |
| 64 位  | i64        | u64        |
| 128 位 | i128       | u128       |
| 根据系统，32/64位   | isize      | usize      |


- 浮点型 `f32`, `f64`
- bool类型 `bool`
- 元组
    - 赋值： `let tup: (i32, f64, u8) = (500, 6.4, 1);`
    - 可以是不同类型
    - 取值1：`let (x, y, z) = tup;`
    - 取值2： `let y = tup.1;`
- 数组
    - 赋值 `let a: [i32; 5] = [1, 2, 3, 4, 5];`
    - 赋值2: `let a = [3; 5];` 这是3重复5次
    - 赋值后长度固定，不可再改
    - 内存整块分配到栈上，而不是堆上
    - 取值：`a[0]`


其它
```Rust
// 允许任意添加下划线，以提高可读性
let num: i32 = 100_00_000_000;

let num: i32 = 0xff; // 16进制
let num: i32 = 0o77; // 八进制
let num: i32 = 0b111_000;// 二进制
```

数据类型的选择
- i32 大多数情况下最快
- f64 与 f32 运行速度差不多，因此默认类型推导是 f64


format
```Rust
let x = 42; // 42 is '2A' in hex

// 转十六进制
assert_eq!(format!("{x:X}"), "2A");
assert_eq!(format!("{x:#X}"), "0x2A");
assert_eq!(format!("{:X}", -16), "FFFFFFF0");

// 转科学计数法
assert_eq!(format!("{x:E}"), "4.2E1");

x.to_string() // 转文本


// +代表显示符号，#代表显示进制头，0代表补0，12代表最小长度，b代表二进制
let a = format!("{num:+#012b}", num = 0b110);
println!("{}", a);

// n进制度：b二进制，xX十六进制，o八进制
let a = format!("{:o}", 0b111000);
println!("{}", a);


// 1位小数
let a = format!("{a:8.1}", a = 1.23);
println!("{}", a);

// https://blog.csdn.net/feiyanaffection/article/details/125575203
```


as 转化
```Rust
// bool 类型可以转 int
assert_eq!(true as i32, 1); // true转换为1

// char 类型其实是一个 i32
assert_eq!('*' as i32, 42);
// ascii 值转 char
assert_eq!(std::char::from_u32(65).unwrap(), 'a');

// 数值类型可以任意相互转化
```






### 基本运算
```Rust
+-*/ // 加减乘除
a%b //取余
```

数字对应的方法

```Rust
// 按位前后颠倒
let a = 0b01110000_i8.reverse_bits(); // 返回 0b00001110
// swap_bytes：按字节颠倒
// 二进制表示的1的个数
let a: u32 = 0b1110_i8.count_ones();
// 二进制表示的0个个数
let a: u32 = 0b1110_i8.count_zeros();

a&b // 按位与
a|b // 按位或
a^b // 按位异或
!a // 按位否
>> // 按位右移
<<
```

逻辑
```Rust
// 比较
==, !=, <, >, <=, >=
// 逻辑运算
&&
||
! // 逻辑非
```




```Rust
// 常量
use std::f64::consts::{PI, E, LOG10_E};


let a: f64 = 9.0;

a.abs()

a.exp(); // e^a
a.exp2(); // 2^a
a.log(3.0); // 以3.0为底的对数
a.log2(); // 以2为底
a.log10(); // 以10为底
a.ln()
x.ln_1p() // ln(1+x)

a.powf(3.0); //a^3.0
a.powi(3); //a^3



a.floor(); // 向下取整
a.ceil(); // 向上取整
a.round(); //四舍五入

a.fract(); // 小数部分
a.trunc(); // 整数部分

a.clamp(3.0, 5.0); // 裁剪到3.0～5.0之间


// 大端表示小端表示
// a.to_le,a.to_be,to_be_bytes,to_ne_bytes
```

更多阅读：https://doc.rust-lang.org/std/primitive.i32.html



```Rust
// 含头不含尾
0..6
(0..6).rev()
```



## 结构体 struct

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    // 不允许单独一个字段可变，只能整体全都可变
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    // 这样改字段值
    user1.email = String::from("anotheremail@example.com");
}
```

简写1
```rust
let email = String::from("123@qq.com");
let username = Strin::from("name");

let mut user2 = User {
  // 简写：email:email,
    email,
    username,
    active: true,
    sign_in_count: 2,
};
```

简写2:复制别的值进来
```rust
let user3 = User {
    email: String::from("321@"),
    ..user1
};
// user1就不能用了，因为它的 username 已经移动过来了
// 不过 active 和 sign_in_count
```

元组结构体:没有字段名的结构体

```rust
struct Color(i32, i32, i32);
let black = Color(0, 0, 0);

// 可以声明字段共有
// struct Color(pub i32,pub i32,pub i32);

```

没有字段的结构体
```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

知识
- 外部使用时，字段是私有的。外部可以使用结构体的任何共有方法，但不能直接访问字段


### 结构体的方法

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // &self 是 self: &Self 的缩写
    // 这里的 &self 指的是 rectangle: &Rectangle
    // 加 & 是因为不想获取所有权，只希望读，而不希望写
    fn area(&self) -> u32 {
        self.width * self.height;
    }
}
```

方法和字段可以同名
```
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn width(&self)->bool{
        self.width>0
    }
}
```

impl 也可以不接一个方法
```Rust
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

// 通常用来做一个构造器
impl Rectangle{
  pub fn new() -> Rectangle{
    Rectangle{
      width: 1,
      height: 1
    }
  }
}
// 用 Rectangle::new() 可以调用它
```



### 泛型


泛型用于 struct

```Rust
// 1. 派生 trait 。这要求所有的字段都支持这些 trait 才行
#[derive(Copy, Clone, Debug, PartialEq)]
struct Point<T> {
    x: T,
    y: T,
}

// 2. 泛型用于方法
impl<T> Point<T> {
    fn get_x(&self) -> &T {
        &self.x
    }
}

// 都合法
let p1 = Point { x: 5, y: 6 };
let p1 = Point { x: "mid", y: "mid" };
```



使用泛型时，如何做类型推断

```Rust
pub struct MyQueue<T> {
    data: Vec<T>,
}

impl<T> MyQueue<T> {
    pub fn new() -> MyQueue<T> {
        MyQueue {
            data: Vec::new()
        }
    }

    pub fn push(&mut self, t: T) {
        self.data.push(t)
    }

    pub fn pop(&mut self) -> Option<T> {
        self.data.pop()
    }
}

fn main() {
    // 可以自动推断类型（最常用）
    let mut q1 = MyQueue::new();
    q1.push(1.0);

    // 也可以这样指定类型
    let mut q2 = MyQueue::<i32>::new();

    //也可以这样
    let mut q3: MyQueue<i64> = MyQueue::new();
}
```

可以把构造函数改成这个（Self值得是这个类的别名）
```
pub fn new() -> Self {
    MyQueue {
        data: Vec::new()
    }
}
```



生命周期：https://blog.csdn.net/feiyanaffection/article/details/125574590?spm=1001.2014.3001.5502







## 枚举 enum

```
enum IpAddrKind {
    // 可以是不同类型
    V4(u8, u8, u8, u8),
    V6(String),
}

let four = IpAddrKind::V4;

// IpAddrKind 可以像一个类型一样使用
let six: IpAddrKind = IpAddrKind::V6(String::from("::1"));
```

match

```
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

match 中的 other

```
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
}
```

如果 other 没用，可以用下划线代替

```
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
}
```

到 other 后什么也不做
```
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
}
```


知识点
- pub 枚举的所有构造式和字段都会是 pub 的
- match 可以是 元组、结构体。
- 可以多匹配 ` 9 | 10  => { println!("big") }`


https://blog.csdn.net/feiyanaffection/article/details/125574617?spm=1001.2014.3001.5502


### 泛型枚举

常见的泛型枚举：

```Rust
enum Option<T> {
  None,
  Some(T)
}

enum Result<T, E> {
  Ok(T),
  Err(E)
}
```


基于泛型的数据结构举例：实现一个二叉树

```
// 创建T类型值的有序集合
enum BinaryTree<T> {         // BinaryTree的值只占1个机器字
  Empty,                     // 不包含任何数据
  NonEmpty(Box<TreeNode<T>>) // 包含一个Box，它是指向位于堆内存的TreeNode的指针
}

// BinaryTree的节点
struct TreeNode<T> {
  element: T,           // 实际的元素
  left: BinaryTree<T>,  // 左子树
  right: BinaryTree<T>  // 右子树
}
```

创建这个树的任何特定节点：

```
use self::BinaryTree::*
let jupiter_tree = NonEmpty(Box::new(TreeNode {
  element: "Jupiter",
  left: Empty,
  right: Empty
}));
```

大一点的树可以基于小一点的树创建

```
// 将jupiter_node和mercury_node的所有权，通过赋值转移给新的父节点mars_tree
let mars_tree = NonEmpty(Box::new(TreeNode {
  element: "Mars",
  left: jupiter_tree,
  right: mercury_tree
}));
```

根节点也使用相同的方式创建：

```
let tree = NonEmpty(Box::new(TreeNode {
  element: "Saturn",
  left: mars_tree,
  right: uranus_tree
}));
```

假如这个树有一个 add 方法，那么可以通过这样调用这个树：

```
let mut tree = BinaryTree::Empty;
for planet in planets {
  tree.add(planet);
}
```


附加：实现一个add功能的二叉树
```
enum BinaryTree<T> {
  Empty,
  NonEmpty(Box<TreeNode<T>>)
}

struct TreeNode<T> {
  element: T,
  left: BinaryTree<T>,
  right: BinaryTree<T>
}

impl<T: Ord> BinaryTree<T> {
  fn add(&mut self, value: T) {
    match *self {
      BinaryTree::Empty =>
          *self = BinaryTree::NonEmpty(Box::new(TreeNode {
            element: value,
            left: BinaryTree::Empty,
            right: BinaryTree::Empty
          })),
      BinaryTree::NonEmpty(ref mut node) =>
          if value <= node.element {
            node.left.add(value);
          } else {
            node.right.add(value);
          }
    }
  }
}
```





## collections

- `Vec<T>`
- `VecDeque<T>`：双端队列。
    - 实现：环形队列，并且可重新分配 capacity
    - 在队头和队尾的插入/删除都是 O(1)
    - 其它操作变慢
- `LinkedList<T>`：双向链表
- `BinaryHeap` 最大堆，（相当于Python的 heapq）
    - 适合查找和移除最大值
- `HashMap`
- `BTreeMap` 有序 kv表
    - 按照 k 顺序存储
    - 大多操作比 HashMap 慢
- `HashSet`
- `BTreeSet` 有序的 set


## Vec

```Rust
// 如何创建1
let mut v1: Vec<i32> = Vec::new(); // 不推荐
let mut v1: Vec<i32> = Vec::with_capacity(128); //推荐


// 如何创建2
let v2 = vec![1, 2, 3];

// 增
v1.push(5); // 会取走所有权
vec1.insert(0, 9); // 在0 位置插入9
vec1.extend(&vec2); // 把另一个塞进去
vec1.append(&mut vec2); // 把vec2塞进去，vec2清空

// 删
v1.pop(); // 删除并返回最后一个，如果 v1 是空的，返回 None。取得所有权
vec1.remove(2); // 删除2位置

// 改
v1[1] = 9;
println!("{:?}", v1);

// 查
let a = v1.get(0); // 返回引用 Some(&val)
// Some 类型
// index 超出的话，为 None 类型
let a2 = v1.get(100);

let b = v1[0]; // 实现 Copy
let c = &v1[0];
println!("{:?},{:?},{},{}", a, a2, b, c);


v1.push(30);
// println!("{:?}", a); // 上面 push 时被借用了，所以这里会报错


println!("{:?}", v1);

// 循环遍历
for i in v2 {
    println!("{}", i);
}

// 如何在循环遍历中改它们
for i in &mut v1 {
    *i += 50;
}
println!("{:?}", v1);
```

内存相关
```Rust
// 创建容量为n的vec
Vec::with_capacity(n);
// 返回容量，usize
v.capacity()
// 确保空闲空间容纳额外n个元素，也就是保证多于 vec.len() + n，有时候会多分配一些
v.reserve(n)
// 确保空闲空间为精确的 n，vec.capacity() = vec.len() + n，不会自作聪明多分配
v.reserve_exact(n);
// 丢掉所有空闲空间
v.shrink_to_fit();
```


裁剪类
```Rust
//用 val 填充，直到长度为 new_len
v.resize(new_len, val);
// 裁剪，使得长度为 new_len
v.truncate(new_len);
// 相当于v.truncate(0);
v.clear();
// truncate，并且把裁剪掉的返回成新的 Vec
let v_part2 = v.split_off(new_len);

// 下面的都是返回引用
iter,iter_mut
split_at(idx);split_at_mut
split_first();split_first_mut();
split_last();split_last_mut();
split(func_is_sep);split_mut(func_is_sep); // 基于函数，拆分为多个子切片，返回迭代器
split_splitn(n,func_is_sep);split_splitn_mut(n,func_is_sep) // 效果同上，超过n个的，会把剩余的放到第n个里面
rsplit;rsplit_mut;rsplitn; r_split_mut;  //效果同 split 系列，但是迭代器是从右向左的

v.windows(n) // 迭代器，第一个是 v[0..n]，第二个是 v[1..n+1]，直到 v[(len-n)..len]
```

```
// 清除相邻的重复元素
vec.dedup()
// 功能类似，但判断标准是一个匿名函数
vec.dedup_by(func)
// 例如：
v1.dedup_by(|elem1, elem2| (*elem1 - *elem2).abs() <= 1);

// 功能类似，但判断标准是 func(elem1) == func(elem2)
vec.dedup_by_key(func)
```

合并
```Rust
// concat：发生所有权转移
let v1: Vec<i32> = vec![1, 2];
let v2: Vec<i32> = vec![3, 2, 9];
let v3 = vec![3, 2];

// 合并1
let v_concat = [v1, v2, v3].concat();
// 合并2
[v1, v2, v3].join(&0)
```


其它
```Rust
v.swap(idx1, idx2); // 交换元素

// 移除，但不是移动内存，而是把最后一个元素移动到最前面
// 在不关心顺序的情况下，性能很高
v2.swap_remove(idx);

```



案例：
```Rust
// 去重案例
let mut v1 = vec![1, 2, 3, 2, 1];
let mut tmp = HashSet::new();
v1.retain(|r| tmp.insert(*r));
// 1. retain 相当于 .into_iter().filter()
// 2. HashSet 在插入已有的值时，会返回 false


```


## String

```Rust
// 如何创建1
let mut s1: String = String::new();

// 如何创建2
let s2_1: &str = "hello, world!";
let s2: String = s2_1.to_string();

// 如何创建3
let s3: String = String::from("hello");
// 如何转回去
let s_str: &str = &*s3;


// t添加
s1.push('a');
let s_append = "abb";
s1.push_str(s_append);

println!("{}", s1);

// 用 format连接
let s_total: String = format!("{}-{}-{}", s1, s2, s3);
println!("{}", s_total);
```


索引
- String实际上是 `Vec<u8>`，所以 `len()` 对应的是 Vec 的长度
- 不要用 `&s[0..9]` 或者 `s[0]`，遇到中文会 panic


遍历字符串

```rust
let s = String::from("你好rust语言");

// 遍历字符
for i in s.chars() {
    println!("{}", i);
}

// 这个是遍历 ascii 值，都在 0～255 之间
for i in s.bytes() {
    println!("{}", i);
}
```

不同格式的字符串
- `String`类型，看上面。
- `&[u8]`： `let my_str_u: &[u8] = b"hello";`
- `&str`，家长字符串切片 : `let my_str: &str = "hello";`

相互转换：
```Rust
String::from_utf8_lossy(my_str_u).to_string();
String::from(my_str);
// 或者 my_str.to_string
// 或者 用 format!()，建立新的 String


<String>.as_str()
<String>.as_bytes()


let new_my_str_u: &[u8] = my_str.as_bytes();
// &[u8] 转  &str 不知道咋转
```

字符串字面量


```Rust
// 1. 前面加r，使得转义字符不转义
let str1 = r"C:\files";

// 2. 前面加b，是 `[u8]` 切片类型

// 3. 也可以前面加 br


// 4. 多行
let str1 = r###"多行文本
用 'r###"'开头
"###;

// 5. 支持比较运算符 `<,<=,>,>=,==,!=`，
"abc" > "aar"
```



### 与hex的互相转

```Rust
// data-encoding = "*"

use data_encoding::{HEXUPPER, DecodeError};

let my_string=String::from("一段字符串");
// 转 hex
let my_string_hex: String = HEXUPPER.encode(my_string.as_bytes());
println!("{:?}", my_string_hex);


// hex 转字符串
let my_string_back_byte: Vec<u8> = HEXUPPER.decode(my_string_hex.as_bytes()).unwrap();
let my_string_back: String = String::from_utf8_lossy(&my_string_back_byte).to_string();
println!("{:?}", my_string_back);
```

### 与 base64 互转

```Rust
use base64;

// 转base64
let my_string = String::from("一段字符串");
let my_string_base64: String = base64::encode(&my_string);

// 转回来
let my_string_back_vec: Vec<u8> = base64::decode(&my_string_base64).unwrap();
let my_string_back = Sring::from(my_string_back_vec);
```






## collections-HashMap



```Rust
use std::collections::HashMap;

fn main() {
    // 新建
    let mut hash_map = HashMap::new();
    // 或者 HashMap::from(...);

    // 新建2（实战中往往要这么用）
    let keys = vec![String::from("blue"), String::from("red")];
    let values = vec![10, 30];
    let hash_map2: HashMap<_, _> = keys.iter().zip(values.iter()).collect();
    println!("{:?}", hash_map2);


    // 增&改
    hash_map.insert(String::from("Blue"), 10);
    hash_map.insert(String::from("Red"), 20);
    // 注：insert 之后，HashMap 将获得所有权
    // 查重复 insert 同一个 key 将覆盖


    // 查1
    let val_opt: Option<&i32> = hash_map.get("Blue");
    // 返回一个 Option
    let _b = match val_opt {
        Some(x) => println!("x={}", x),
        None => println!("None")
    };

    // 查2
    for (key, val) in &hash_map {
        println!("k:v = {}:{}", key, val);
    }

    // 改2：循环中改

    for (key, val) in &mut hash_map {
        println!("k:v = {}:{}", key, val);
        *val += 100;
    }


    // 删
    hash_map.remove("red1");


    println!("{:?}", hash_map);
}
```



## HashSet

```Rust
let mut hash_set = HashSet::new();
// 或者 HashSet::from([1,2,3,4])

// 插入
hash_set.insert(String::from("key1"));
hash_set.insert(String::from("key2"));

// 删除
hash_set.remove("key3"); // 不存在不会报错

// 清空
hash_set.clear();

// HashSet 没有那种“在循环中更改”的功能

// 其它方法
// hash_set.contains(val)
// extend
```


集合运算
```rust
is_subset
is_superset

is_disjoint // 没有任何重叠返回 true

hash_set1.intersection(&hash_set2) // 交集
hash_set1.union(&hash_set2) // 并集
```



## 控制流程

```rust

let y = {
    let x = 3;
    x + 1
};
// y=4，因为代码块最后一句是它的返回值

// 函数的最后一句也是返回值，但最后一句不要加分号
fn my_func(x: i32) -> i32 {
    x + 1
}
```

if 语句
```rust
// 1. 不会自动转换为 bool 值，必须手动转换
if x < 0 {
    println!("x<0")
} else if x < 1 {
    println!("0<=x<1")
} else { println!("x>=1") }
```

if 用于赋值

```rust
let age = 20;
// 每个分支必须都是相同类型
let sex = if age > 18 { "adult" } else { "child" };
```



loop：不停的执行

1. 可以与break，continue连用
```rust
let mut x = 1;
loop {
    x = x + 1;
    if x > 20 {
        break;
    } else if x % 3 == 0 { continue; }
    println!("{}", x);
}
```
2. break 可以像 return 一样使用，然后赋值
```rust
let mut cnt = 1;
let res = loop {
    cnt += 1;
    if cnt > 10 {
        break "end";
    }
};
```
3. break可以指定一个 **生命周期**
```Rust
'search:  // 下面break的时候，直接跳到这里（跳了2层）
for i in 0..10 {
    for j in 0..10 {
        println!("i = {}, j = {}", i, j);
        if j == 5 {
            break 'search;
        }
    }
}
```

while 条件循环

```
while cnt < 10 {
    cnt += 1;
}
```

for 循环
```
let lst = [10, 20, 30, 40, 50];

for element in lst {
    println!("the value is: {}", element);
}


for num in (1..4).rev() {
    println!("{}", num);
}
```

### 匿名函数


```Rust
let func_even = |x: u32| x % 2 == 0;
// 指定类型就必须加大括号
let func_even2 = |x: u32| -> bool{ x % 2 == 0 };
```


## 所有权

所有权让 Rust 无需 GC

内存管理的方式
- 垃圾回收机制，不断寻找不再使用的内存，例如 Java
- 开发者写明内存分配和释放，例如 C
- Rust：所有权机制

所有权规则
- 每一个值都有一个 owner （变量）
- 值在任一时刻有且只有一个所有者。
- 当owner（变量）离开作用域，这个值将被丢弃。


栈Stack，堆Heap
- Stack：
    - 存的数据大小固定
    - 后进先出，新数据总在栈顶
    - 不需要寻址
- Heap
    - 堆内存上开辟地址，标记为已用，然后返回该地址的指针
    - 访问速度比Stack曼，因为经过了一次指针


clone和copy
- `clone()` 拷贝堆和栈上的数据，特别消耗资源
- `copy()` 只拷贝栈上的数据，需要类型实现 `Copy Trait`

作用域
```
{
    let a = 1;
}
// a 的作用域结束，这里失效了
println!("{}", a); //所以报错
```


```Rust
let x = 5;
let y = x; // 这里发生了 Copy，所以可以正常运行
println!("{}{}", x, y);

// 但是这样就会报错，因为 s1 的数据被“移动”到s2了
let s1 = String::from("hello");
let s2 = s1;
println!("{}{}", s1, s2);

// 改成这样就可以了
let s1 = String::from("hello");
let s2 = s1.clone();
println!("{}{}", s1, s2);
```

如果类型实现了 copy trait，那么就可以用等号。哪些实现了 copy trait 呢：
- 所有的整型、浮点型，例如 `u32, f64`
- bool 类型
- 字符类型 `char`
- 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，`(i32, i32)` 实现了 Copy，但 `(i32, String)` 就没有。

哪些没有？
- String
- struct
- 其它


### 所有权与函数

向函数传值的时候，等同于赋值，所以规则是同上的

```Rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s);
    // println!("{}", s); // 所有权已经没了，会报错
    let x = 5;
    makes_copy(x); // 因为是 copy 的，所以所有权还在
    println!("{}", x); // 不会报错
}

fn takes_ownership(some_string: String) {
    // 运行结束，some_string 调用了 drop 方法，内存释放
}

fn makes_copy(some_integer: i32) {
//     这里的some_integer 也会调用 drop 方法，但它是 copy 来的，对之前的值没有影响
}
```

另外，函数return一个值的时候，所有权转移出去了（因此不会drop掉）  
（代码略）
- 但不要 return 它的引用，因为对应的值会drop。进而导致这个引用指向一个无效的内存。Rust 编译器不通过

### 借用

上面这种情况，把一个 String 传入函数后，就失去所有权了。**但是x1** 往往不希望这种情况发生。所以有了借用的概念

```Rust
fn main() {
    let s1 = String::from("hello");

    // &s1 创建了一个指向 s1 的引用，但没有其所有权。
    // 函数可以使用 s1，但不获取所有权
    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
  // 因为没有所有权，所以不能更改。例如，不能 s.push_str("aaaa");
    s.len()
//     因为没有所有权，所以函数结束后不触发 drop
}
```

**但是x2** 有时候还想让它在函数中可变，这就需要使用 **可变借用**

```
fn main() {
    // 1. s1 要加 mut，因为 s1 是要改动的
    let mut s1 = String::from("hello");

    // 2. &mut 表示可变引用
    let len = calculate_length(&mut s1);

    println!("The length of '{}' is {}.", s1, len);
    // s1 变成了 'helloaaaa'
}

// 3. 声明函数的时候，也要明确加 &mut
fn calculate_length(s: &mut String) -> usize {
    // 就可以改 s 了
    s.push_str("aaaa");
    s.len()
}
```


**但是x3**，同一个值，同一时间，只能有一个可变引用。这是为了防止数据竞争（data race），它会导致程序结果不可知。
- 一个已用的作用域冲声明开始，持续到最后一次使用
- 可变引用和不可变引用不能有生命周期重叠
- 可变引用和可变引用之间不能有生命周期重叠
- 不可变引用和不可变引用之间可以有重叠


```Rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2); // 报错
}
// 进一步说，一个可变引用+一个不可变引用，也会报错
```

```Rust
// 进一步所x2，不可变引用的最后一次使用后，又声明了可变引用，就没有问题
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // 没问题
    let r2 = &s; // 没问题
    println!("{} and {}", r1, r2);
    // 此位置之后 r1 和 r2 不再使用

    let r3 = &mut s; // 没问题
    println!("{}", r3);
}
```

**但是x4**，如果用大括号限制一下作用域，就不存在同时拥有权限的问题

```
// 不会报错
let mut s = String::from("hello");
{
    let r1 = &mut s;
    println!("{}", r1);
}

let r2 = &mut s;
println!("{}", r2);
```


### slice

```
let mut s = String::from("hello world");
let s1_1: &str = &s[3..s.len()];
let s1_2 = &s[3..];
let mut s2_1 = &s[..];
println!("{},{},{}", s1_1, s1_2, s2_1);
```

1. 切片等同指针
2. 字符串slice相当于不可变引用。因此生命周期按照不可变引用来理解
3. 字符串的字面值 `&str`，就是一个 slice


### 关于所有权的其它知识点

1. 引用struct后，可以直接用 `r.field`，等价于 `(*r).field`
2. 在做比较时，也无需解引用 `r1<=r2;r1==r2`，等价于 ` (*rx) == (*ry)`
3. 但是 `std::ptr::eq(rx, ry)` 是判断引用是否指向同一块内存
4. Rust的引用不可能为空


### 延迟计算全局静态常量 lazy_static

```Rust
// lazy_static = "*"
#[macro_use]
extern crate lazy_static;

// use lazy_static;
use std::collections::HashMap;

lazy_static! {
    static ref PRIVILEGES: HashMap<&'static str, Vec<&'static str>> = {
        println!("生成静态变量");
        let mut map = HashMap::new();
        map.insert("James", vec!["user", "admin"]);
        map.insert("Jim", vec!["user"]);
        map
    };
}

fn show_access(name: &str) {
    let access = PRIVILEGES.get(name);
    println!("{}: {:?}", name, access);
}

fn main() {
    println!("开始运行");
    let access = PRIVILEGES.get("James");
    println!("James: {:?}", access);

    show_access("Jim");
}
```





## 智能指针

简单的是用 Box 实现的，Box 允许你把值放到堆上，而不是栈上。

```
fn main() {
    let b = Box::new(5);
    println!("b = {}", b)
}
```





## 特性参考代码



打印结构体
```
// 1. 需要加上下面这行
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect = Rectangle {
        width: 30,
        height: 50,
    };
    println!("Rect is {:?}", rect);
    // 下面这个格式更好看
    println!("Rect is {:#?}", rect);
}
```
结果：

```
Rect is Rectangle { width: 30, height: 50 }
Rect is Rectangle {
    width: 30,
    height: 50,
}
```






## 参考

https://rustwiki.org/zh-CN/book/ch03-05-control-flow.html
