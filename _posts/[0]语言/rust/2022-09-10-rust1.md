---
layout: post
title: 【Rust】初学 笔记
categories: 语言
tags:
keywords:
description:
order: 19001
---







```bash
# 编译
rustc main.rs

# 运行
./main
```


cargo:系统和包管理器

```bash
cargo --version

# 创建一个新的cargo项目
cargo new learn_rust_project

# 编译
cargo build

# 编译并运行代码
cargo run
```


## 基本语法

```rust
// 加上 mut 是可变的(mutable)，不加是不可变的
let mut guess = String::new();


io::stdin()
    .read_line(&mut guess)
    .expect("Failed to read line");

//
println!("You guessed: {}", guess);
```

导入别的项目
```text
rand = "0.8.3"
// Crates.io 是 Rust 生态

```



猜数字的代码
```rust
use std::cmp::Ordering;
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the num!");

    let secret_num = rand::thread_rng().gen_range(1..101);

    println!("secret num is {}", secret_num);


    loop {
        println!("Please input you guess:");

        //？？？为啥要在loop中定义
        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");


        // let guess: u32 = guess.trim().parse().expect("Please type a number!");
        // 用 match，而不是 expect，匹配抛出的错误，并做相应的处理
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("pleas input a num!");
                continue;
            }
        };


        println!("You guessed: {}", guess);


        match guess.cmp(&secret_num) {
            Ordering::Less => println!("Too small"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```


## 变量


变量类型
- 可变变量 `let mut x = 1`
- 不可变变量 `let x = 1`
- 常量 `const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`
    - 运行的整个过程中有效

### 遮蔽

遮蔽
```rust
fn main() {
    let x = 5;
// x = 5
    let x = x + 1;
    // x = 6

    {
        let x = x * 2;
        // x = 12
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
    // 内部遮蔽结束，这里 x = 6
}
```

遮蔽2
```rust
// 不同类型可以遮蔽 1）必须不能加 mut，2）必须是不同类型
let x = "abcd";
let x = x.len();
```


### 数据类型
- rust是静态类型，必须编译时知道所有变量的类型

整型


|  长度  | 有符号类型 | 无符号类型 |
|:------:|:----------:|:----------:|
| 8 位   | i8         | u8         |
| 16 位  | i16        | u16        |
| 32 位  | i32        | u32        |
| 64 位  | i64        | u64        |
| 128 位 | i128       | u128       |
| arch   | isize      | usize      |


- 浮点型 `f32`, `f64`
- bool类型 `bool`
- 元组
    - 赋值： `let tup: (i32, f64, u8) = (500, 6.4, 1);`
    - 取值1：`let (x, y, z) = tup;`
    - 取值2： `let y = tup.1;`
- 数组
    - 赋值 `let a: [i32; 5] = [1, 2, 3, 4, 5];`
    - 赋值2: `let a = [3; 5];` 这是3重复5次
    - 取值：`a[0]`





## 基本语法

```rust

let y = {
    let x = 3;
    x + 1
};
// y=4，因为代码块最后一句是它的返回值

// 函数的最后一句也是返回值，但最后一句不要加分号
fn my_func(x: i32) -> i32 {
    x + 1
}
```

if 语句
```rust
// 1. 不会自动转换为 bool 值，必须手动转换
if x < 0 {
    println!("x<0")
} else if x < 1 {
    println!("0<=x<1")
} else { println!("x>=1") }
```

if 用于赋值

```rust
let age = 20;
// 每个分支必须都是相同类型
let sex = if age > 18 { "adult" } else { "child" };
```



loop：不停的执行

1. 可以与break，continue连用
```rust
let mut x = 1;
loop {
    x = x + 1;
    if x > 20 {
        break;
    } else if x % 3 == 0 { continue; }
    println!("{}", x);
}
```
2. break 可以像 return 一样使用，然后赋值
```rust
let mut cnt = 1;
let res = loop {
    cnt += 1;
    if cnt > 10 {
        break "end";
    }
};
```



## 参考

https://rustwiki.org/zh-CN/book/ch03-05-control-flow.html
