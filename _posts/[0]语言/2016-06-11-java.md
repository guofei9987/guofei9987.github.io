---
layout: post
title: 【Java】入门笔记
categories: 语言
tags: 
keywords:
description:
order: 1014
---

## 知识点

Java特点
- Write once, run anywhere，跨平台能力
- 垃圾收集（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下不需要自己操心内存的分配和回收


- Java 程序执行过程。`.java`（代码）-(编译)->`.class`字节码文件-->`虚拟机`解释执行
- JDK： Java 开发工具包。包括两个组件：
    - 开发工具集，如Javac（编译器，把源程序转为字节码），
    - JRE（Java Runtime Environment）。包括JVM（Java Virtual Machine，Java虚拟机，是Java平台无关性的关键），Java核心类库和支持文件。


Java平台
- Java SE：Java 标准版，用来开发桌面程序。
- Java EE：Java 企业版，多了Web程序开发。
- Java ME：Java 微型版，用来移动设备开发。用的越来也少了。


## HelloWorld

```java
// HelloWorld.java

/**
 * @author guofei9987
 * @version 0.0.1
 * 文档型注释，用 java doc 命令自动生成文档
 */

/*
多行注释
*/

// 单行注释
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println(args[0]);
    }
}
```

```bash
javac HelloWorld.java # 用来生成 *.class 字节码
java HelloWorld Hello World # 执行代码，会输出 Hello，这是因为 Wrold 对应 args[1]
```


<!--
## 进阶知识点
对于 Java 平台的理解，可以从很多方面简明扼要地谈一下，例如：Java 语言特性，包括泛型、Lambda 等语言特性；基础类库，包括集合、IO/NIO、网络、并发、安全等基础类库。

JVM 的一些基础概念和机制，比如 Java 的类加载机制，常用版本 JDK（如 JDK 8）内嵌的 Class-Loader，例如 Bootstrap、 Application 和 Extension Class-loader；类加载大致过程：加载、验证、链接、初始化（这里参考了周志明的《深入理解 Java 虚拟机》，非常棒的 JVM 上手书籍）；自定义 Class-Loader 等。还有垃圾收集的基本原理，最常见的垃圾收集器，如 SerialGC、Parallel GC、 CMS、 G1 等，对于适用于什么样的工作负载最好也心里有数。这些都是可以扩展开的领域，我会在后面的专栏对此进行更系统的介绍。

当然还有 JDK 包含哪些工具或者 Java 领域内其他工具等，如编译器、运行时环境、安全工具、诊断和监控工具等。这些基本工具是日常工作效率的保证，对于我们工作在其他语言平台上，同样有所帮助，很多都是触类旁通的。


几个板块：
- Java 基础：Java 语言基本特性和机制
- Java 进阶：并发编程、Java 虚拟机等领域展开
- Java 应用开发扩展：从数据库编程、主流开源框架、分布式开发等，
- Java 安全基础：应用安全问题和处理方法
- Java 性能基础：掌握相关工具、方法论与基础实践。
-->






## 工具安装

- JDK 去 oracle 官网下载。https://www.oracle.com/downloads/
- IDE 去 jetbrain 官网下载 IntelliJ IDEA https://www.jetbrains.com/
- 打开IDE，右键 new->Module, 然后开始编程



## 代码规范

- 大小写敏感
- 类名：每个单词的首字母大写，例如 MyFirstJavaClass 。
- 方法名：小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
- 变量名：规范同方法名
- 源文件名：源文件名必须和类名相同后缀为.java。
- 主方法入口：所有的Java 程序由public static void main(String[] args)方法开始执行。
- 注释方法类似 C

## 基本

```java
public class Puppy{
    int puppyAge;
    public Puppy(String name){
        // 这个构造器仅有一个参数：name
        System.out.println("Passed Name is :" + name );
    }

    public void setAge( int age ){
        puppyAge = age;
    }

    public int getAge( ){
        System.out.println("Puppy's age is :" + puppyAge );
        return puppyAge;
    }

    public static void main(String []args){
        /* 创建对象 */
        Puppy myPuppy = new Puppy( "tommy" );
        /* 通过方法来设定age */
        myPuppy.setAge( 2 );
        /* 调用另一个方法获取age */
        myPuppy.getAge( );
        /*你也可以像下面这样访问成员变量 */
        System.out.println("Variable Value :" + myPuppy.puppyAge );
    }
}
```

程序入口是main

## 数据类型

### 基本数据类型


6种数字类型，1种字符类型，1种布尔类型


|数据类型|说明|字节|最小值|最大值|默认值|例子|
|--|--|--|--|--|--|--|--|
|byte|8位，有符号，以二进制补码表示，整数|1|-128（-2^7）|127（2^7-1）|0|byte a = 100，byte b = -50|
|short|16位、有符号的以二进制补码表示的整数|2|-32768（-2^15）|32767（2^15 - 1）|0|short s = 1000，short r = -20000|
|int|32位、有符号的以二进制补码表示的整数|4|-2,147,483,648（-2^31）|2,147,483,647（2^31 - 1）|0|int a = 100000, int b = -200000|
|long|64位、有符号的以二进制补码表示的整数|8|约 -9E18（-2^63）|约 9E18（2^63 -1）|0L|long a = 100000L，long b = -200000L|
|float|单精度、32位、符合IEEE 754标准的浮点数，不能用来表示精确的值，如货币|4|||0.0f|float f1 = 234.5F;|
|double|双精度、64位、符合IEEE 754标准的浮点数，不能表示精确的值，如货币|8|||0.0d|double d1 = 123.4; double d1 = 123D; double d=.2E5;|
|boolean|只有两个取值：true和false|1|||false|boolean one = true|
|char|单一的16位Unicode字符|2|'\u0000'（即为0）|'\uffff'（即为65,535）||char letter = 'A'; char ch = 65; char ch1='\u005d';|

在赋值或初始化时，可以把“小的”类型赋值给“大的”类型，反过来不行。

进制
- 八进制：0开头，如037，056
- 十六进制：0x或0X开头，如 0x12ab
- 进制也可以指定类型，如 0x123L


字符串
- `String s="";`
- 可以出现 unicode `String s="\u005d\u005fABC";`
- 可以用加号连接

```java
str.toUpperCase()
```

### 基本数据类型转换

分为自动类型转换，显式的类型转换。
- 自动类型转换：范围小的转为范围大的。
- 显式的类型转换  `double d = 12.3; float f = (float) d;`


```java
int x = 10, y = 5;
System.out.println("" + x + y); // 105，按照字符串连接
System.out.println(x + y + ""); // 先运算然后字符串连接
System.out.println(' ' + x + y); // char格式被转换为int
```


### 常量

指不能改变的量，一般用大写表示。
```java
final double PI = 3.1415927;
```

### String

默认是 null

## 运算符


- 算术运算符
```java
+
-
*
/ // 如果分子分母都是int，结果为int
% // 求余数
int y = x++;
y = ++x; // 先自增，然后赋值
y = --x;
y = x--;
```
- 赋值运算符
```java
int x = 1; // 普通的赋值
x += 5;
x -= 5;
x *= 5;
x /= 5;
x %= 5;
```
- 关系运算符
```java
>; <; >=; <=; ==;!=;
'A'>'B' // 结果是 false，比较的是 ASCII
float f=5.0f; long l=5; f==l; // true, 只要值相等，就返回 true
```
- 逻辑运算符
```java
& // 与
&& // 与，如果第一个为 false，后面就不算了
| //或
|| //或快，如果第一个为 true，后面就不算了
! // 非
```
- 条件运算符
```java
// 语法：bool?expr1:expr2
// 例子：
int x = 1, y = 2;
int max = (x > y) ? x : y;
```
- 位运算符


## 流程控制

### 条件语句
if
```java
// if
if(a>b){
    System.out.println('yes');
}

// if-else
if(a>b){
    System.out.println('yes');
}
else{
    System.out.println('no');
}

// 多重if，只会执行一个分支
if(bool1){
  expr1;
}
else if(bool2){
  expr2;
}
else if(bool3){
  expr3;
}
else{
  exprn;
}


// 嵌套if，不多说。

// 如果没有大括号，else会匹配到最近的if
```

switch
```java
switch(bool){
  case value1:
    expr1;break;
  case value2:
    expr2;break;
  default: // default 可以省略。
    expr3;
}
```


### 循环语句
while

```java
while(bool){
  expr1;
}

// do-while 循环，至少会循环一次。
do{
  exp1;
}while(bool1); // 这里必须以分号结尾
```

for
```java
for(初始化表达式;循环条件表达式;类似n++) // 每个表达式都可以省略，可以把逻辑放到其它地方：初始化表达式可以放for循环之前，循环条件表达式可以在循环体中用break语句代替，自增表达式也可以放循环体。最省略的形式 for(;;;)
{
  expr1;
}


int sum = 0;
for (int i = 1; i <= 5; i++) {
    int n = 1;
    sum += i;
}
// 1. 这里会报错，for循环内定义的变量，作用范围只能在for循环中。
// 2. 如果 int i 在for循环外定义，就不报错，返回6.
System.out.println(i);
System.out.println(n); // 同样报错，原因同上


// 对数组for循环
String [] names ={"James", "Larry", "Tom", "Lacy"};
for(String name:names){
  System.out.println(name);
}
```



```java
// 功能不多说，只对单层循环有效。
break
continue
```



## 数组


数组分配连续的内存空间

```java
// 数组的声明
数据类型[] 数组名; // 常用的形式
数据类型 数组名[]; // 这种是为了和其它语言保持一致

// 数组的创建
// 方法1. 先声明后创建
数据类型[] 数组名;
数组名 = new 数据类型[数组长度];
// 例：
int[] arr;
arr = new int[10];
// 方法2 声明时创建
数据类型[] 数组名 = new 数据类型[数组长度]
int[] arr=new int[10];


// 数组的初始化
int[] arr = {1,2,3,4,5,6,};
```

数组的使用
```java
arr[0]; // 取数
arr.length; // 长度
arr[1] = 1; // 赋值
```

例子：
```java
int[] intArray = new int[5];
String[] strArray = new String[5];
float[] floatArray = new float[3];
char[] ch = {'a', 'b', 'c', 'd'};
```



下面展示对象构成的数组是如何使用的：

```java
// DataType.java
public class DataType {
    public int a=1;
    public String b="dataType";

}


public class Main {

    public static void main(String[] args) {
        int arraySize = 5;
        DataType[] myArray = new DataType[arraySize]; // 定义了一个空 array
        System.out.println(myArray.getClass());

        // 第一种循环
        for (int i = 0; i < myArray.length; i++) {
            myArray[i] = new DataType(); // 填充这个空 array
        }


        // 数组作为输入和输出
        DataType[] myArray1 = myArrayFunc(myArray);

        // 第二种循环： foreach 循环
        for (DataType element : myArray1) {
            System.out.println(element.a);
        }


    }

    // 数组作为函数输入值 + 数组作为函数返回值
    public static DataType[] myArrayFunc(DataType[] inputs) {
        return inputs;
    }

}
```

以上代码展示了
- 如何创建一个 array
- 如何填充一个 array
- 两种循环方法
- array 如何作为函数的输入，如何作为函数的输出


下面展示了一些 array 方法
```Java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Arrays;

public class Main {

    public static void main(String[] args) {
        int[] myArray1 = new int[5];
        int[] myArray2 = new int[5];
        for (int i = 0; i < 5; i++) {
            myArray1[i] = i;
            myArray2[i] = i;
        }

        // Arrays.equals 用来判断两个 array 是否完全相等
        boolean totalEqual = Arrays.equals(myArray1, myArray2);
        System.out.println(totalEqual);

        // Arrays.fill 用来用指定类型填充 array
        Arrays.fill(myArray1, 1);
        for (int elements : myArray1) {
            System.out.println(elements);
        }

        // Arrays.sort 用来升序排列
        Arrays.sort(myArray2);
        for (int elements : myArray2) {
            System.out.println(elements);
        }
    }
}
```

## 其它数组（未整理完）

### ArrayList


```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


public class Main {
    public static void main(String[] args) {
        List<Integer> myArray = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            myArray.add(i);
        }
        System.out.println(myArray);

        Iterator<Integer> nameIterator = myArray.iterator();

        // remove
        while (nameIterator.hasNext()) {
            Integer a = nameIterator.next();
            System.out.println(a);
            if (a == 3) {
                nameIterator.remove();
            }
            System.out.println(myArray);
        }

        // forEachRemaining()方法对集合中尚未由迭代器访问的每个元素执行操作。
        // 迭代器是一次性对象。不能重置。要再次遍历，需要创建一个新的Iterator。
        Iterator<Integer> nameIterator2 = myArray.iterator();
        nameIterator2.forEachRemaining(System.out::println);
    }
}
```

以上代码展示了
- 2种借用 iterator 的遍历方法
- remove 方法

### Set

```java
import java.util.HashSet; // HashSet
import java.util.LinkedHashSet; // 有序的 HashSet
import java.util.Set;

Set<String> s1 = new HashSet<>();

s1.add("About")
s1.remove("About")
```

集合操作
```java
// 并集，结果存到 s1
s1.add(s2);
// 交集，结果存到 s1
s1.retainAll(s2);
// 差集，结果存到 s1
s1.removeAll(s2);

// boolean 类型，是否是子集
s2.containsAll(s1)
```





## 面向对象

### 方法

```java
public/protected/private stastic void/int methodName(int inp){
  return inp
}
```

案例：

```java
public class HelloWorld {
    // 1. 无参数无返回值方法
    public void printStar() {
        System.out.println("*********");
    }
    // 2. 有参数有返回值方法
    public float myFunc(float a,float b){
        printStar(); // 3. 不在主方法中调用方法，就可以不用 new 一个
        return a+b;
    }

    public static void main(String[] args) {
        // 4. 在main中调用方法：
        HelloWorld helloWorld = new HelloWorld();
        helloWorld.printStar();
        float c= helloWorld.myFunc(1.2f,1.5f);
        System.out.println(c);
        helloWorld.printStar();
    }
}
```




#### 重载
方法的重载：方法名相同，但入参列表不同。  
```Java
// 一个重载的例子
public class D {
    public void func(int a) {
        System.out.println("int");
    }

    public void func(String a) {
        System.out.println("String");
    }

    public static void main(String[] args) {
        D d = new D();
        d.func(1);
        d.func("1");
    }
}
```

#### 可变参数类型
可变参数列表
```java
public class HelloWorld {
    public int get_sum(int... n) { // 可变参数列表
        int sum = 0;
        for (int i : n) {
            sum += i;
        }
        return sum;
    }

    public static void main(String[] args) {
        HelloWorld helloWord = new HelloWorld();
        System.out.println(helloWord.get_sum(1));
        System.out.println(helloWord.get_sum(1, 2, 3));
    }
}
```

可变参数类型2
```java
public class HelloWorld {
    public boolean isIn(int a, int... n) { // 可变参数必须放到最后。这个n可以传入数组，因此不能再写一个同名方法重载另一个n是数组的方法了。
        for (int i : n) {
            if (a == i) {
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        HelloWorld helloWord = new HelloWorld();
        System.out.println(helloWord.isIn(1, 1, 2, 3, 4));
        System.out.println(helloWord.isIn(5, 1, 2, 3));
    }
}
```

可变参数列表：
- 可变参数必须放到最后。
- 可变参数位置的可以传入数组。因此不能再写一个同名方法重载另一个n是数组的方法了（因为已经有了这样一个方法了）。
- 多个同名方法同时满足时，可变参数最后被调用。例如，两个方法 `func(int a, int b)`, `func(int... a)`，那么调用 `func(1,2)` 会优先调用第一个。


方法的传值问题：在方法中改变一个变量的值，方法外会怎样？
- （与 Python 一样）
- 如果传入int等，方法中改变值后，方法外不变
- 如果传入数组，方法外会跟着变
- 如果传入自定义对象，方法外会跟着变



### 继承
```java
// A.java
public class A {
    private int i;
    protected int j;

    public void func1() {
        System.out.println("Class A");

    }
}



// B.java
public class B extends A {
    public int z;

    public void func2(){
        super.func1(); // 注意这个 super 方法
        System.out.println("Class B");

    }

}

// C.java
public class C {

    public static void main(String []args){
        A a=new A();
        B b=new B();

        System.out.println("Hello world!");
        System.out.println(a instanceof A);
        System.out.println(b instanceof B);
        b.func1();

    }
}
```

- 重写 (Override)：子类可以写一个同名的方法，覆盖掉父类的同名方法。
    - 参数列表与被重写方法的参数列表必须完全相同。
    - 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
    - 子类方法的访问权限必须大于或等于父类方法的访问权限。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
    - 声明为 final 的方法不能被重写。
    - 声明为 static 的方法不能被重写，但是能够被再次声明。
    - 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
    - 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
    - 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
    - 构造方法不能被重写。
    - 如果不能继承一个方法，则不能重写这个方法。
    - 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 重载 (overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。





## 参考资料

https://www.w3cschool.cn/java/
