---
layout: post
title: 【C6】编译
categories: 语言
tags:
keywords:
description:
order: 10006
---



## 编译

gcc
```bash
gcc -o main.so main.c
# 然后执行 main 文件
./main.so

# (或者)编译+链接
gcc -o main.o main.c -c
gcc -o main main.o

# 编译优化
gcc -o main.so main.c -O3
```


- `O0` （默认）不进行任何优化，
    - 优点：编译消耗低（时间，空间）。debug方便，可以打断点打断，给任意的给变量赋值。
- `O1` 会消耗稍多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。
- `O2` 会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。
- `O3` 在 `O2` 的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。
- `Os` 一般不用。主要是对代码大小的优化。会关闭一些性能优化选项。会打乱程序的结构，无法调试。会打乱执行顺序，依赖内存操作顺序的程序无法正确执行。实际基本不用这个选项。
- `Ofast` 一般不用。用一些非国际标准，进一步做非常规的优化。



include
```c
#include <stdio.h> // 表示文件在系统目录下
#include "a.h" // 表示文件在当前目录下
```

知识
- main函数是执行的起点，有且只能有1个
- printf 是向标准设备输出，未必是向屏幕输出，例如 `./main > save.txt`
- 建议用 `int main`，而不是 `void main`，后者不支持c++
- 约定 `return 0;` 代表执行成功，`return -1;` 代表执行失败
- 预编译：把 include 替换进来，删除注释，等操作。`gcc -o  main1.c main.c -E`
- 汇编 `gcc -o main.s main.c -S`
- `cc`也可以，但`gcc` 多操作系统，多语言，所以一般用 `gcc`



## 多文件

头文件 `my_lib.h`
```c
//防止头文件被重复包含
#pragma once

//兼容C++编译器，如果遇到C++编译器，按C编译
#ifdef __cplusplus
extern "C"
{
#endif

//    这里声明你的函数
int my_func1();

#ifdef __cplusplus
}
#endif
```

实现文件 `my_lib.c`
```c
int my_func1(){
    return 0;
}
```

引用 `my_test.c`
```c
#include <stdio.h>
#include "my_lib.h"

int main(void) {
    printf("%d", my_func1());
}
```

如何编译
```bash
gcc -o my_test my_test.c my_lib.c
```

### 方式2

```c
// my_lib.h
// 防止重复导入
#ifndef LEARN_C_MY_LIB_H
#define LEARN_C_MY_LIB_H

int my_func1(int x);

#endif //LEARN_C_MY_LIB_H


// my_lib.c
int my_func1(x) {
    return x + 1;
}

// main.c
#include <stdio.h>
#include "my_lib.h"

int main() {
    printf("%d\n", my_func1(5));
    return 0;
}

// 编译
gcc -o main.o main.c my_lib.c
// 执行
./main.o
```



### 方式3

```c
// my_lib.c
int func1(int x) {
    return x + 1;
}

// main.c
// 定义一下
int func1(int x);

int main() {
    printf("%d\n", func1(25));
}

// 编译
gcc -o main.o main.c my_lib.c
// 执行
./main.o
```



## 引入库文件



编译步骤
1. 准备 `.c/.cpp` 源文件
2. 预编译。把代码展开到 `#include`, `#define` 位置。生成 `.i` 文件
    - `gcc -E hello.c -o hello.i`
    - 或者 `cpp hello.c > hello.i`
3. 编译。生成 `.s` 汇编语言
    - `gcc -S hello.i -o hello.s`
4. 汇编。将汇编代码转变成机器可以执行的指令。生成 `.o` 文件（object）
    - `gcc -c hello.s -o hello.o`
    - 或者 `as hello.s -o hello.o`
5. 链接。引用别的库。两种类型：
    - 静态库。链接后直接注入目标程序（所以文件会更大，但是链接后就不需要再保留被引用的库了）。库文件名字通常为 `libxxx.a`。
    - 动态库。运行目标程序时加载，库文件通常以 `.so` 结尾
6. 完成以上步骤后，得到最终的可执行程序





### 静态库




编译静态库
```bash
gcc -c hello.c -o hello.o # .c 文件编译为 .o 文件
ar rcs libhello.a hello.o # 生成静态库文件 libhello.a
```

关于 ar 命令
```bash
ar  archivefile  objfile
archivefile：archivefile是静态库的名称
objfile：      objfile是已.o为扩展名的中间目标文件名，可以多个并列
参数        意义
-r            将objfile文件插入静态库尾或者替换静态库中同名文件
-x            从静态库文件中抽取文件objfile
-t            打印静态库的成员文件列表
-d            从静态库中删除文件objfile
-s            重置静态库文件索引
-v            创建文件冗余信息
-c            创建静态库文件
```


链接静态库
```bash
gcc tst.c -o tst -L . -lhello
```
解读一下： -L 后面是静态库文件所在的目录，我这里 . 就是指当前目录的意思。也就是库文件就和源文件在同一路径。真正编译的时候，这个路径还是要填绝对路径要好，这个需要注意一下。后面的-l加上库名，这个库名是去掉lib和后面的.a。静态库的链接就是这样的。




### 动态库


使用下面的命令就可以生成一个动态库文件 `libhello.so`

```bash
gcc -fPIC -shared -o libhello.so hello.c
```
- -fPIC 是创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。
- -shared指定生成动态链接库。


调用动态库
```c
gcc tst.c -o tst -L ./ -lhello
```

同样，-L后面是库文件的路径，最好是用绝对路径。-l加上去掉lib的库名。然后直接执行可执行文件就可以了。

参考文档：https://cloud.tencent.com/developer/article/1656728?from=15425



## cmakelist.txt


https://blog.csdn.net/afei__/article/details/81201039


## 大型项目的代码规范


C 语言的特性要求所有的函数、结构体名字都不能一样，否则编译时会重复，这导致命名会很长、很丑，可以这样

```c
#ifndef MYPROJECT_MY_LIB_H
#define MYPROJECT_MY_LIB_H

#define T My_Project_Stack_T;

//一大堆函数，大量用到 T
//如此，在这个文件中，可以用 T 来表示 My_Project_Stack_T，大大减少了阅读负担

#undef T
#endif //MYPROJECT_MY_LIB_H
```


### ATOM：一种可让相同的字符串只存一次的方案

- 效果：当程序中申请 new 一个字符串，如果这个字符串之前出现过，就把指针指向之前出现过的那个。
- 优点：节约空间
- 注：经常用于字符串，但其它

关键方案
```c
static struct atom {
    struct atom *link; // 哈希冲突的，用链表存下来
    int len;    // 这个字符串的长度
    char *str; // 存放这个字符串
} *buckets[2048];
```

根据字符串的值，决定其hash值，然后分桶

哈希函数有很多，简单的一个：
```c
for(h=0,i=0;i<len;i++){
    h=(h<<1) + scatter[(unsigned char) str[i]];
}
// 其中 scatter[256] 是一个随机数组，用 rand.h 生成的，它用来帮助hash值更均匀
// (unsigned char) 是因为有的机器char值是带符号的
```



哈希表（python中的dict）有类似的实现

```c
struct T{
    struct binding{
        struct binding *link;
        const void *key;
        void *value;
    } **buckets;
}

int size;

```


...


集合