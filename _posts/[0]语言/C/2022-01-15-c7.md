---
layout: post
title: 【C7】数据结构
categories: 语言
tags:
keywords:
description:
order: 10005
---


## 数组

静态数组
```c
int arr[] = {1, 2, 4};
```

### 动态数组

DynamicArray.h
```c
#ifndef DYNAMIC_ARRAY_H
#define DYNAMIC_ARRAY_H

#include<stdlib.h>
#include<stdio.h>
#include<string.h>

typedef struct DYNAMIC_ARRAY {
    int *pAddr;
    int capacity;
    int size;

} Dynamic_Array;

//初始化
Dynamic_Array *Init_Dynamic_Array();

//打印
void Print_Dynamic_Array(Dynamic_Array *arr);

//插入
void Push_Dynamic_Array(Dynamic_Array *arr, int val);

//删除
void Pop_Dynamic_Array(Dynamic_Array *arr,int idx);

int Find_Dynamic_Array(Dynamic_Array *arr,int val);
int Get_Dynamic_Array(Dynamic_Array *arr, int idx);
void Set_Dynamic_Array(Dynamic_Array *arr, int idx, int val);

// 释放空间
void Free_Dynamic_Array(Dynamic_Array *arr);

#endif //DYNAMIC_ARRAY_H
```


DynamicArray.c
```c
#include "Dynamic_Array.h"

//初始化
Dynamic_Array *Init_Dynamic_Array() {
    Dynamic_Array *arr = (Dynamic_Array *) malloc(sizeof(Dynamic_Array));
    arr->capacity = 20;
    arr->size = 0;
    arr->pAddr = (int *) malloc(sizeof(int) * arr->capacity);
    return arr;
}

//插入
void Push_Dynamic_Array(Dynamic_Array *arr, int val) {
    if (arr == NULL) {
        return;
    }

    if (arr->size == arr->capacity) {
        int new_capacity = arr->capacity * 2;
        int *newPArr = (int *) malloc(sizeof(int) * arr->capacity);
        memcpy(newPArr, arr->pAddr, sizeof(int) * arr->capacity);
        free(arr->pAddr);

        arr->pAddr = newPArr;
        arr->capacity = new_capacity;
    }
    arr->pAddr[arr->size] = val;
    arr->size++;

}

//打印
void Print_Dynamic_Array(Dynamic_Array *arr) {
    if (arr == NULL) {
        return;
    }
    for (int i = 0; i < arr->size; i++) {
        printf("%d,", arr->pAddr[i]);
    }
    printf("\n");
}

//删除一个
void Pop_Dynamic_Array(Dynamic_Array *arr, int idx) {
    if (arr == NULL) {
        return;
    }
    if (idx < 0 || idx >= arr->size) {
        return;
    }

    arr->size--;
    for (int i = idx; i < arr->size; i++) {
        arr->pAddr[i] = arr->pAddr[i + 1];
    }

}

//取一个
int Get_Dynamic_Array(Dynamic_Array *arr, int idx) {
    return arr->pAddr[idx];
}
//赋值
void Set_Dynamic_Array(Dynamic_Array *arr, int idx, int val) {
    arr->pAddr[idx] = val;
}

//查找
int Find_Dynamic_Array(Dynamic_Array *arr, int val) {
    for (int i = 0; i < arr->size; i++) {
        if (arr->pAddr[i] == val) {
            return i;
        }
    }
    return -1;
}

//释放空间
void Free_Dynamic_Array(Dynamic_Array *arr) {
    if (arr == NULL) {
        return;
    }
    if (arr->pAddr != NULL) {
        free(arr->pAddr);
    }
    free(arr);
}
```

测试

```c
#include <stdio.h>

#include "Dynamic_Array.h"

int main() {

    Dynamic_Array *arr = Init_Dynamic_Array();

    for (int i = 0; i < 30; i++) {
        Push_Dynamic_Array(arr, i);
    }

    Print_Dynamic_Array(arr);

    Pop_Dynamic_Array(arr, 3);
    Print_Dynamic_Array(arr);

    printf("%d\n", Find_Dynamic_Array(arr, 5));
    printf("%d\n", Get_Dynamic_Array(arr, 5));


    Set_Dynamic_Array(arr, 0, 30);
    Print_Dynamic_Array(arr);

    Free_Dynamic_Array(arr);


}
```

## 链表

LinkList.h
```c
#ifndef LINKLIST_H
#define LINKLIST_H

#include<stdlib.h>
#include<stdio.h>

//链表结点
typedef struct LINKNODE{
    void* data;  //指向任何类型的数据
    struct LINKNODE* next;
}LinkNode;

//链表结构体
typedef struct LINKLIST{
    LinkNode* head;
    int size;
}LinkList;



//初始化链表
LinkList* Init_LinkList();
//指定位置插入
void Insert_LinkList(LinkList* list,int pos,void* data);
//删除指定位置的值
void RemoveByPos_LinkList(LinkList* list, int pos);
//获得链表的长度
int Size_LinkList(LinkList* list);
//查找
int Find_LinkList(LinkList* list,void* data);
//返回第一个结点
void* Front_LinkList(LinkList* list);
//释放链表内存
void FreeSpace_LinkList(LinkList* list);


//不知道用户要打印什么，所以定义一个打印函数指针，用户传入print即可
typedef void(*PRINTLINKNODE)(void*);
//打印链表结点
void Print_LinkList(LinkList* list, PRINTLINKNODE print);

#endif
```

LinkList.c
```c
#include"LinkList.h"

//初始化链表
LinkList* Init_LinkList(){

    LinkList* list = (LinkList*)malloc(sizeof(LinkList));
    list->size = 0;

    //头结点 不保存数据信息
    list->head = (LinkNode*)malloc(sizeof(LinkNode));
    list->head->data = NULL;
    list->head->next = NULL;

    return list;
}
//指定位置插入
void Insert_LinkList(LinkList* list, int pos, void* data){

    if (list == NULL){
        return;
    }
    if (data == NULL){
        return;
    }

    if (pos < 0 || pos > list->size){
        pos = list->size;
    }

    //创建新的结点
    LinkNode* newnode = (LinkNode*)malloc(sizeof(LinkNode));
    newnode->data = data;
    newnode->next = NULL;

    //找结点
    //辅助指针变量
    LinkNode* pCurrent = list->head;
    for (int i = 0; i < pos;i++){
        pCurrent = pCurrent->next;
    }

    //新结点入链表
    newnode->next = pCurrent->next;
    pCurrent->next = newnode;

    list->size++;

}
//删除指定位置的值
void RemoveByPos_LinkList(LinkList* list, int pos){
    if (list == NULL){
        return;
    }

    if (pos < 0 || pos >= list->size){
        return;
    }

    //查找删除结点的前一个结点
    LinkNode* pCurrent = list->head;
    for (int i = 0; i < pos;i ++){
        pCurrent = pCurrent->next;
    }

    //缓存删除的结点
    LinkNode* pDel = pCurrent->next;
    pCurrent->next = pDel->next;
    //释放删除结点的内存
    free(pDel);

    list->size--;
}
//获得链表的长度
int Size_LinkList(LinkList* list){
    return list->size;
}
//查找
int Find_LinkList(LinkList* list, void* data){
    if (list == NULL){
        return -1;
    }

    if (data == NULL){
        return -1;
    }

    //遍历查找
    LinkNode* pCurrent = list->head->next;
    int i = 0;
    while (pCurrent != NULL){
        if (pCurrent->data == data){
            break;
        }
        i++;
        pCurrent = pCurrent->next;
    }

    return i;
}
//返回第一个结点
void* Front_LinkList(LinkList* list){
    return list->head->next->data;
}
//打印链表结点
void Print_LinkList(LinkList* list, PRINTLINKNODE print){
    if (list == NULL){
        return;
    }
    //辅助指针变量
    LinkNode* pCurrent = list->head->next;
    while (pCurrent != NULL){
        print(pCurrent->data);
        pCurrent = pCurrent->next;
    }

}
//释放链表内存
void FreeSpace_LinkList(LinkList* list){

    if (list == NULL){
        return;
    }

    //辅助指针变量
    LinkNode* pCurrent = list->head;
    while (pCurrent != NULL){
        //缓存下一个结点
        LinkNode* pNext = pCurrent->next;
        free(pCurrent);
        pCurrent = pNext;
    }

    //释放链表内存
    free(list);
}
```

测试
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "LinkList.h"


//自定义数据类型
typedef struct PERSON{
    char name[64];
    int age;
    int score;
}Person;


//打印函数
void MyPrint(void* data){
    Person* p = (Person*)data;
    printf("Name:%s Age:%d Score:%d\n",p->name,p->age,p->score);
}

int main(void){


    //创建链表
    LinkList* list = Init_LinkList();

    //创建数据
    Person p1 = { "aaa", 18, 100};
    Person p2 = { "bbb", 19, 99 };
    Person p3 = { "ccc", 20, 101 };
    Person p4 = { "ddd", 17, 97 };
    Person p5 = { "eee", 16, 59 };

    //数据插入链表
    Insert_LinkList(list, 0, &p1);
    Insert_LinkList(list, 0, &p2);
    Insert_LinkList(list, 0, &p3);
    Insert_LinkList(list, 0, &p4);
    Insert_LinkList(list, 0, &p5);

    //打印
    Print_LinkList(list, MyPrint);

    //删除3
    RemoveByPos_LinkList(list, 3);

    //打印
    printf("---------------\n");
    Print_LinkList(list, MyPrint);

    //返回第一个结点
    printf("-----查找结果------------\n");
    Person* ret = (Person*)Front_LinkList(list);
    printf("Name:%s Age:%d Score:%d\n", ret->name, ret->age, ret->score);

    //销毁链表
    FreeSpace_LinkList(list);

    return 0;
}
```

### 更好用的现代链表

上一种实现的缺点：
1. 每个节点（一个 struct）访问 next 的时候（`pCurrent->next`），都要做指针偏移
2. 链表很多算法都要频繁做 next，这就有大量的偏移操作（？？？为什么不把next放到第一个个字段）
3. 如果节点拥有的数据类型是有变化的，这个偏移量也是有变化的（？？？导致什么问题呢）


LinkList.h
```c
#ifndef LINKLIST_H
#define LINKLIST_H

#include<stdlib.h>
#include<stdio.h>

//链表小结点
typedef struct LINKNODE{
    struct LINKNODE* next;
}LinkNode;

//链表结点
typedef struct LINKLIST{
    LinkNode head;
    int size;
}LinkList;

//遍历函数指针
typedef void(*PRINTNODE)(LinkNode*);
//比较函数指针
typedef int(*COMPARENODE)(LinkNode*, LinkNode*);

//初始化链表
LinkList* Init_LinkList();
//插入
void Insert_LinkList(LinkList* list, int pos, LinkNode* data);
//删除
void Remove_LinkList(LinkList* list, int pos);
//查找
int Find_LinkList(LinkList* list, LinkNode* data, COMPARENODE compare);
//返回链表大小
int Size_LinkList(LinkList* list);
//打印
void Print_LinkList(LinkList* list, PRINTNODE print);
//释放链表内存
void FreeSpace_LinkList(LinkList* list);


#endif
```


LinkList.c

```c
#include"LinkList.h"

//初始化链表
LinkList* Init_LinkList(){

    LinkList* list = (LinkList*)malloc(sizeof(LinkList));
    list->head.next = NULL;
    list->size = 0;
    return list;
}
//插入
void Insert_LinkList(LinkList* list, int pos, LinkNode* data){

    if (list == NULL){
        return;
    }

    if (data == NULL){
        return;
    }

    if (pos < 0 || pos > list->size){
        pos = list->size;
    }

    //查找插入位置
    LinkNode* pCurrent = &(list->head);
    for (int i = 0; i < pos;i++){
        pCurrent = pCurrent->next;
    }

    //插入新节点
    data->next = pCurrent->next;
    pCurrent->next = data;

    list->size++;
}
//删除
void Remove_LinkList(LinkList* list, int pos){

    if (list == NULL){
        return;
    }

    if (pos < 0 || pos >= list->size){
        return;
    }

    //辅助指针变量
    LinkNode* pCurrent = &(list->head);
    for (int i = 0; i < pos;i++){
        pCurrent = pCurrent->next;
    }

    //删除结点
    pCurrent->next = pCurrent->next->next;

    list->size--;
}
//查找
int Find_LinkList(LinkList* list, LinkNode* data, COMPARENODE compare){

    if (list == NULL){
        return -1;
    }

    if (data == NULL){
        return -1;
    }

    //赋值指针变量
    LinkNode* pCurrent = list->head.next;
    int index = 0;
    int flag = -1;
    while (pCurrent != NULL	){
        if (compare(pCurrent, data) == 0){
            flag = index;
            break;
        }
        pCurrent = pCurrent->next;
        index++;
    }

    return flag;
}
//返回链表大小
int Size_LinkList(LinkList* list){
    return 0;
}
//打印
void Print_LinkList(LinkList* list, PRINTNODE print){

    if (list == NULL){
        return;
    }

    //辅助指针
    LinkNode* pCurrent = list->head.next;
    while (pCurrent != NULL){
        print(pCurrent);
        pCurrent = pCurrent->next;
    }


}
//释放链表内存
void FreeSpace_LinkList(LinkList* list){

    if (list == NULL){
        return;
    }

    free(list);
}
```


测试

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "LinkList.h"

typedef struct PERSON{
    LinkNode node;
    char name[64];
    int age;
}Person;

void MyPrint(LinkNode* data){
    Person*  p = (Person*)data;
    printf("Name:%s Age:%d\n",p->name,p->age);
}

int MyCompare(LinkNode* node1, LinkNode* node2){
    Person* p1 = (Person*)node1;
    Person* p2 = (Person*)node2;

    if (strcmp(p1->name,p2->name) == 0 && p1->age == p2->age){
        return 0;
    }
    return -1;
}

int main(void){

    //创建链表
    LinkList* list = Init_LinkList();

    //创建数据
    Person p1, p2, p3, p4, p5;
    strcpy(p1.name, "aaa");
    strcpy(p2.name, "bbb");
    strcpy(p3.name, "ccc");
    strcpy(p4.name, "ddd");
    strcpy(p5.name, "eee");

    p1.age = 10;
    p2.age = 20;
    p3.age = 30;
    p4.age = 40;
    p5.age = 50;

    //将结点插入链表
    Insert_LinkList(list, 0, (LinkNode*)&p1);
    Insert_LinkList(list, 0, (LinkNode*)&p2);
    Insert_LinkList(list, 0, (LinkNode*)&p3);
    Insert_LinkList(list, 0, (LinkNode*)&p4);
    Insert_LinkList(list, 0, (LinkNode*)&p5);

    //打印
    Print_LinkList(list, MyPrint);

    //删除结点
    Remove_LinkList(list, 2);

    //打印
    printf("---------------\n");
    Print_LinkList(list, MyPrint);

    //查找
    Person findP;
    strcpy(findP.name, "bbb");
    findP.age = 20;
    int pos = Find_LinkList(list, (LinkNode*)&findP, MyCompare);
    printf("位置:%d\n",pos);

    //释放链表内存
    FreeSpace_LinkList(list);


    system("pause");
    return 0;
}
```
