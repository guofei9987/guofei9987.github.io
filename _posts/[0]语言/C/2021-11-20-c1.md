---
layout: post
title: 【C1】基本数据类型、流程控制
categories: 语言
tags:
keywords:
description:
order: 12001
---

## 基础

gcc
```bash
gcc -o main main.c
# 然后执行 main 文件
./main

# (或者)编译+链接
gcc -o main.o main.c -c
gcc -o main main.o
```

include
```c
#include <stdio.h> // 表示文件在系统目录下
#include "a.h" // 表示文件在当前目录下
```

知识
- main函数是执行的起点，有且只能有1个
- printf 是向标准设备输出，未必是向屏幕输出，例如 `./main > save.txt`
- 建议用 `int main`，而不是 `void main`，后者不支持c++
- 约定 `return 0;` 代表执行成功，`return -1` 代表执行失败
- 预编译：把 include 替换进来，删除注释，等操作。`gcc -o  main1.c main.c -E`
- 汇编 `gcc -o main.s main.c -S`



## 基本数据结构


```C
// 基本数据类型
void
char
int
float
double

// 修饰符
short // 短整形
long // 长整形
signed // 有符号
unsigned // 无符号
```

一个二进制位是一个bit，8 bit=1 Byte

c 本身不规定变量类型的范围，跟系统有关，我的 MacBook 如下：


<table>
<thead>
  <tr>
    <th>修饰符</th>
    <th>数据类型</th>
    <th>占用（字节）</th>
    <th>取值范围</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td rowspan="3">signed</td>
    <td>short int</td>
    <td>2</td>
    <td>-32768 到 32767 (-2^15 ~ 2^15-1)</td>
  </tr>
  <tr>
    <td>int</td>
    <td>4</td>
    <td>-2147483648 到 2147483647 (-2^31 ~ 2^31-1)</td>
  </tr>
  <tr>
    <td>long int<br>long long int</td>
    <td>8</td>
    <td></td>
  </tr>
  <tr>
    <td rowspan="3">unsigned</td>
    <td>short int</td>
    <td>2</td>
    <td>0 到 65535 (0 ~ 2^16-1)</td>
  </tr>
  <tr>
    <td>int</td>
    <td>4</td>
    <td>0 到 4294967295   (0 ~ 2^32-1)</td>
  </tr>
  <tr>
    <td>long int</td>
    <td>8</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td>float</td>
    <td>4</td>
    <td>1.4E-45 ~ 3.4E+38，-1.4E-45 ~ -3.4E+38</td>
  </tr>
  <tr>
    <td></td>
    <td>duble</td>
    <td>8</td>
    <td>4.9E-324 ~ 1.7E+308, -4.9E-324 ~ -1.7E+308</td>
  </tr>
  <tr>
    <td></td>
    <td>char</td>
    <td>1</td>
    <td>-128~127</td>
  </tr>
  <tr>
    <td></td>
    <td>unsigned char</td>
    <td>1</td>
    <td>0~255</td>
  </tr>
</tbody>
</table>


```c
#include <stdio.h>
#include <float.h>

int main() {
  printf("int 存储大小 : %lu \n", sizeof(int));
  printf("a 存储大小 : %lu \n", sizeof(a));
  printf("float 存储最节数 : %lu \n", sizeof(float));
  printf("float 最小值: %E\n", FLT_MIN);
  printf("float 最大值: %E\n", FLT_MAX);
  printf("精度值: %d\n", FLT_DIG);

    return 0;
}
```


编码
- 原码：最高位0代表正，1代表负
- 反码：如果是正数，反码和原码相同。如果是负数，符号位为1，其它各位与原码相反
- 补码：正数与原码相同。负数：反码加一
  - 好处：相加不用再考虑正负
  - 负数补码转原码：符号位不动，其它求反，得到的数加一
  - 内存中以补码的形式存储


进制

```c
int a;
// 以 n 进制赋值
a = 10; // 默认十进制
a = 010; //0开头为8进制
a = 0b101; // 0b 开头为 2 进制
a = 0x2f;//    0x开头为16进制

// 以 n 进制显示
printf("十进制 = %d，八进制 = %o, "
       "十六进制小写 = %x , 16进制大写 = %X, "
       "十进制无符号 %u", a, a, a, a, a);


char c = 0x41;
printf("size = %lu, value= %c", sizeof(c), c);




```



小数

```c
float f = 123.4f;
double d1 = 100.1; // C语言默认都是 double


char ch = 'A';
printf("字符：%c，对应的ascii：%d\n", ch, ch);

```

类型转换
```c
int x = 1;
double y;
y = (double) x;
```

字符串

```c

// char 的 \b 是退格符号，例如：
printf("hello word");
char b='\b';
printf("%c%c",b,b);
// 输出 hello wo


// 字符串 s/S char/wchar
printf("%s\n", "hello");


// p 16进制指针
int a = 1;
printf("%p\n", &a);

// 输出一个百分号
printf("%%", );

// printf 还有对其之类的操作，就不多写了
```



常量：不可被修改
```c
// 宏常量，规范：用大写
#define MAX 100;

// const 常量
const int a = 0;
// c用宏常量多，C++用const多

"字符串常量"
20 // 整数常量
```

volatile，不让编译器自动做优化，例如：
```c
int a =1;
a = a+1;
a = a+2;
// 以上代码会被编译器自动优化为： a = a+3

volatile int a = 1
// 编译器不会再自动做优化，

```

register:提升效率
```c
register int a = 0; // 这个变量直接放在寄存器中，而不是内存中
a = a + 1;
// 对应汇编
move eax, 0
add eax, 1

// 普通的：
int a = 0;
a = a + 1;
// 对应汇编
move b, 0
move eax, b
add eax, 1
move b, eax
```
知识：
- register 是建议型指令，而不是命令型的。如果寄存器不够用，register 可能不生效




## 复杂类型
```C
struct // 结构体
union // 共用体
enum // 枚举

typedef // 声明类型别名
sizeof // 得到类型大小，32位系统返回 unsigned int，64位系统返回 unsigned long
```


```c
#include <stdio.h>

enum month {
    JAN = 1, FEB = 2, MAR = 3, APR = 4, MAY = 5, JUN = 6,
    JUL = 7, AUG = 8, SEP = 9, OCT = 10, NOV = 11, DEC = 12
};

int main() {
    enum month lastmonth, thismonth, nextmonth;
    lastmonth = APR;
    thismonth = MAY;
    nextmonth = JUN;
    printf("%d %d %d \n", lastmonth, thismonth, nextmonth);
    return 0;
}
```

小知识：
- 如果不定义值，第0个默认为0，后面的是前面的加1
```c
enum month {
    JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC
};
```

## 运算符

```txt
+-*/ 加减乘除
% 取模
i++ , i--  自加/自减

=，+=，-=，*=，/=，%= 赋值

int x, y, z;
x = y = z = 5; //为三个变量同时赋值
// 原理是 (z = 5) 除了赋值外还会返回5
// 所以 if(z=5) 不会报错，如果本意是 if(z == 5)，会有问题

```

### 逻辑运算符

C语言没有bool类型，使用 0 代表假，非 0 代表真

```c
// 比较运算符，返回0或1
==，!=，<，>，<=，>=

// 与或非
&&，||，!

// 三目运算符
max = x > y ? x : y;
```

小知识：
- 逻辑运算符不会做额外运算，例如：x>3||x/0 不会报错，因为第二部分就不会运算


### 位运算符
```
& 按位与
| 按位或
~ 按位反
^ 按异或

<< 移位
>> 移位
```


## 存储相关

```C
auto
static
register
extern
const
volatile
```

## 流程相关
```C
continue
break
goto
```


### 选择语句

if语句
```C
// 第一种
if (/* condition */) {
  /* code */
} else if (/* condition */) {
  /* code */
} else {
  /* code */
}
// 1. else if 和 else 都可以省略
// 2. if(z=5) 不会报错，如果本意是 if(z == 5)，会有问题
// 3. if(a==b); 多一个分号也不会报错，只不过会直接结束if，后面的代码不在 if 范围中了。

// 第二种

if (/* condition */) {
  /* code */
}



// 第三种

if (/* condition */) {
  /* code */
} else {
  /* code */
}

// 第四种

if (/* condition */) {
  /* code */
} else if (/* condition */) {
  /* code */
}
```

switch
```C
int a;
printf("input a=");
scanf("%d", &a);

switch (a) {
    case 0:
        printf("input 0");
        break;
    case 1:
        printf(" and 1");
        break;
    case 2:
        printf("other");
        break;
    default:
        printf("not known!");
}
// 1. break 必须带，不然的话，匹配成功一个，下面的每个 case 都会执行（不知道为啥要这样设计）
```

### 循环结构

```C
for (size_t i = 0; i < count; i++) {
  /* code */
}


do {
  /* code */
} while(/* condition */);


while (/* condition */) {
  /* code */
}
```


goto：不要用
```C
goto label1;
printf("hello");
label1:
printf("world");
```


关键词：
```C
continue; // 直接执行下一个循环
break; // 跳出循环
```

## 数组

```c
int a[10] // 定义了一个数组，其长度为10
// 1. 数组的元素类型必须都一样
// 2. 数组名本身是数组第一个元素的地址对应的常量
printf("%p == %p", a, &a[0]); // 两个都是在内存中的开头位置


// 初始化
int a[3] = {1, 2, 3};
int a[3] = {1, 2}; // 没定义的，默认为0
int a[] = {1, 2, 3}; // 如果不指定长度，自动计算和指定长度

// 3. 语法上，index 可以溢出，例如
a[100] = 999;
a[101];

// 4. 如何得到数组的长度？ sizeof(a)/sizeof(a[0])
// 所以这样遍历数组
for (int i = 0; i < sizeof(a) / sizeof(a[0]); i++) {
    printf("%d\n", a[i]);
}
```


### 二维数组

```c
int a[2][5]; // 定义了一个二维数组，a[0],a[1] 是两个1维数组名
printf("%p = %p = %p", a, a[0], &a[0][0]); // 同一维数组，存放的也是内存地址

// 初始化
int a[2][5] = { {1, 2, 3, 4, 5},
               {3, 4, 5, 6, 7} };

// 省略的自动补0
int a[2][5] = { {1, 2, 3, 4, 5},
              {3} };

// 可以省略第一个大小
int a[][5] = { {1, 2, 3, 4, 5},
               {3} };
```

多维数组
```c
int a[2][3][5]; // 定义了一个三维数组，其 a[0], a[1] 分别代表2个二维数组
```

### 字符数组




```c
char a[2];
a[0] = 'a';
a[1] = '\0'; // 它的 ascii 码就是 0，所以也可以 a[1] = 0;

char a1[10] = "abc"; // 这其实是初始化一个字符数组。不能用赋值 a="abc" 是错的
char a2[] = "abc"; // 会多一位 \0，这个例子实际上长度为 4
```
字符数组和字符串的区别：
- 字符串是一种连特殊的 `char []`，它必须以0结尾
- `char[]` 如果中间某个值为0，字符串就到此截断，但整体仍然是个数组
```c
char a[] = "hello, world";
a[3] = 0;
printf("%s", a); // 打印 hel
```
- 如果一个 char[] 没有以0结尾，它就不是个字符串，printf会出乱码

字符串数组和指针
```c
char a[100] = "hello world";
char *s = "hello world"; // 这个是先定义一个 字符串常量，然后用指针指向它的首地址。所以是只读。

```



例题：如何合并两个字符串？
```c
char a[100] = {0};
char b[100] = {0};
char c[200] = {0};

scanf("%s", a); // 这里不是 &a
scanf("%s", b); // 如果用户的输出超过100个，会有溢出

int idx1, idx2;
idx1 = idx2 = 0;
while (a[idx1]) {
    c[idx1] = a[idx1];
    idx1++;
}
while (b[idx2]) {
    c[idx1] = b[idx2];
    idx1++;
    idx2++;
}

printf("%s", c);
```

### 字符串方法

scanf 有一些问题：
1. 认为空格和回车都是结束
2. 如果 `char [10] a`，然后 scanf 输入长度为3的字符串，会添加0之后赋值给前几个元素，后面的元素保持不变。
3. 如果用户输入超过 a 的长度，会溢出


```c
putchar('a') \\ 一次输出一个字符
printf("hello") \\ 不多说

getchar() \\ 返回 int，是你输入的字符对应的 ascii 码

// scanf：
int a;
scanf("%d", &a); // 第二个变量是变量的地址
printf("%d\n",a);
```


- gets 和 puts 底层是由 putchar/getchar 实现的




```c

char a[10];
gets(a);
// 1. 用户输出超长后会报错
// 2. 空格不代表结束，回车代表结束
// 3. 仍然有溢出危险

fgets(a, sizeof(a), stdin);
// 1. 用户超长后不报错，而是截断
// 2. 回车和空格都会放进去
// 3. 没有溢出危险



puts(a); // 跟 printf 功能差不多，自动加一个 \n，所以和 gets 连用会出现两次 \n
fputs(a, stdout);
// 1. 不会自作主张加 \n



```

string.h

```c
#include<string.h>

// 字符串长度：strlen
unsigned long len = strlen(a);
// 1. 这个长度不包括末尾的 0
// 2. 1个汉字算3个
// 3. 到第一个0为止，既是数组后面还有内容


// 字符串合并：strcat，strncat
strcat(a, b); // 把 a 和 b 合并，并且放到 a
// a 必须有足够的空间，否则报错
strncat(a, b, 3); // 最多追加 b 的前 3 个字符

// 字符串拷贝：strcpy，strncpy
strcpy(a, b); // 把 b copy 到 a 中
// 如果超过 a 的大小，不会报错，而是会继续写入后续的内存（或许会导致错误）
strncpy(a, b, sizeof(a) - 1);
// 最多只复制 sizeof(a) - 1 个，可以防止溢出




// 字符串比较：strcmp，strncmp
int is_unequal = strcmp(a, b);
// 如果不同，返回非0。如果相同，返回0
int is_unequal = strncmp(a, b, 2);
// 比价前2个字符串
// a == b 是不对的，因为这个比较的是内存


// 字符串格式化：sprintf
char a[100];
sprintf(a, "%d: Hello, %s, welcome.", 1, "Tom");
// 把格式化后的字符串，放入a
// 可以这么理解：printf 是输出到标准输出设备，sprintf 是输出到字符数组
// 额外一个小应用：int 转 char[]

// 从指定格式中的字符中提取：sscanf
char a[] = "12+21";
int i, j;
sscanf(a, "%d+%d", &i, &j);
// 额外一个小应用：char[] 转 int（其实也能转 double）
// 也可以 char c;sscanf(a, "%d%c%d", &i, &c, &j);

// 字符串中提取数字
char a[100] = "105hellohello";
char *stopstring;
long int i = strtol(a, &stopstring, 6);
// 1. 以 6 进制提取
// 2. stopstring 是提取后的剩余部分
// 3. 类似的有这些：strtof, strtol, strtold, strtold, strtoll 等
// 4. 类似的还有 atoi, atof 等
// 5. 没有反过来转化的内置函数，可以用 sprintf 实现
```

字符串查找
```c
char a[] = "hello world!";
char *s; //定一个一个 char类型指针变量
s = strchr(a, 'w');
// 1. s 也是一个 char[]
// 2. printf("%s", s); 输出 world!，也就是遇到 \0 才结束
// 3. 如果找不到，返回 null，用 s==NULL 做判断

s = strstr(a, "wor"); // 功能相似，入参可以是字符串
```

字符串分割

```c
// 字符串分割：strtok
char a[100] = "abc_efg_123_666666";
char *s;

s = strtok(a, "_"); // 返回 abc
printf("%s\n", s);

s = strtok(NULL, "_");// 继续查找，返回 efg。如果查完了，返回null
printf("%s\n", s);

// 一般这么用
char a[100] = "abc_efg_123_666666";
char *s;

s = strtok(a, "_");
while (s) {
    printf("%s\n", s);
    s = strtok(NULL, "_");
}
```


char的一些有关技巧

```c
// 小写转大写的技巧
char a = 'a';
if (a >= 'a' && a <= 'z') { // 1. char 可以当成 int 用
    a -= ' '; // 2. 减空格就代表着转大写（ascii设计不错）
}

// 同样原理，可以字符转数字
int a = '1';
if (a >= '0' && a <= '9') {
    a -= '0';
}

```

## 函数

1. 使用前必须先定义或声明。可以先声明，然后在底下定义。
2. 任何位置执行 `exit(0)` 会让整个程序中止
3. 字符数组作入参是这样的 `int my_func(char *a)`

多文件编译
```c
// my_utils.c:
int my_add(int a, int b) {
    return a + b;
}

// main.c:
#include<stdio.h>

int my_add(int a, int b);

int main() {
    int a = 1;
    int b = 2;
    int c = my_add(a, b);
    printf("%d\n", c);
    return 0;
}

// 编译：
// gcc -o my_package main.c my_utils.c
// 执行：
// ./my_package
```


往往这么做
```c
// my_utils.h
int my_add(int a, int b) {
    return a + b;
}

// main.c
#include<stdio.h>
#include "my_utils.h"

int main() {
    int a = 1;
    int b = 2;
    int c = my_add(a, b);
    printf("%d\n", c);
    return 0;
}

// gcc -o my_package main.c
// ./my_package
```

另外，好像还有个规范：.h 文件只声明函数，函数定义放到 my_utils.c



宏

```c
#include<stdio.h>

#define TEST// 定义了一个宏

int main() {
#ifdef TEST // 如果定义了 TEST，就编译这里面的，否则不编译
    printf("dev");
#endif

#ifndef TEST
    printf("prod") // 如果没定义就不编译，定义了就编译
#endif

    return 0;
}
```

宏的应用，在一个头文件中，一般这么做，以防重复 include 时，被重复声明（类似单例模式）
```c
#ifndef _MY_UTILS
#define _MY_UTILS

int my_add(int a,int b){
return a + b;
}

#endif
```

还有一个规范：`.h` 文件一般只放函数的声明，`.c` 文件放函数的定义

一个错误的使用：
```c
#include <stdio.h>

int func1();

int main() {
    func1(); // 这里编译器不会提示错误，但会产生一个随机的值
    return 0;
}

int func1(int a){
    printf("%d",a);
    return 0;
}
```


对于真的无入参函数，规范：使用 `int func1(void);`，C++ 没有这个问题。


## 指针

- 指针是一种数据类型，它指向内存
- 每个地址对应一个 Byte，
- 地址编号本身是 8 个字节（64位系统）or 4个字节（32位系统）的 无符号整数

```c
int *p;
// 1. 指针变量是 p
// 2. void *p 可以指向任何类型

int a;
p = &a; // 把 a 的内存赋值给 p
// 或者 int *p = &a;
a = 1;
printf("%p\n",p); // 打印内存编号

*p = 10; // 给指针指向的位置赋值，*p 就代表a

// 1.
```
1. `register int a;` 定义的变量是无法用 & 取地址的，因为它一直在寄存器中。
2. 保证类型一致


空指针和野指针

```c
// 野指针
int *p ;
*p = 100;
// 没有指向哪个变量，编译器不报错，但规范不允许

// 空指针
int *p = NULL;
// 空指针是允许的
// NULL 其实是0
```


指向常量的指针，指针常量
```c
// 指针常量
int a = 0;
const int *p = &a; // p 是一个变量，但指向一个常量
// 可以通过 *p 读取，但不能通过 *p 写。可以通过 a 写。
// *p = 1; // 这个是不允许的
// a = 1; // 这个是允许的
// 可以这么理解把，获取了 a 的只读权限


// 常量指针
int *const p = &a;
// 这个 p 是常量指针，不能再指向其它变量，例如 *p = &a2 是错的


// 错误用法
const int a = 100;
int *p = &a;
*p = 1;
printf("%d != %d\n", a, *p); // 不相同，好像和编译器有关，不知道为啥
printf("%p == %p", p, &a); // 相同
// 上面这个用法是不符合规范的。
```

指针和数组

```c
int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *p = a; // 数组存入的就是内存地址，因此不需要 *p = &a;
int *p = &a[1]; // 也可以

p[3] = 100; // 可以直接当数组名用
printf("%ld != %ld ", sizeof(a), sizeof(p)); //但又不完全一样
```


```c
int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *p = &a[1];

p[3] = 100; // 其实是 a[4]
```

指针运算
```c
p + 1; // 指向下一个 “数据单元”，而不是16进制地址加1
p - 1;
// 实际移动多少 16 进制大小呢？取决于定义指针时的指定类型。例如 int 是 4，double 是 8
// 如果指针类型和变量类型不一致（虽然不符合规范），以指针类型为准


// 同样，也可以有这个：
p += 5;
p -= 3;
p++;
p--;

*(p + 3) = 100;
p[3] = 100; // 等价写法，即使不是数组，也能这么写，位移3个单位
```


有趣的例子1
```c
int a = 0x12345678;
char *p = &a; // 也可以 char *p = (char *) &a;

printf("%x\n", *p);
printf("%x\n", *(p + 1));
printf("%x\n", *(p + 2));
printf("%x\n", p[3]);
// 返回：
// 78
// 56
// 34
// 12
// 1. 颠倒过来是因为整数是“正向对其”的
// 2. 也可以写入
```

有趣的例子2:ip 其实对应一个 int
```c
unsigned int a = 987654321;
unsigned char *p = (unsigned char *)&a;
for(int i=3;i>=0;i--){
    printf("%u.",p[i]);
}
```
思考： ip 如何转回为 int
```c
unsigned char a[4] = {58, 222, 104, 177};
unsigned char tmp[4];
for (int i = 0; i < 4; i++) {
    tmp[i] = a[3 - i];
}
unsigned int *p = &tmp;
printf("%d",*p);
```


### 指针数组
```c
int *p[5]; // 5个指针组成的数组（叫做指针数组）
p[2]; // 这是一个指针
*p[2]; // 这是那个指针指向的值

// 你需要先把指针的指向赋值好，才能用这个指针
int a = 2;
p[3] = &a;
*p[3] = 5;
```

### 二级指针

指的是指向指针的指针

```c
int a = 0;
int *p = &a;
int **pp;//二级指针，指向指针的指针
pp = &p;
// 或者 int **p = &p;


**pp = 10; // 通过二级指针访问 a
```

如果想用一个指针指向指针数组，必须用一个二级指针指向它
```c
int value = 10;
int *arr[10];//一个指针数组
arr[2] = &value;//指针数组的第2个，指向一个 int

int **p = arr; //指向指针数组的指针，必须用二级指针

p[2]; // 其实是 arr[2] ，存放的是一个指针
*p[2] = 5; // 那么，这个指针其实指向 value
```

类似的，还有多级指针

### 指针的应用

如果想用函数改变某个变量的值，必须通过指针
```c
int swap(int *a, int *b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
    return 0;
}


int main() {
    int a = 1;
    int b = 2;
    swap(&a, &b);
    printf("%d%d", a, b);
    return 0;
}
```

当一个数组名作为入参时，自动作为指针变量。
```c
int tst(int a[10]);
int tst(int a[]);
int tst(int *a);
// 以上三个是等价的
// 编译的时候，3个都会编译成最后一个
// 规范：通常使用最后一个


int tst(const int *a); // 这样，函数内部就无法修改数组 a 了
// 其实做个强转后，还是能改的 int *p = (int *)a; p[5] = 999;
// C++ 没这漏洞了
// 一般约定，函数只要不改数组，都加 const

// 如果数组作为入参，数组的大小在函数中是不可见的
int tst(const int *a) {
    printf("%lu\n", sizeof(a)); // 是指针的size，必然为 8
    return 0;
}
// 因此，往往需要额外传入一个数组长度。不过字符串不需要，因为字符串是 0 结尾的

```

一个函数也可以返回一个指针

```c
int *tst(); // 函数返回指针
```

### main函数的参数

```c
int main(int argc, char **args) {
    for (int i = 0; i < argc; i++) {
        printf("%s, ", args[i]);
    }
    printf("\n");
    return 0;
}

// 如何使用？
// 编译后：./main -l -s 0
// 打印：./main, -l, -s, 0,
// !注意，在linux下，* 指的是通配符，被目录下的全部文件替换
// 要想传入星号，要传入 \*
```


### 标准库-内存操作

string.h


memset：内存置空
```c
int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
memset(a, 0, sizeof(a));
// 入参：置空的区域的首地址，0，这块内存大小（单位 Byte）
```

memcopy：内存拷贝。要确保没有内存重叠区域
```c
int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int b[10] = {0};
memcpy(b, a, sizeof(a));
// 入参：目标地址，源地址，拷贝的大小（单位 Byte）
```

## 标准库






### 随机数
```c
#include<time.h>
#include<stdlib.h>

srand(100); // 指定种子
int a = rand(); // 如果不定义种子，不会随机定种子

// 如何得到真随机：
int t=(int) time(NULL);
srand(t);
int a = rand();

// 如何得到0-100的随机数？
rand() % 101;
```


### system
```c
#include <stdlib.h>

int main()
{
    system("ls -l"); // 运行成功返回0
    return 0;
}
```

system 返回什么？
- 被调用者的返回
- 如果调用 linux 命令，成功返回0
- 如果调用其它编译好的 another.c，返回 another.c#main 函数的 return （？？？并不是）
