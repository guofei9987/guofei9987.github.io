---
layout: post
title: 【C】一些特性
categories: 语言
tags:
keywords:
description:
order: 10010
---



## 关于变量类型

```c
for (int i = 0; i < 10; i++) {
    static int a = 10;
    a++;
    printf("%d\n", a);
}
// >11, 12, 13, 14, 15, 16, 17, 18, 19, 20,

for (int i = 0; i < 10; i++) {
    int a = 10;
    a++;
    printf("%d\n", a);
}
// >11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
```

这是因为， static 只会初始化1次，无论它在哪


## 关于指针

### 二级指针避免内存泄露
错误的代码
```c
void tst(char *i) {
    i = malloc(100); // 这个 i 运行完毕后被清空了
}

int main() {
    char *p = NULL;
    tst(p);
    strcpy(p, "hello"); // 这个 p 仍然为0
    free(p); // 释放不是 malloc 分配的内存
    return 0;
}
```

正确的代码：用二级指针
```c
void tst(char **i) {
    *i = malloc(100);
}

int main() {
    char *p = NULL;
    tst(&p);
    strcpy(p, "hello");
    free(p);
    return 0;
}
```


## 零碎知识

```c
char a = '\72'; // 表示 8 进制的ascii码
char s[5] = {"abc"};  // 也是合法的
int *a, b; // a 是个指针，b是int类型

```


```c
int (*p)[5]; // 指针指向一个长度为5的整形数组
int *p[5]; // 定义一个长度为5的数组，数组的元素都是指针
```

函数的传参是如何进行的？
- `int sum(int x,int y);`，调用时，x和y以堆栈的形式复制了一份，当函数运行完毕后，复制的这一份数据自动释放。

如何防止频繁申请内存？
- 如果程序中有很多次 `malloc(8)`。那么可以事先 `malloc(1024*16)`，然后立即释放掉。这样可以避免频繁向系统要内存。


## 进阶

数组名不是指针

```c
int arr[] = {1, 2, 3, 4, 5}; // arr 是数组名
int *p = (int *) &arr; // p 是指针

printf("%ld != %ld\n", sizeof(arr), sizeof(p));
//   1.  一个是数组的大小，为4*5；一个是指针的大小，为8

// 2. +1后的指向不同
printf("%p,%p\n", p, p + 1);// +1移动一个int
printf("%p,%p", &arr, &arr + 1); // +1移动5*int

//    3. 数组名是指针常量，不可更改
//    arr = NULL; //错的

```


指针作为入参
```c
int func(int arr[]){ // 等价于 int *arr

}
```

typedef


## 指针的一些梳理

1. 指针常量、指向常量的指针，已经梳理好

## 零碎

```c
int a[10]
// ？实际上是定义了一个指针？指向数组的开头

取数 a[3]
实际上是  *(a+3)
```


## 指针

```c


// 方法1
char a[10] = "hello";
// 上面等价于：
char a[10] = {'h', 'e', 'l', 'l', 'o', 0};
// 上面是初始化一个字符数组
char *b = "hello";
// 上面是初始化一个字符串常量

// 方法2
char a1[10];
char *a2;

// 1. sizeof(a) 结果不一样
// 2. 初始化方式不一样
// a1 = "hello" 是错的
a2 = "hello"; // 直接就可以赋值，

// 必须用这个：
strcpy(a1, "world");
// 但你不能对指针 a2 用 strcpy，memset 之类的，但是：
// 1. 第二个变量可以是指针，表示copy的是指针指向的内容
// 2. 如果用 malloc 分配内存，就可以给指针赋值:
char *a2;
p = malloc(10);
strcpy(p, "hello");
free(p)
```


```c
// 下面这个函数，多次调用同一个，也不会有错误
// 因为1）传入的参数都是拷贝，这里是指针的拷贝，因此对指针做自增只作用于函数内。但它指向的内存却可以去修改
// 2）也没有对指针指向的内存做改动
int strlen(char *string) {
    int length = 0;
    while (*string++ != 0) {
        length += 1;
    }
    return length;
}
```

char *s = "hello" 定义之后，不能改动元素，但 int */char a[] 都是可以改的。  
是不是这样解释： char *s = "hello" 是指向的字符串常量，因此不能改动
```c
char *s = "hello";
s[1] = 'c'; // 报错


```

### 指针和向量的区别

```c
// 这两个不一样
int a[5]; // 内存中创造一个空间，然后创建一个数组名，它的值是一个常量，指向这段空间
int *b; // 仅仅是创建一个指针本身的内存空间，并没有分配 int 内存空间

// *a 合法，但 *b 不合法，因为访问了一个不存在的位置。

```

### 指针加法
```c
int arr1[10];

printf("%p = %p= %p\n", arr1, &arr1, &arr1[0]);
printf("%p = %p\n", arr1 + 1, &arr1[1]); // 指向“下一个元素”
printf("%p = %p\n", &arr1 + 1, &arr1[10]); // 指向“下一个模块”


// 对于二维数组，也是一样的
int arr[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
};


printf("%p = %p\n", arr, &arr[0][0]); // 指向第0行第0个元素： &arr[0][0]
printf("%p = %p\n", arr + 1, arr[1]); // 指向第1行第0个元素： &arr[1][0]
printf("%p\n", &arr + 1); //指向下一块：&arr[2][2] + 1
```

问题：
- ` *(*(arr + 1) + 2)` 是什么？是 `arr[1][2]`
- 这是因为 `*(arr + 1) + 2` 
- `arr[1, 2]`不会报错，它实际上是 `arr[2]`，导致结果不符合预期



## 关于溢出

char 在运算中以 int 运算的，例如：

```c
unsigned char a, b;
b = 200;
a = (b * 5) / 5;  // 结果是 200，不会因为超过 255 而溢出，因为它们是以 int 运算的
```

但是，这个会因为溢出而结果错误
```c
unsigned int a = 0xFFFFFFF0;
long b = (a * 2) / 2;
// 要改成这样才能保证结果正确：
long b = ((long) a * 2) / 2;
```

## 一些你不应该写的代码

```c
int a[10]={0,1,2};
int c = 2[a];
// 它相当于 *(2+a)，也就相当于 *(a+2)，也就相当于 a[2];
```
