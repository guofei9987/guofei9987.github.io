---
layout: post
title: 【C】一些特性
categories: 语言
tags:
keywords:
description:
order: 10010
---



## 关于变量类型

```c
for (int i = 0; i < 10; i++) {
    static int a = 10;
    a++;
    printf("%d\n", a);
}
// >11, 12, 13, 14, 15, 16, 17, 18, 19, 20,

for (int i = 0; i < 10; i++) {
    int a = 10;
    a++;
    printf("%d\n", a);
}
// >11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
```

这是因为， static 只会初始化1次，无论它在哪


## 关于指针

### 二级指针避免内存泄露
错误的代码
```c
void tst(char *i) {
    i = malloc(100); // 这个 i 运行完毕后被清空了
}

int main() {
    char *p = NULL;
    tst(p);
    strcpy(p, "hello"); // 这个 p 仍然为0
    free(p); // 释放不是 malloc 分配的内存
    return 0;
}
```

正确的代码：用二级指针
```c
void tst(char **i) {
    *i = malloc(100);
}

int main() {
    char *p = NULL;
    tst(&p);
    strcpy(p, "hello");
    free(p);
    return 0;
}
```


## 零碎知识

```c
char a = '\72'; // 表示 8 进制的ascii码
char s[5] = {"abc"};  // 也是合法的
int *a, b; // a 是个指针，b是int类型

```


```c
int (*p)[5]; // 指针指向一个长度为5的整形数组
int *p[5]; // 定义一个长度为5的数组，数组的元素都是指针
```

函数的传参是如何进行的？
- `int sum(int x,int y);`，调用时，x和y以堆栈的形式复制了一份，当函数运行完毕后，复制的这一份数据自动释放。

如何防止频繁申请内存？
- 如果程序中有很多次 `malloc(8)`。那么可以事先 `malloc(1024*16)`，然后立即释放掉。这样可以避免频繁向系统要内存。


## 进阶

数组名不是指针

```c
int arr[] = {1, 2, 3, 4, 5}; // arr 是数组名
int *p = (int *) &arr; // p 是指针

printf("%ld != %ld\n", sizeof(arr), sizeof(p));
//   1.  一个是数组的大小，为4*5；一个是指针的大小，为8

// 2. +1后的指向不同
printf("%p,%p\n", p, p + 1);// +1移动一个int
printf("%p,%p", &arr, &arr + 1); // +1移动5*int

//    3. 数组名是指针常量，不可更改
//    arr = NULL; //错的

```


指针作为入参
```c
int func(int arr[]){ // 等价于 int *arr

}
```

typedef


## 指针的一些梳理

1. 指针常量、指向常量的指针，已经梳理好

## 零碎

```c
int a[10]
// ？实际上是定义了一个指针？指向数组的开头

取数 a[3]
实际上是  *(a+3)
```


## 指针

```c
char a1[10];
char *a2;

// 1. sizeof(a) 结果不一样
// 2. 初始化方式不一样
a2 = "hello"; // 直接就可以赋值，
// 但是 a1 = "hello" 是错的，无法编译
// 必须用这个：
strcpy(a1, "world");
// 但你不能对指针 a2 用 strcpy，memset 之类的，但是：
// 1. 第二个变量可以是指针，表示copy的是指针指向的内容
// 2. 如果用 malloc 分配内存，就可以给指针赋值:
char *a2;
p = malloc(10);
strcpy(p, "hello");
free(p)
```


```c
// 下面这个函数，多次调用同一个，也不会有错误
// 因为1）只对指针做自增，而这个自增作用域只在函数内
// 2）也没有对指针指向的内存做改动
int strlen(char *string) {
    int length = 0;
    while (*string++ != 0) {
        length += 1;
    }
    return length;
}
```

char *s = "hello" 定义之后，不能改动元素，但 int */char a[] 都是可以改的。  
是不是这样解释： char *s = "hello" 是指向的字符串常量，因此不能改动
```c
char *s = "hello";
s[1] = 'c'; // 报错


```



## 关于溢出

char 在运算中以 int 运算的，例如：

```c
unsigned char a, b;
b = 200;
a = (b * 5) / 5;  // 结果是 200，不会因为超过 255 而溢出，因为它们是以 int 运算的
```

但是，这个会因为溢出而结果错误
```c
unsigned int a = 0xFFFFFFF0;
long b = (a * 2) / 2;
// 要改成这样才能保证结果正确：
long b = ((long) a * 2) / 2;
```
