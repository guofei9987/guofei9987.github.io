---
layout: post
title: 【CS】计算机操作系统
categories:
tags: 0x11_算法平台
keywords:
description:
order: 173
---


## 概述

操作系统的功能
- CPU管理：进程/线程管理。进程/线程状态、控制、同步互斥、通信、调度...
- 存储管理。分配/回收、地址管理、存储保护、内存扩充...
- 文件管理。文件目录、文件操作、磁盘空间、文件存取控制...
- 设备管理。设备驱动、分配回收、缓冲技术...
- 用户接口。系统命令、编程接口...


OS是硬件上的第一层软件
- 例如读取文件：“从某个文件读一个数据块” or “移动磁头，等待放下”
- OS 在应用程序578和硬件之间建立一个“虚拟机”
- 对硬件抽象、提高程序可移植性

OS的特征
- 并发（concurrency），能处理同时的活动。
    - 这些活动之间有依赖关系，需要解决同步等问题。
    - 宏观上看，程序在同步执行。微观上看，程序在CPU上轮流执行
- 共享（sharing），
    - 互斥共享（打印机）/同时共享（磁盘文件）
- 虚拟（virtual）
    - 一个物理实体，映射为若干逻辑实体
    - 提高资源利用率
    - 例如：CPU--进程，存储器--每个进程有独立的虚拟地址空间，显示设备--多窗口/虚拟终端
- 随机。处理不可预测的次序发生的事件
    - 多个进程的运行速度不可预知


### 操作系统的分类

其实还有别的分类，这里只写一种分类。

1. 批处理操作系统。用户把作业交给系统操作员，操作员把作业输入到计算机系统，计算机批量处理。
    - 用户用卫星机把作业放入“输入井”，主机读取“输入井”，处理后把结果放入“输出井”，用户从“输出井”获取处理结果
2. 分时操作系统：CPU分成片段，轮流供每个用户使用，使用户感觉自己在连续使用。
3. 实时操作系统：要求计算机立即响应外部请求，并在严格时间内完成处理，高可靠性。
    - 工业控制、航空、军事
    - 实时通信（信息）处理
    - 硬实时系统：要求必须在规定时间内完成。  
    - 软实时系统：偶尔可以违反时限。例如播放器。
4. 个人计算机操作系统：界面友好、使用方便、应用丰富。
5. 网络操作系统。按网络体系结构协议标准开发的软件。
    - 网络管理、通信、安全、资源共享、各种网络应用
6. 分布式操作系统。是一个统一的操作系统，若干台计算机共同完成任务。
7. 嵌入式操作系统。各种设备，例如汽车、手机、电视机。

### 运行机制

系统调用：操作系统给应用程序的接口
- 允许应用程序执行一些操作/服务（例如文件操作、进程管理、内存分配、设备管理）
- 过程中从用户态切换到内核态（叫做陷入 trap）





## 中断和异常

- 中断由外部设备和时间引起的
- 异常是由正在执行的程序内部产生的错误或特殊情况引起的
- 都对应从 用户态 切换到 内核态度


## 进程/线程

多道程序设计：允许多个程序同时进入内存并运行。目的是提高系统效率。
- 每个程序都有自己的逻辑程序计数器
- 哪个运行，就把哪个放入物理计数器
- 每个程序轮流执行，并发执行


并发环境：
- 单个处理器上的程序，**同时** 处于开始运行但尚未结束的状态
- 并且次序不是事先确定的

**进程**（Process）：有独立功能的程序关于某个数据集合上的一次运行活动
- 又称任务（Task、Job）
- 是对 CPU 的抽象。
- 是把一个 CPU 抽象为 多个虚拟的CPU
- 一单位为分配，如内存、文件
    - **每个都有独立的地址空间**。意味着每个进程的地址空间是逻辑地址，而不是物理地址。
- 操作系统把 CPU 调度给需要的进程


**PCB**（Process Control Block，进程描述符，进程属性）
- 一个专门数据结构，记录进程的各种属性、描述进程的动态变化过程
- 进程与 PCB 是一一对应的
- 所有 PCB 集合叫做 **进程表**
    - 进程表的大小限制了操作系统可以同时开多少个进程
- **PCB 记录了哪些信息？**
    - 进程描述信息
        - 进程标识符 process ID，唯一、整数
        - 进程名，通常基于可执行文件名
        - 用户标识符 user ID
        - 进程组关系
    - 进程控制信息
        - 当前状态
        - 优先级 priority
        - 代码执行入口地址
        - 程序的磁盘地址
        - 运行统计信息（执行时间、页面调度）
        - 进程间同步和通信
        - 进程的队列指针
        - 进程的消息队列指针
    - 进程拥有的资源和使用情况
        - 虚拟地址文件状况
        - 打开文件列表
    - CPU 现场信息。进程不运行状态下保存的信息。
        - 寄存器值（通用机孙琦、PC、状态字PSW、栈指针）
        - 志向进程页表的指针
- 在不同的操作系统下是不一样的。Linux：`task_struct`, Windows：`EPROCESS`,`KPROCESS`,`PEB`


进程状态（基础状态）
- 运行态（Running），占有 CPU，并在 CPU 运行
- 就绪态（Ready），已经具备运行条件，但没有空闲 CPU
- 等待态（Waiting/Blocked、阻塞态、封锁态、睡眠态），等待某个事件而暂时不能运行。例如等待读磁盘。

进程的其他状态
- 创建态（New），已经完成创建的必要工作（PID，PCB），但是尚未同意执行该进程（例如资源有限）
- 终止态（Terminated）。
    - 终止执行
    - 可完成一些数据统计工作（资源使用量等）
    - 资源回收
- 挂起态（suspend）
    - 用于负载调节
    - 进程的内存会被回收，进程印象道磁盘上。
    - 资源足够后会重新激活
 

![进程间的转化](/pictures_for_blog/computer/process.gif)

除此之外，还有类似的七状态模型

Linux 的进程态:

![process_linux](/pictures_for_blog/computer/process_linux.jpg)




**进程队列**。进程状态的改变，实际上是 PCB 从一个队列出列，进入另一个队列的过程
- 例如，就绪态可能有多个队列


### 进程控制

进程控制操作完成进程之间的转换，由 **原语**（primitive） 完成。（原语一种原子操作，不可分割、不可中断）

进程的创建
- 分配一个唯一标识，进程控制块
- 分配地址空间
- 初始化进程控制块
- 设置相应的队列指针。
    - 例如新进程加入到就绪队列链表中。
- unix：`fork`, `exec`。Windows：`CreateProcess`

进程的撤销（结束进程）
- 资源回收：关闭打开的文件、断开网络链接、回收分配的内存
- 撤销进程的 PCB
- unix:`exit`，windows：`TerminateProcess`

进程的阻塞
- 进程自己执行阻塞原语
- unix：`wait`，windows：`WaitForSingleObject`


unix 几个进程控制函数
- `fork()` 复制调用进程来建立新的进程。最基本的进程建立过程。
- `exec()` 用新的程序代码覆盖原来的地址空间，实现进程执行代码的转换
- `wait()` 初级进程同步操作，使一个进程等待另一个进程的结束
- `exit()` 终止一个进程的运行

`fork()` 的实现
- 为子进程分配一个空闲的进程描述符（proc 结构）
- 为子进程分配 pid
- **一次一页的方式复制父进程地址空间**
    - 子进程的代码一般与父进程不同，这一步就造成浪费。Linux 采用 Copy-On-Write 技术来解决
        - 不复制父进程地址空间，而是用一个指针指向它，然后设定为只读。
        - 如果需要写入它，就开辟一个新的空间来写入
- 从父进程继承共享资源（如，打开的文件、当前工作目录）
- 把子进程状态设为就绪，插入到就绪队列
- 对子进程返回标识符 0
- 向父进程返回子进程的 pid

`fork()` 的使用


伪代码：
```
pid = fork(); // 创建一个子进程
if(pid<0){
    fprintf("出错);
    exit(-1);
}
else if(pid == 0){ 
    // 因为子进程会把父进程的一页复制进来
    fprintf("pid = 0 说明正在运行的是子进程");
    exec("xxx") // 调用 exec，用新代码覆盖子进程的地址空间
}
else {
    fprintf("pid>0 ，指的是子进程的 pid，并且正在运行的是父进程");
    wait(NULL); // 父进程等待子进程结束
    exit(0);
}
```

### 进程相关概念

![process_addr](/pictures_for_blog/computer/process_addr.gif)


分类1:
- 系统进程（优先级较高）
- 用户进程

分类2:
- 前台进程。与用户直接交互的，例如鼠标键盘
- 后台进程。打印、防火墙、电子邮件接收等

分类3:
- CPU密集型进程
- IO密集型进程 

进程的层次结构
- unix：进程树。init 为根。父进程结束，子进程也必须结束。
- Windows：地位相同。虽然也是由进程建立另一个进程，但是未必一个结束另一个也结束。


进程与程序：一个程序可以对应多个进程。 


进程有自己的地址空间（逻辑地址，而不是物理地址）

进程映像（IMAGE）
- 由进程地址空间内容、硬件寄存器、进程相关的内核数据结构、内核栈组成
- 相当于一个快照

上下文切换（Context Swith）
- CPU 硬件从一个进程切换到另一个进程的过程
- 进程不运行时，寄存器值保存在 PCB 中；切换到某个进程时，从对应的 PCB 中把值送回寄存器


### 线程

为什么需要多线程？
- 例如一个编辑器，需要同时处理：键盘输入、自动排版、定时保存。
- 一个Web服务器，需要同时接受网页请求、从磁盘检索网页、读入内存、把结果返回给客户端。



其它方案
- 如果使用单个进程，顺序编程，性能低
- 如果使用多进程，就不能使用共享的内存空间了
- 如果使用有限状态机方法（就是用一些编程手段来模拟多进程），例如非阻塞IO，编程会非常复杂

所以需要 **多线程**


多线程的好处2:开销小
- 进程涉及到进程创建、进程撤销、进程通信、进程切换，时间和空间开销大
- 线程开销小：
    - 创建和撤销花费时间少
    - 线程切换花费时间少
    - 线程间通信无须调用内核，同一个进程的线程共享内存和文件


线程的好处3:多个处理器，可以充分发挥优势

线程是什么？
- 进程有两个属性：资源拥有者、CPU调度单位
- 线程只继承一个属性：CPU调度单位。（因此有时候把线程称为 **轻量级进程**）

线程的属性
- 标识符 ID
- 状态、状态转换
- 不运行时需要保存的上下文（例如PC寄存器）
- 线程有自己的栈和栈指针
- 共享所在进程的地址空间和其它资源
- 线程可以创建、撤销另一个线程


### 线程的实现

**用户级线程**
-  **Run-time system** 完成线程的管理工作
- 内核管理还是进程，不知道线程的存在
- 线程切换不需要内核态特权
- 例子：UNIX，遵守 POSIX 规范
- 优点：
    - 线程切换快
    - 调度算法是应用程序特定的
    - 可以运行在任何操作系统上（只需实现线程库）
- 缺点：
    - 内核吧处理器分配给进程。**同一个进程的两个线程不能同时运行在两个处理器上**
    - 大多数系统调用时阻塞的。因此内核阻塞时，进程中所有线程也被阻塞



**核心级线程**
- 内核管理所有的线程
- 内核既维护进程，也维护线程
- 线程的切换需要内核支持
- 以线程为基础进行调用
- 例子：Windows



**混合模型**
- 线程的创建在用户空间完成
- 线程调度在核心态完成
- 例子：Solaris


**协程**：比线程更加轻量级。用户态。资源消耗更小。



| **特性**           | **进程（Process）**                                     | **线程（Thread）**                                   | **协程（Coroutine）**                                |
|--------------------|--------------------------------------------------------|------------------------------------------------------|-----------------------------------------------------|
| **定义**           | 操作系统分配资源和调度的基本单位，拥有独立的内存空间。   | 进程内的执行单元，共享进程的内存和资源。             | 用户态的轻量级线程，通过协作式调度实现并发。         |
| **资源开销**       | 较大，每个进程拥有独立的内存空间和系统资源。           | 中等，每个线程有独立的栈和寄存器，但共享进程资源。     | 极小，共享同一线程的内存空间，栈空间占用少。         |
| **创建与销毁**     | 较慢，需要系统调用，涉及内存和资源分配。               | 较快，用户态和内核态均有开销，但低于进程。           | 非常快，仅在用户态进行，无需系统调用。               |
| **上下文切换开销** | 高，涉及内核态与用户态的切换，保存和恢复大量状态。     | 中等，涉及内核态切换和部分状态保存。                 | 低，仅在用户态切换，保存恢复少量状态。               |
| **并发与并行**     | 支持真正的并行（多核CPU），进程间相互独立。           | 支持真正的并行（多核CPU），线程间共享内存。           | 通常在单线程内实现并发，需结合多线程/多进程实现并行。 |
| **隔离性**         | 高，进程间内存隔离，一个进程崩溃不影响其他进程。       | 中等，线程共享进程内存，一个线程崩溃可能影响整个进程。 | 低，协程共享线程内存，一个协程出错可能影响整个线程。   |
| **通信方式**       | 需要进程间通信（IPC），如管道、消息队列、共享内存等。 | 通过共享内存直接访问数据，通信效率高。               | 通过共享数据直接访问，通信效率极高。                 |
| **同步机制**       | 复杂，需要使用IPC机制进行同步。                       | 复杂，需要使用锁、信号量等同步机制。                 | 简单，通常在单线程内协作运行，无需复杂同步。         |
| **适用场景**       | 高隔离性和稳定性要求的应用，如微服务、独立服务进程。   | 需要高效并行处理和共享数据的应用，如Web服务器、多任务处理。 | 高并发、I/O密集型任务，如网络服务器、爬虫、实时数据处理。 |
| **稳定性**         | 高，一个进程崩溃不会影响其他进程。                     | 中等，一个线程崩溃可能导致整个进程崩溃。             | 低，一个协程出错可能影响整个线程。                   |
| **编程复杂度**     | 较高，需要处理进程创建、IPC、资源管理等。             | 中等，需要处理线程同步、资源共享等问题。             | 低，协程通过顺序代码风格简化并发编程。               |
| **可扩展性**       | 高，通过增加进程数可以扩展系统容量。                   | 中等，受限于线程同步和共享资源管理。                 | 高，通过大量协程实现高并发，但需结合多线程/多进程。   |
| **示例**           | Python的`multiprocessing`模块，Java的多进程架构。     | Python的`threading`模块，Java的多线程编程。          | Python的`asyncio`，Go的Goroutine，Lua的协程。         |


- **计算密集型任务**：
  - **多线程**：适用于支持真正多线程的编程语言（如C++、Java、Go），能够高效利用多核CPU，实现并行计算。
  - **多进程**：适用于存在全局解释器锁（如Python）或需要高隔离性的应用，能够绕过GIL，实现真正的并行。
  - **协程**：不推荐单独使用，因其无法充分利用多核并行计算能力。

- **I/O密集型任务**：
  - **协程**：非常适合高并发、I/O密集型任务，通过高效的任务切换和低开销实现高并发。
  - **多线程和多进程**： 也可用于I/O密集型任务，但协程在资源利用和性能上更具优势。

通过综合考虑任务类型、编程语言特性和系统架构需求，选择最合适的并发模型能够显著提升系统性能和开发效率。

## CPU调度

CPU调度：从就绪队列中选择一个进程，把 CPU 使用权交给它。
- N个进程就绪状态
- M个CPU空闲状态
- 需要决策：给哪个进程分配哪个CPU

需要解决3个问题：
- When：调度时机
- What：调度算法，调度哪个
- How：如何调度（进程的上下文切换）


**调度时机**：就绪队列改变。具体来说，有4个情况：
- 进程正常终止、由于错误终止
- 新进程创建。某个进程从等待变成就绪
- 进程从运行态变成阻塞态
- 进程从运行态变成就绪态

上下文切换的开销
- 直接开销：内核完成切换所用的CPU时间
    - 保存和恢复寄存器
    - 切换地址空间（昂贵）
- 间接开销
    - 高速缓存、缓冲区缓存、TLB等区域的失效


调度算法考虑的因素
- 不同的系统：批处理系统、多道程序设计系统、批处理与分时的混合系统、个人计算机、网络服务器
- 性能的理解。用户角度：周转时间、响应时间、任务的最后期限。系统角度：吞吐量、CPU利用率。
- 其它方面。用户角度：可预测性。系统角度：公平性、强制优先性、平衡资源。
- 调度算法衡量指标
    - 吞吐量（Throughput）：单位时间完成的进程数
    - 周转时间（TT，Turnaround Time）：进程从提出请求到运行完成的时间
    - 响应时间（RT，Response Time）：从提出请求到第一次回应的时间
    - CPU利用率（CPU Utilization）：CPU做有效工作时间的比例
    - 等待时间（Waiting time）：每个进程就绪队列（ready queue）中的等待时间。
- 调度算法相关的因素：
    - PCB 中存储了优先级。静态优先级（优先级不会变），动态优先级（优先级会变，例如等待较长时间后，把优先级提高）
    - 就绪队列。按照不同的优先级，队列有多个。
    - 抢占 CPU 的方式
        - 不可抢占式（Non-preemitive）。某进程被调度后一直运行下去，除非它由于自身原因不能运行
        - 抢占式（Preemptive）。有更高优先级的进程就绪时，系统强行剥夺正在运行进程的 CPU，提供给更高优先级的进程使用
    - IO密集型/CPU密集型
        - 一般优先运行IO密集型。因为它运行完后会进入等待态。
    - 时间片（Time slice，quantum）。单次允许进程运行的时间
        - 考虑因素：进程切换开销，对响应时间的要求，就绪进程个数，CPU能力，进程的行为。
        - 问题：时间片多大合适？长度固定还是可变？

### 调度算法

批处理系统常用的调度算法
- 先来先服务（FCFX，First Come First Serve）
    - 按照进程就绪的先后顺序使用 CPU
    - 非抢占
    - 实现简单、公平
    - 如果短进程在后面，整体等待时间长
- 最短作业优先（SJF，Shortest Job First）
    - 有最短完成时间的进程优先执行
    - 非抢占式
    - 提高了平均周转时间
- 最短剩余时间优先（SRTN，Shortest Remaining Time Next）
    - SJF 的抢占式版本，一个新就绪的进程比当前运行的进程有更短的完成时间时，抢占进程。
    - 所有进程同时可运行前提下，有最短的平均周转时间
    - 如果有源源不断的短任务到来，长任务会长时间得不到运行（**饥饿问题**）
- 最高响应比优先（HRRN，Highest Response Ratio Next）
    - 是 FCFX 和 SJF 的折中。先计算响应比 R = 周转时间/处理时间 = 1 + （等待时间/处理时间），响应比越高越优先。


![scheduling_algorithms1](/pictures_for_blog/computer/scheduling_algorithms1.gif)

![scheduling_algorithms2](/pictures_for_blog/computer/scheduling_algorithms2.gif)


交互式系统中的调度算法
- 轮转调度（RR，Round Robin）
    - 按照确定的顺序轮番调度，每次运行一个时间片
    - 如何确定时间片：
        - 时间片太长，大于一次典型交互时间，退化成FCFS算法。并且会延长响应时间（例如，100个进程，则需要100T才能轮到）。
        - 时间片太短，小于一次典型交互时间，进程切换频繁，浪费 CPU 时间
        - 经验选择 10ms-100ms 之间
    - 优点：公平。有利于交互式计算，响应快。
    - 缺点：进程切换有成本
    - 缺点：平均完成时间会下降。例如进程 A，B都需要 100ms完成，时间片为 1ms，那么调度顺序为 `ABABAB...A(199)B(200)`，平均完成时间为 199.5ms。相比之下， FCFS 平均完成时间为 （100ms+200ms）/2= 150ms
- 虚拟轮转算法（Virtual RR）
    - 为什么？使用 RR 算法时，IO 密集型任务每次分片都会提前执行完，并进入调度循环。这对于 IO 密集型任务很不公平。
    - Virtual RR 是 RR 的改进。另开一个“辅助队列”，当一个分片提前执行完，就会放入“辅助队列”。每次轮换优先从“辅助队列”选取，直到“辅助队列”为空。
- 最高优先级调度（HPF，Highest Priority First）
    - 总是选择优先级最高的进程来执行
    - 优先级设计：系统进程高于用户进程，前台进程高于后台进程，IO密集型进程高于CPU密集型进程
    - 优先级可以是静态不变的，也可以是动态变化的
    - 评价：实现简单、不公平、会让某些进程一直无法运行（**饥饿现象**）
    - **优先级反转** 现象。例子，有高、中、低三个优先级的进程，记为 H、M、L，其中 L 持有 H 所需要的资源。那么 H 进入临界区被阻断，L进入临界区被抢占，M一直执行。导致高优先级进程一直无法运行，系统性能降低。（1997年，火星探测器上发生了此现象）
        - 解决方法3种：1）设置优先级上限，进入临界区的进程优先级都是最高的。2）优先级继承，L可以继承H的优先级。3）进入临界区的进程禁止中断
- 多级反馈队列（Multiple feedback queue）非抢占式
    - 是UNIX的BSD采用的调度算法，是一个综合调度算法
    - 就绪队列为多个，每个队列优先级不同，第一个队列优先级最高
    - 每个队列的时间片不同，优先级越低，时间片越大。$2^n$ 的方式递增。
    - 优先调度高优先级，直到高优先级为空，再调度下一个优先级的队列
    - 一个新进程就绪后直接进入第一级队列
    - 由于用完时间片而放弃 CPU 的进程，进入更低等级队列
    - 由于阻塞而放弃 CPU 的进程，就绪后进入原队列。这里有不同的策略：可以插入队尾或队首；分配的时间片可以是原本未用完的，也可以是新值。
    - 评价：对IO密集型更优先调度。对计算密集型，虽然优先度低，但时间分片长。
- 多级反馈队列，允许抢占
    - 被抢占的进程回到原来一级就绪队列的队尾（或队首）
- 最短进程优先（Shortest Process Next），与上面批处理中的 SJF 一样

### 多处理器调度算法

考虑问题
- 不但要确定选择哪个进程执行，还要考虑哪个CPU上执行
- 考虑多CPU之间迁移时的开销。进程尽可能在同一个CPU上执行。
- 负载均衡问题

### Windows的线程调度算法


典型系统的调度算法
- UNIX 动态优先数
- 5.3BSD 多级反馈队列
- Linux 抢占式调度
- Windows 基于优先级的抢占式多任务调度
- Solaris 综合调度算法


Windows的线程调度
- 由于 Windows 支持内核级线程，因此 **调度单位是线程**
- 调度算法是：基于动态优先级、抢占式、结合时间配合调整
    - 就绪线程按照优先级进入队列
    - 总是悬着优先级最高的就绪线程运行
    - 同一优先级各线程按时间片轮转进行调度
    - 多 CPU 允许多个线程并行运行
- 引发线程调度的条件
    - 一般的：正常终止/错误终止，新线程创建，等待线程变成就绪，运行态进入阻塞态，运行态变成就绪态
    - 还新增两种情况：1）一个线程的优先级改变了。2）一个线程改变它的亲和（Affinity）处理机集合


Windows 共有 32 个优先级

时间配额



| 调度算法              | 特点                        | 是否抢占CPU         | 平均周转时间 | 响应时间                        | 对进程的影响             | 饥饿问题 |
|-----------------------|-----------------------------|----------------------|--------------|---------------------------------|--------------------------|----------|
| FCFS                  | 简单、公平                   | 非抢占               | 长           | 慢，特别是执行时间差别较大时       | 对短进程和I/O型进程不利   | 无       |
| SJF                   | 优先选择短进程               | 非抢占               | 较短         | 短进程响应较好                   | 对长进程不利             | 有       |
| SRTN                  | 允许抢占，优先剩余时间短的进程 | 抢占（新进程到达时） | 更短         | 较好                             | 对长进程不利             | 有       |
| HRRN                  | FCFS和SJF折中，解决饥饿问题  | 非抢占               | 接近SJF      | 接近SJF                          | 对长进程更友好           | 无       |
| RR                    | 公平，时间片轮转             | 抢占（时间片用完时）  | 中等         | 短进程响应较好                   | 公平                     | 无       |
| Virtual RR            | 类似RR，引入“辅助队列”    | 通常为抢占            | 不定         | 较好                             | 适合混合型任务           | 无       |
| HPF                   | 根据优先级调度               | 可为抢占或非抢占      | 不定         | 高优先级响应快                   | 低优先级进程可能受影响   | 有       |
| Feedback (非抢占式)   | 多级反馈队列，逐步降级       | 非抢占               | 取决于队列结构 | 较好                             | 对I/O进程有利             | 有       |
| Feedback (抢占式)     | 多级反馈队列，时间片调度     | 抢占（时间片用完时）  | 取决于队列结构 | 较好                             | 对I/O进程有利             | 有       |
| Shortest Process Next | 类似SJF                     | 非抢占               | 短           | 短                               | 对长进程不利             | 有       |



## 同步机制


与时间有关的错误（例子）

有个程序是关于从账户付款的，初始余额为 5000元，连续两次付款（1000元和2000元），引发了2个进程：

![concurrency_example0](/pictures_for_blog/computer/concurrency_example0.gif)

这两个进程运行后，根据不同的调度顺序，可能有不同的结果


![concurrency_example](/pictures_for_blog/computer/concurrency_example.gif)

概念
- **进程互斥**（Mutual Exclusive）：进程使用的某些共享资源（变量、文件等）需要排他性的使用（否则结果可能不对），各进程之间竞争使用这些资源。
- **临界资源** （critical resource）：资源一次只允许一个进程使用（叫做临界资源、互斥资源、共享变量）
- **临界区**(互斥区，critical section，region)：各个进程中对某个临界资源（共享变量）实施操作的程序片段


不允许两个进程同时处于临界区。带来优先级反转问题（前面写了）

为了防止临界区重叠，
- 软件方案：Dekker、Peterson
- 硬件方案：屏蔽中断、TSL(XCHG)指令

### 进程互斥的软件解决方案

一个错误的解决方案1：

```
... ...
while(free); // 如果 free = true，则一直在此等待；如果 free = false，则
free = true; // 标识临界区已被占用

临界区;

free = false; // 表示临界区已释放
... ...
```

上面的思路正确，但结果仍然可能错误。
- 原因是 程序挂起的时间点可能在 `while(free)` 和 `free = true`，这样仍然会临界区重叠
- 解决方案是把 `while(free)` 和 `free = true` 变成一个元语 ``，使其不可被中断，如下：

**进程互斥的软件解决方案1:**  

```
... ...
lock();
临界区;
unlock();
... ...
```


一个错误的解决方案2：

```
进程 P:
... ...
while(not turn);
临界区
turn = false;

进程Q:
while(turn);
临界区
turn = true;
```

错误在于，如果 `turn = true`，且 Q 不想进入临界区，那么 P 就永远无法进入临界区。


一个错误的解决方案3：


```
进程 P:
... ...
pturn = true;
while(qturn);
临界区
pturn = false;

进程Q:
qturn = true;
while(pturn);
临界区
qturn = false;
```


上面的错误在于，如果 P 和 Q 恰好都在 `pturn = true;` 和 `while(qturn);` 语句之间中断，那么两个进程都永远无法进入临界区（After you 问题）。


**DEKKER算法** （1965年）
- 在解法3 的基础上，引入 `turn` 变量（枚举类型），当出现 after you 问题时，由 turn 来决定谁进入临界区




```
进程 P:
... ...
pturn = true;
while(qturn){
    if (turn == 2){
        pturn = false;
        while(turn == 2);
        pturn = true;
    }
}
临界区
turn = 2;
pturn = false;

进程Q:
qturn = true;
while(pturn){
    if (turn ==1){
        qturn = false;
        while (turn == 1);
        qturn = true;
    }
}
临界区
turn = 1;
qturn = false;
```

此算法的缺点必须轮流运行


**peterson算法** （1981年）
- 解决互斥问题
- 克服了DEKKER算法强制轮流的缺点

```c
// 对于进程i：
enter_region(i);
临界区;
leave_region(i);


// 进入临界区的函数：
int turn; // 轮到谁了
int interested[N]; // 兴趣数组，记录哪个进程对进入 CPU 感兴趣，初始化为 false
void enter_region(int process){ // 此案例假设只有 2 个进程，因此 process = 0 或 1
    int other; // 另一个进程的进程号
    other = 1 - process;
    interested[process] = true; // 本进程对进入 CPU 感兴趣
    turn = process; // 设置标志位
    while(turn == process && interested[other] == true);
}


void leave_region(int process){
    interested[process] = false;
}
```

### 进程互斥的硬件解决方案

方案1：“开关中断”指令

```
执行 “关中断”指令
临界区
执行“开中断”指令
```

评价
- 简单、高效
- 如果临界区大，就限制了 CPU 的并发能力。
- 不适用于多处理器
- 适用于操作系统本身，不适于用户进程（因为用户程序不能使用特权指令）。



方案2:“测试并加锁”指令（TSL，TEST AND SET LOCK）

```
enter_region:
    TSL REGISTER,LOCK       | 复制锁到寄存器
    CMP REGISTER,#0        | 判断寄存器内容是否为0
    JNE enter_region        | 若不为0，跳转到 enter_region
    RET                     | 返回调用者，使其进入临界区 

leave_region:
    MOVE LOCK,#0            | 在锁中置0
    RET                     | 返回调用者
```

方案3:“交换指令”

```
enter_region:
    MOVE REGISTER,#1        | 寄存器置1
    XCHG REGISTER,LOCK      | 交换寄存器和锁的内容
    CMP REGISTER,#0        | 判断寄存器内容是否为0
    JNE enter_region        | 若不为0，跳转到 enter_region
    RET                     | 返回调用者，使其进入临界区 

leave_region:
    MOVE LOCK,#0            | 在锁中置0
    RET                     | 返回调用者
```


### 进程同步

进程同步（synchronization）：进程之间存在 **时序关系**。例如，一个进程运行到某一点，需要另一个进程给它提供消息，此时该进程进入阻塞态，获得消息后进入就绪态。

生产者-消费者问题

问题：忙等待，缓存区满/缓冲区空，都会有浪费。
解决：新增两个原语：睡眠、唤醒



## 存储模型

## 文件系统

## IO

## 死锁



## 参考资料


[Coursera课程：北京大学，陆俊林《计算机组成》](https://www.coursera.org/learn/os-pku)
