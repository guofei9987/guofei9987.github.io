---
layout: post
title: 【CS】计算机操作系统
categories:
tags: 0x11_算法平台
keywords:
description:
order: 173
---


## 概述

操作系统的功能
- CPU管理：进程/线程管理。进程/线程状态、控制、同步互斥、通信、调度...
- 存储管理。分配/回收、地址管理、存储保护、内存扩充...
- 文件管理。文件目录、文件操作、磁盘空间、文件存取控制...
- 设备管理。设备驱动、分配回收、缓冲技术...
- 用户接口。系统命令、编程接口...


OS是硬件上的第一层软件
- 例如读取文件：“从某个文件读一个数据块” or “移动磁头，等待放下”
- OS 在应用程序578和硬件之间建立一个“虚拟机”
- 对硬件抽象、提高程序可移植性

OS的特征
- 并发（concurrency），能处理同时的活动。
    - 这些活动之间有依赖关系，需要解决同步等问题。
    - 宏观上看，程序在同步执行。微观上看，程序在CPU上轮流执行
- 共享（sharing），
    - 互斥共享（打印机）/同时共享（磁盘文件）
- 虚拟（virtual）
    - 一个物理实体，映射为若干逻辑实体
    - 提高资源利用率
    - 例如：CPU--进程，存储器--每个进程有独立的虚拟地址空间，显示设备--多窗口/虚拟终端
- 随机。处理不可预测的次序发生的事件
    - 多个进程的运行速度不可预知


### 操作系统的分类

其实还有别的分类，这里只写一种分类。

1. 批处理操作系统。用户把作业交给系统操作员，操作员把作业输入到计算机系统，计算机批量处理。
    - 用户用卫星机把作业放入“输入井”，主机读取“输入井”，处理后把结果放入“输出井”，用户从“输出井”获取处理结果
2. 分时操作系统：CPU分成片段，轮流供每个用户使用，使用户感觉自己在连续使用。
3. 实时操作系统：要求计算机立即响应外部请求，并在严格时间内完成处理，高可靠性。
    - 工业控制、航空、军事
    - 实时通信（信息）处理
    - 硬实时系统：要求必须在规定时间内完成。  
    - 软实时系统：偶尔可以违反时限。例如播放器。
4. 个人计算机操作系统：界面友好、使用方便、应用丰富。
5. 网络操作系统。按网络体系结构协议标准开发的软件。
    - 网络管理、通信、安全、资源共享、各种网络应用
6. 分布式操作系统。是一个统一的操作系统，若干台计算机共同完成任务。
7. 嵌入式操作系统。各种设备，例如汽车、手机、电视机。

### 运行机制

系统调用：操作系统给应用程序的接口
- 允许应用程序执行一些操作/服务（例如文件操作、进程管理、内存分配、设备管理）
- 过程中从用户态切换到内核态（叫做陷入 trap）





## 中断和异常

- 中断由外部设备和时间引起的
- 异常是由正在执行的程序内部产生的错误或特殊情况引起的
- 都对应从 用户态 切换到 内核态度


## 进程/线程

多道程序设计：允许多个程序同时进入内存并运行。目的是提高系统效率。
- 每个程序都有自己的逻辑程序计数器
- 哪个运行，就把哪个放入物理计数器
- 每个程序轮流执行，并发执行


并发环境：
- 单个处理器上的程序，**同时** 处于开始运行但尚未结束的状态
- 并且次序不是事先确定的

**进程**（Process）：有独立功能的程序关于某个数据集合上的一次运行活动
- 又称任务（Task、Job）
- 是对 CPU 的抽象。
- 是把一个 CPU 抽象为 多个虚拟的CPU
- 一单位为分配，如内存、文件
    - **每个都有独立的地址空间**。意味着每个进程的地址空间是逻辑地址，而不是物理地址。
- 操作系统吧 CPU 调度给需要的进程


**PCB**（Process Control Block，进程描述符，进程属性）
- 一个专门数据结构，记录进程的各种属性、描述进程的动态变化过程
- 进程与 PCB 是一一对应的
- 所有 PCB 集合叫做 **进程表**
    - 进程表的大小限制了操作系统可以同时开多少个进程
- **PCB 记录了哪些信息？**
    - 进程描述信息
        - 进程标识符 process ID，唯一、整数
        - 进程名，通常基于可执行文件名
        - 用户标识符 user ID
        - 进程组关系
    - 进程控制信息
        - 当前状态
        - 优先级 priority
        - 代码执行入口地址
        - 程序的磁盘地址
        - 运行统计信息（执行时间、页面调度）
        - 进程间同步和通信
        - 进程的队列指针
        - 进程的消息队列指针
    - 进程拥有的资源和使用情况
        - 虚拟地址文件状况
        - 打开文件列表
    - CPU 现场信息。进程不运行状态下保存的信息。
        - 寄存器值（通用机孙琦、PC、状态字PSW、栈指针）
        - 志向进程页表的指针
- 在不同的操作系统下是不一样的。Linux：`task_struct`, Windows：`EPROCESS`,`KPROCESS`,`PEB`


进程状态（基础状态）
- 运行态（Running），占有 CPU，并在 CPU 运行
- 就绪态（Ready），已经具备运行条件，但没有空闲 CPU
- 等待态（Waiting/Blocked、阻塞态、封锁态、睡眠态），等待某个事件而暂时不能运行。例如等待读磁盘。

进程的其他状态
- 创建态（New），已经完成创建的必要工作（PID，PCB），但是尚未同意执行该进程（例如资源有限）
- 终止态（Terminated）。
    - 终止执行
    - 可完成一些数据统计工作（资源使用量等）
    - 资源回收
- 挂起态（suspend）
    - 用于负载调节
    - 进程的内存会被回收，进程印象道磁盘上。
    - 资源足够后会重新激活
 

![进程间的转化](/pictures_for_blog/computer/process.gif)

除此之外，还有类似的七状态模型

Linux 的进程态:

![process_linux](/pictures_for_blog/computer/process_linux.jpg)




**进程队列**。进程状态的改变，实际上是 PCB 从一个队列出列，进入另一个队列的过程
- 例如，就绪态可能有多个队列


### 进程控制

进程控制操作完成进程之间的转换，由 **原语**（primitive） 完成。（原语一种原子操作，不可分割、不可中断）

进程的创建
- 分配一个唯一标识，进程控制块
- 分配地址空间
- 初始化进程控制块
- 设置相应的队列指针。
    - 例如新进程加入到就绪队列链表中。
- unix：`fork`, `exec`。Windows：`CreateProcess`

进程的撤销（技术进程）
- 资源回收：关闭打开的文件、断开网络链接、回收分配的内存
- 撤销进程的 PCB
- unix:`exit`，windows：`TerminateProcess`

进程的阻塞
- 进程自己执行阻塞原语
- unix：`wait`，windows：`WaitForSingleObject`


unix 几个进程控制函数
- `fork()` 复制调用进程来建立新的进程。最基本的进程建立过程。
- `exec()` 用新的程序代码覆盖原来的地址空间，实现进程执行代码的转换
- `wait()` 初级进程同步操作，使一个进程等待另一个进程的结束
- `exit()` 终止一个进程的运行

`fork()` 的实现
- 为子进程分配一个空闲的进程描述符（proc 结构）
- 为子进程分配 pid
- **一次一页的方式复制父进程地址空间**
    - 子进程的代码一般与父进程不同，这一步就造成浪费。Linux 采用 Copy-On-Write 技术来解决
        - 不复制父进程地址空间，而是用一个指针指向它，然后设定为只读。
        - 如果需要写入它，就开辟一个新的空间来写入
- 从父进程继承共享资源（如，打开的文件、当前工作目录）
- 把子进程状态设为就绪，插入到就绪队列
- 对子进程返回标识符 0
- 向父进程返回子进程的 pid

`fork()` 的使用


伪代码：
```
pid = fork(); // 创建一个子进程
if(pid<0){
    fprintf("出错);
    exit(-1);
}
else if(pid == 0){ 
    // 因为子进程会把父进程的一页复制进来
    fprintf("pid = 0 说明正在运行的是子进程");
    exec("xxx") // 调用 exec，用新代码覆盖子进程的地址空间
}
else {
    fprintf("pid>0 ，指的是子进程的 pid，并且正在运行的是父进程");
    wait(NULL); // 父进程等待子进程结束
    exit(0);
}
```

### 进程相关概念

![process_addr](/pictures_for_blog/computer/process_addr.gif)


分类1:
- 系统进程。系统建立的，优先级较高
- 用户进程

分类2:
- 前台进程。与用户直接交互的，例如鼠标键盘
- 后台进程。打印、防火墙、电子邮件接收等

分类3:
- CPU密集型进程
- IO密集型进程 

进程的层次结构
- unix：进程家族树。init 为根。父进程结束，子进程也必须结束。
- Windows：地位相同。虽然也是由进程建立另一个进程，但是未必一个结束另一个也结束。


进程与程序：一个程序可以对应多个进程。 


进程有自己的地址空间（逻辑地址，而不是物理地址）

进程映像（IMAGE）
- 由进程地址空间内容、硬件寄存器、进程相关的内核数据结构、内核栈组成
- 相当于一个快照

上下文切换（Context Swith）
- CPU 硬件从一个进程切换到另一个进程的过程
- 进程不运行时，寄存器值保存在 PCB 中；切换到某个进程时，从对应的 PCB 中把值送回寄存器


### 线程

为什么需要多线程？
- 例如一个编辑器，需要同时处理：键盘输入、自动排版、定时保存。
- 一个Web服务器，需要同时接受网页请求、从磁盘检索网页、读入内存、把结果返回给客户端。



其它方案
- 如果使用单个进程，顺序编程，性能低
- 如果使用多进程，就不能使用共享的内存空间了
- 如果使用有限状态机方法（就是用一些编程手段来模拟多进程），例如非阻塞IO，编程会非常复杂

所以需要 **多线程**


多线程的好处2:开销小
- 进程涉及到进程创建、进程撤销、进程通信、进程切换，时间和空间开销大
- 线程开销小：
    - 创建和撤销花费时间少
    - 线程切换花费时间少
    - 线程间通信无须调用内核，同一个进程的线程共享内存和文件


线程的好处3:
- 多个处理器，可以充分发挥优势

线程是什么？
- 进程有两个属性：资源拥有者、CPU调度单位
- 线程只继承一个属性：CPU调度单位。（因此有时候把线程称为 **轻量级进程**）

线程的属性
- 标识符 ID
- 状态、状态转换
- 不运行时需要保存的上下文（例如PC寄存器）
- 线程有自己的栈和栈指针
- 共享所在进程的地址空间和其它资源
- 线程可以创建、撤销另一个线程





## 参考资料


[Coursera课程：北京大学，陆俊林《计算机组成》](https://www.coursera.org/learn/os-pku)
