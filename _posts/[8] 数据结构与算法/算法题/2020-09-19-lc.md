---
layout: post
title: LeetCode刷题大全
categories:
tags: 0x80_数据结构与算法
keywords:
description:
order: 595
---


### 1. Two Sum

考点
1. 限制加和等于n。不要每一步都判断x+y=n，而是判断n-x=y
2. 两次遍历。考虑不写2个for，而是1次遍历，把元素放到hashtable中

```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
    tmp_dict = dict()
    for i, j in enumerate(nums):
        if j in tmp_dict:
            return [tmp_dict[j], i]
        tmp_dict[target - j] = i
```


### 2. Add Two Numbers

考点
1. 对于链表，`curr.next` 指针向下走，这个不多说
2. `curr1=curr1.next if curr1 else curr1` 这个操作，让遍历到尾部后，值保持`curr1=None`，好处是少些几行代码。作为配合，在其它行，可以用 `if curr1` 来判断是否到尾部
3. 链表还有个好处，如本例，`l3` 是含一个空的头的，返回 `l3.next` 即可


```python
def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
    carry=0
    l3=ListNode(None)
    curr1,curr2,curr3=l1,l2,l3
    while curr1 or curr2 or carry:
        value=(curr1.val if curr1 else 0)+(curr2.val if curr2 else 0)+carry
        carry,val=divmod(value,10)
        curr3.next=ListNode(val)
        curr1=curr1.next if curr1 else curr1
        curr2=curr2.next if curr2 else curr2
        curr3=curr3.next
    return l3.next
```

### 3. Longest Substring Without Repeating Characters

考点：
1. 2 sum 那道题里面写过，这种貌似需要两次遍历的题目。都可以想一下能不能用 hashTable 存下历史遍历，从而变成一次遍历。


```python
def lengthOfLongestSubstring(self, s: str) -> int:
    used = dict()
    start = 0
    res = 0
    for i, c in enumerate(s):
        if c in used and start <= used[c]:
            start = used[c] + 1
        else:
            res = max(res, i - start + 1)
        used[c] = i
    return res
```



### 4. Median of Two Sorted Arrays


这个题目其实可以 cheat，俩列表加一起，然后用Python自代的sort，代码就不写了。

套路详解：https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2481/Share-my-O(log(min(mn)))-solution-with-explanation  

考点：  
1. 中位数的定义：中位数两边的数量相等。
2. 因此，num1 的分割和num2的分割存在一个恒等关系，len(left1)+len(left2)=len(right1)+len(right2)
3. 这也就意味着，给定num1的分割，就立即能计算出num2的分割
4. 本质上还是把两次遍历变成一次
5. 如果if情况过多，考虑换一下两个变量，减少代码量。


(代码还是好难写，奇偶之类的)

```python
def median(A, B):
    m, n = len(A), len(B)
    if m > n:
        A, B, m, n = B, A, n, m

    imin, imax, half_len = 0, m, (m + n + 1) / 2
    while imin <= imax:
        i = (imin + imax) / 2
        j = half_len - i
        if i < m and B[j-1] > A[i]:
            # i is too small, must increase it
            imin = i + 1
        elif i > 0 and A[i-1] > B[j]:
            # i is too big, must decrease it
            imax = i - 1
        else:
            # i is perfect

            if i == 0: max_of_left = B[j-1]
            elif j == 0: max_of_left = A[i-1]
            else: max_of_left = max(A[i-1], B[j-1])

            if (m + n) % 2 == 1:
                return max_of_left

            if i == m: min_of_right = B[j]
            elif j == n: min_of_right = A[i]
            else: min_of_right = min(A[i], B[j])

            return (max_of_left + min_of_right) / 2.0
```

### 5. Longest Palindromic Substring

没有套路。中间往外拓，平方级复杂度。

```py
class Solution:

    def helper(self, left, right):
        while left >= 0 and right < len(self.s) and self.s[left] == self.s[right]:
            left -= 1
            right += 1
        return left + 1, right - 1

    def longestPalindrome(self, s: str) -> str:
        self.s = s
        left, right = 0, 0
        for i in range(len(s)):
            left1, right1 = self.helper(i, i)
            left2, right2 = self.helper(i, i + 1)
            if right1 - left1 > right - left:
                left, right = left1, right1
            if right2 - left2 > right - left:
                left, right = left2, right2

        return s[left:right + 1]
```

### 6. ZigZag Conversion
没有套路。按照ZigZag的字面意思，在s上做遍历。  
（其实还可以先算出每个值所在的位置，不过有点儿费草稿纸）
```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows==1 or (len(s)<numRows):
            return s
        res_list = [''] * numRows
        location, direction = 0, -1 # 假想开头前面也迭代过程中，所以初始是负号
        for i in s:
            res_list[location] = res_list[location] + i
            if location == 0 or location == numRows - 1:
                direction = -direction
            location += direction
        return ''.join(res_list)
```

### 7. Reverse Integer

没有套路。  
按位数颠倒一个整数。考虑负号和零。Python用字符串反转就行了。

```python
class Solution:
    def reverse(self, x: int) -> int:
        sign = -1 if x < 0 else 1
        r = int(str(sign * x)[::-1])
        return sign * r * (r < 2 ** 31)
```


### 8. String to Integer (atoi)
实在无聊的题，就是各种边界条件。这题别做了，浪费时间。

```python
# 3.13->3
# .1->0
# -+9->0
# -000123a123->-123


class Solution:
    def get_num(self, sub_str):
        res = []
        for i in sub_str:
            if i.isdigit():
                res.append(i)
            else:
                break
        if len(res) == 0:
            return 0
        return int(''.join(res))

    def myAtoi(self, s: str) -> int:

        s = s.lstrip()
        if len(s) == 0:
            return 0
        if s[0] == '+':
            res = self.get_num(s[1:])
        elif s[0] == '-':
            res = -self.get_num(s[1:])
        else:
            res = self.get_num(s)

        if res < -2 ** 31:
            return -2 ** 31
        if res > 2 ** 31 - 1:
            return 2 ** 31 - 1

        return res
```

### 9.
无聊

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        x_str = str(x)
        return x_str == x_str[::-1]
```



### 10. Regular Expression Matching
好题！  
套路：
1. 递归（不是很容易想出）
2. 递归的某些节点被反复调用。考虑存下来。（下面代码里面没有体现）

https://leetcode.com/problems/regular-expression-matching/solution/

```python

def isMatch(text, pattern):
    if not pattern:
        return not text

    first_match= text and pattern[0] in {text[0],'.'}
    if len(pattern)>=2 and pattern[1]=='*':
        return isMatch(text,pattern[2:]) or first_match and isMatch(text[1:],pattern)
    else:
        return first_match and isMatch(text[1:],pattern[1:])

```

需要再过一遍：DP也能很好的解这个题。

### 11. Container With Most Water

好题！
1. 像 2-sum 那个题目，看起来需要2次遍历，立即想到暂存历史计算，减少计算量。
2. 先看看哪些情况是“不可能”的，把它们排除出去。左挡板从左向右遍历，如果后一个比前一个还短，那么这个不可能是 candidate，右挡板同样的道理。
3. （到上面这一步已经可以写代码了，最坏平方级复杂度）还可以继续优化（这个看答案才想出来）。我们上一步把不可能的情况删掉后得到了递增的左挡板，和递增（从右往左看）的右挡板。如果左挡板低于右挡板，那么右挡板向左移动就不可能是 candidate，于是又排除了很多情况，变成 O(n) 复杂度。


```python
a=[1,8,6,2,5,4,8,3,7]
i,j=0,len(a)-1
weight=0
while i<j:
    weight=max(weight,(j-i)*min(a[i],a[j]))
    if a[i]<a[j]:
        i+=1
    else:
        j-=1

weight
```

### 12. Integer to Roman
无聊的题
```python
all_symbols = [
    ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX']
    ,['', 'X', 'XX', 'XXX','XL', 'L', 'LX', 'LXX', 'LXXX', 'XC']
    , ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM']
    ,['', 'M', 'MM', 'MMM']
]

''.join([all_symbols[i][num//(10**i)%10] for i in range(3,-1,-1)])
```

### 13~15 无聊的题目

### 16. 3Sum Closest
n-Sum 两种思路：
1. 复用2sum，加一层遍历。2sum复杂度是n，3sum复杂度是O(n^2)
2. 2sum还有另一种解法，先排序，然后使用 `Container With Most Water` 的思路，找解复杂度是 O(n),但排序的复杂度是 O(nlgn)，所以2sum复杂度是 O(nlgn),3sum复杂度 O(n^2+nlgn)=O(n^2)
3. 所以2sum和3sum都可以用这个思路，复杂度一样
4. 但3Sum Closest显然不能用1了，但可以用2


```python

nums=[0,-4,1,-5]
target=0

nums.sort()


def sum2_cloeset(nums,n):
    i,j=0,len(nums)-1
    res=nums[i]+nums[j]
    diff=abs(res-n)
    while i<j:
        sum2=nums[i]+nums[j]
        if sum2==n:
            return sum2
        diff_tmp=abs(sum2-n)
        if diff_tmp<diff:
            diff=diff_tmp
            res=sum2
        if sum2>n:
            j-=1
        else:
            i+=1
    return res


# nums=[1,2,3,4,5]
# sum2_cloeset(nums,5)


diff=abs(sum(nums[:3])-target)
res=sum(nums[:3])
for i in range(len(nums)-2):
    tmp=sum2_cloeset(nums[i+1:],target-nums[i])
    if abs(tmp+nums[i]-target)<diff:
        print(tmp,nums[i])
        res=tmp+nums[i]
        diff=abs(tmp+nums[i]-target)

res
```

### 17. Letter Combinations of a Phone Number

基础题，可以以此题为例子，把几种解法练熟了，甚至背下来。
1. 利用 itertools
```python
import itertools
def letterCombinations(self, digits: str) -> List[str]:
    if len(digits)==0:return []
    all_char=['','','abc','edf','ghi','jkl','mno','pqrs','tuv','wxyz']
    candidate=[list(all_char[int(button)]) for button in digits]
    return [''.join(i) for i in  itertools.product(*candidate)]
```
2. 递归。这个递归方法要求返回所有遍历到叶节点的路径。而不是成功访问1个叶节点就返回。这两种递归都要非常熟悉。
```python
all_char=['','','abc','edf','ghi','jkl','mno','pqrs','tuv','wxyz']
def letter_comb(digits):
    if len(digits)==0:
        return []
    if len(digits)==1:
        return list(all_char[int(digits[0])])
    prev=letter_comb(digits[:-1])
    lst=all_char[int(digits[-1])]
    return [s+l for s in prev for l in lst]
letter_comb(digits)
```
3. 递归（从前往后），另外，如果不考虑空的特殊情况，代码还可以再省一些
```python
all_char=['','','abc','edf','ghi','jkl','mno','pqrs','tuv','wxyz']
def letter_comb(digits):
    if len(digits)==0:
        return ['']
    prev=all_char[int(digits[0])]
    lst=letter_comb(digits[1:])
    return [p+l for p in prev for l in lst]
```
4. 遇到笛卡尔积问题，优先使用这个套路。递归太容易写错，还是for循环好一些。
```python
all_char=['','','abc','edf','ghi','jkl','mno','pqrs','tuv','wxyz']
def letter_comb(digits):
    digits=[int(i) for i in digits]
    res=['']
    for digit in digits:
        res=[i+j for i in res for j in all_char[digit]]
    return res
```
5. 事实证明，太多骚操作，复用就不方便。简简单单的for循环。（22题复用此代码）
```python
all_char=['','','abc','edf','ghi','jkl','mno','pqrs','tuv','wxyz']
res=['']
for i in digits:
    res=[term+char for term in res for char in all_char[int(i)]]
```



### 18. 4Sum

用递归，nSUM都能做出来
```python

def find_2sum(nums,target):
    i,j=0,len(nums)-1
    res=[]
    while i<j:
        sum2=nums[i]+nums[j]
        if sum2==target:
            res.append([nums[i],nums[j]])
            i+=1
        elif sum2>target:
            j-=1
        else:
            i+=1
    return res


def find_Nsum(nums,target,N):
    if N==2:
        return find_2sum(nums,target)
    res=[]
    for i in range(len(nums)-N+1):
        tmp=find_Nsum(nums[i+1:],target-nums[i],N-1)
        if len(tmp)>0:
            res.extend([[nums[i]]+t for t in tmp])
    return res


nums=[1,0,-1,0,-2,2]
target=0
nums.sort()
find_Nsum(nums,target,N=4)
```

### 19. Remove Nth Node From End of List

考点：
1. 凡是链表上的遍历问题，一律先想想能否使用单指针/双指针/多指针
2. 如果处理的链表是不含空的头节点那种，一律加上空的头节点。这样往往可以减少很多处理边界条件的代码量。

```python
def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
    dummy=ListNode('')
    dummy.next=head
    curr1=dummy
    for i in range(n):
        curr1=curr1.next
    curr2=dummy
    while curr1.next:
        curr1=curr1.next
        curr2=curr2.next
    curr2.next=curr2.next.next
    return dummy.next
```

### 20. Valid Parentheses

好题目，用堆栈做，没什么难度
```python
def isValid(self, s: str) -> bool:
    stack=list()
    pairs={'(':')','[':']','{':'}'}
    pairs2={')':'(',']':'[','}':'{'}
    for i in s:
        if i in pairs:
            stack.append(i)
        elif i in pairs2:
            if len(stack)==0:
                return False
            elif stack[-1]==pairs2[i]:
                stack.pop()
            else:
                return False
    return len(stack)==0
```


### 21. Merge Two Sorted Lists

基础题，
1. 遇到链表，第一想到指针
2. 处理链表，一律先转化成带空头节点的链表。可以减少一些边界条件的代码量，减少错误。

```python
def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
    if l1 is None :
        return l2
    if l2 is None:
        return l1
    dummy1,dummy2=ListNode(),ListNode()
    dummy1.next,dummy2.next=l1,l2
    curr1,curr2=dummy1,dummy2.next
    while curr2 and curr1.next:
        if curr1.next.val>curr2.val:
            tmp1,tmp2=curr1.next,curr2.next
            curr1.next=curr2
            curr2.next=tmp1
            curr2=tmp2
            curr1=curr1.next
        else:
            curr1=curr1.next
    while curr1.next:
        curr1=curr1.next
    curr1.next=curr2
    return dummy1.next
```

addition：其实熟练后可以不用全都加 dummy

```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if list1 is None:
            return list2
        dummy1=ListNode(None)
        dummy1.next=list1
        curr1,curr2=dummy1,list2
        while curr1.next and curr2:
            if curr1.next.val<=curr2.val:
                curr1=curr1.next
            else:
                tmp1,tmp2=curr1.next,curr2.next
                curr1.next=curr2
                curr2.next=tmp1
                curr1=curr1.next
                curr2=tmp2
        if curr1.next is None:
            curr1.next=curr2
        return dummy1.next
```



### 22. Generate Parentheses

用 `f(n-1)` 表示 `f(n)`，马上得出思路


```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        if n==1:
            return ['()']
        res=set()
        for term in self.generateParenthesis(n-1):
            tmp=[term[:i]+'()'+term[i:] for i in range(2*n)]
            res.update(tmp)

        return list(set(res))

```

### 23. Merge k Sorted Lists
复用merge2

```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if len(lists)==0:return None
        if len(lists)==1:return lists[0]
        def merge2(l1,l2):
            if l1 is None :
                return l2
            if l2 is None:
                return l1
            dummy1,dummy2=ListNode(),ListNode()
            dummy1.next,dummy2.next=l1,l2
            curr1,curr2=dummy1,dummy2.next
            while curr2 and curr1.next:
                if curr1.next.val>curr2.val:
                    tmp1,tmp2=curr1.next,curr2.next
                    curr1.next=curr2
                    curr2.next=tmp1
                    curr2=tmp2
                    curr1=curr1.next
                else:
                    curr1=curr1.next
            while curr1.next:
                curr1=curr1.next
            curr1.next=curr2
            return dummy1.next

        l1=lists[0]
        for i in range(1,len(lists)):
            l1=merge2(l1,lists[i])

        return l1     
```

### 24. Swap Nodes in Pairs

考点都是在前面出现过的，必须都玩熟了：
1. 遇到链表，无脑转成带空头节点的链表
2. 用 `curr.next and curr.next.next` 来规避 `curr.next` 是 `None` 的情况

```python
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        if head is None:
            return head
        dummy = ListNode(None)
        dummy.next = head
        curr = dummy
        while curr.next and curr.next.next:
            tmp1,tmp2=curr.next,curr.next.next
            tmp1.next=tmp2.next
            curr.next=tmp2
            tmp2.next=tmp1
            curr=tmp1

        return dummy.next
```

### 25. Reverse Nodes in k-Group

这个题就是两个逻辑的合并：取接下来的n个node，链表反转。
1. 链表反转是一个基础考点。可以每次把最前面的节点放到后面。也可以每次把最后面的节点放到前面。
2. 链表上的遍历，立即想到指针。
3. 链表无脑转为带空头节点的链表。传入 reverse 函数的“子串”是前一级当成dummy来用，
3. 代码逻辑不要混合，取k个与链表反转独立写。模块化适合考场。

```python
class Solution:
    def reverse(self,dummy,tail):
        # first as dummy
        head=dummy.next
        curr=head
        while curr is not tail:
            tmp=curr.next
            curr.next=tail.next
            tail.next=curr
            curr=tmp
        dummy.next=tail
        return dummy,head

    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        dummy=ListNode(None)
        dummy.next=head
        curr=dummy

        i=k
        start=curr
        while curr.next:
            curr=curr.next
            i-=1
            if i==0:
                _,curr=self.reverse(start,curr)
                start=curr
                i=k

        return dummy.next
```


## 26. Remove Duplicates from Sorted Array

很简单，也没总结出啥套路，下一题一样。

```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        curr1,curr2=0,1
        while curr2<len(nums):
            if nums[curr1]<nums[curr2]:
                curr1+=1
                nums[curr1]=nums[curr2]
            curr2+=1
        return curr1+1
```

## 27. Remove Element

很简单，不用看了，跟上一个提一样

```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        curr1,curr2=0,0
        while curr2<len(nums):
            if nums[curr2]!=val:
                nums[curr1]=nums[curr2]
                curr1+=1
            curr2+=1
        return curr1
```

## 28. Implement strStr()

自带的 `haystack.find(needle)`

KMP算法也可以

## 29. Divide Two Integers

不用再做了
```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        sign=1
        if dividend<0:
            sign=-sign
            dividend=-dividend
        if divisor<0:
            sign=-sign
            divisor=-divisor

        res=sign*(dividend//divisor)
        if res>2**31-1:
            return 2**31-1
        if res<-2**31:
            return -2**31
        return res
```

## 30. Substring with Concatenation of All Words

这个题目有一些特殊情况，例如 `['ab','ba']` 这种可能相互重叠的，还有 `['ab','cd','ab']` 这种重复的。

似乎比较好写的解决方式是每次移动一格，做暴力搜索。

???还没找到更好的方案

```python
import collections

class Solution:
    def is_good(self,text,words_dict,len_word,len_words):
        words_dict=words_dict.copy()
        for i in range(len_words):
            term=text[i*len_word:(i+1)*len_word]
            if term not in words_dict:
                return False
            elif words_dict[term]==0:
                return False

            words_dict[term]-=1
        return True




    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        res=[]
        len_word=len(words[0])
        len_words=len(words)
        curr=0
        words_dict=collections.Counter(words)
        while curr<len(s)-len_word*len_words+1:
            if self.is_good(s[curr:],words_dict,len_word,len_words):
                res.append(curr)
            curr+=1


        return res
```


## 31. Next Permutation

想到有个递推公式：
1. 如果 `num[i+1:]` 有next，那么整体就有next，迭代为 `f(num[i:]) = [num[i]] + f(num[i+1:])`
2. 如果 `num[i+1:]` 已经没有next，但是 `num[i]` 比 `num[i+1:]` 中的某个小。就让两个数字互换，并且 `num[i+1:]` 重新排序。例如 `2; 4, 3, 1` 就先换位置，变成 `3; 4, 2, 1`，然后后者排序，变成 `3; 1, 2, 4`
3. 如果以上条件都不满足，说明 `num[i:]` 是升序，就没有下一个了，按照题目要求，需要返回 `nums.sort()`


另外：
- 题目中要求直接替换 nums，下面的代码用了额外空间配合for循环赋值实现。后续改改代码或许可以节省空间


```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        def next_perm(nums):
            if len(nums)<=1:
                return False,None

            part1,part2=nums[0],nums[1:]
            has_next,next_nums = next_perm(part2)
            if has_next:
                return True,[part1] + next_nums
            else:
                if part1<max(part2):
                    next_idx=0
                    next_num=101
                    for idx,num in enumerate(part2):
                        if num>part1:
                            if num<next_num:
                                next_idx,next_num=idx,num
                    tmp=part2[next_idx]
                    part2[next_idx]=part1
                    part1=tmp
                    part2.sort()
                    return True,[part1]+part2
            return False,None

        has_next,next_nums=next_perm(nums)
        if has_next:
            for i in range(len(nums)):
                nums[i] = next_nums[i]
        else:
            nums.sort()
```

## 32. Longest Valid Parentheses

- 两个计数器，left表示当前序列中，左括号数量。right表示当前序列中，右括号数量。
- 如果left=right，更新一次最大值
- 如果left<right，开始一个新的序列
- （关键）以上忽略了 `(()` 这种情况，只需要把上面的算法从右向左再跑一次即可


```python3
class Solution:
    def helper(self,s,mode):
        left,right=0,0
        res=0
        for char in s:
            if char==mode:
                left+=1
            else:
                right+=1

            if right>left:
                left,right=0,0
            if right==left:
                res=max(res,left*2)
        return res    

    def longestValidParentheses(self, s: str) -> int:
        res1=self.helper(s,mode='(')
        res2=self.helper(s[::-1],mode=')')
        return max(res1,res2)
```


## 33. Search in Rotated Sorted Array

n种情况吧。（感觉下面的代码还可以优化，不过大体思路就是这样了）


```python3
class Solution:
    # def find_pivot(self,nums):
    #     left,right=0,len(nums)-1
    #     head,tail=nums[left],nums[right]
    #     mid_idx=(left+right)//2

        # return 0
    def search(self, nums: List[int], target: int) -> int:
        if nums[0]==target:
            return 0

        left,right=0,len(nums)-1

        if nums[0]<=target:
            while left<right:
                mid=(left+right)//2
                if nums[mid]<target:
                    if nums[mid]<nums[0]:
                        right=mid-1
                    else:
                        left=mid+1
                elif nums[mid]>target:
                    right=mid-1
                else:
                    return mid

        else:
            while left<right:
                mid=(left+right)//2

                if nums[mid]<target:
                    left=mid+1
                elif nums[mid]>target:
                    if nums[mid]>=nums[0]:
                        left=mid+1
                    else:
                        right=right-1
                else:
                    return mid



        mid=left
        if nums[mid]==target:
            return mid


        return -1
```

## 34. Find First and Last Position of Element in Sorted Array

先用二分法找左边，然后用二分法找右边。
- 应该有合起来找的方法，但是写的慢
- 下面的代码也有优化的空间



```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        res=[-1,-1]

        if len(nums)==0:
            return res


        # 寻找左边
        left,right=0,len(nums)-1
        while left<right:
            mid=(left+right)//2
            if nums[mid]>=target:
                right = mid-1
            else:
                left = mid+1

        if nums[left]<target:
            if left==len(nums)-1:
                return [-1,-1]
            if nums[left+1]==target:
                res[0]=left+1
            else:
                return [-1,-1]
        elif nums[left]==target:
            res[0]=left
        else:
            return [-1,-1]


        # 寻找右边
        left,right=res[0],len(nums)-1
        while left<right:
            mid=(left+right)//2
            if nums[mid]<=target:
                left=mid+1
            else:
                right=mid-1

        if nums[left]>target:
            res[1]=left-1
        else:
            res[1]=left


        return res
```


## 35. Search Insert Position

基本的二分法

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left,right=0,len(nums)-1
        while left<right:
            mid=(left+right)//2
            if nums[mid]<target:
                left=mid+1
            elif nums[mid]>target:
                right=mid-1
            else:
                return mid

        if nums[left]<target:
            return left+1
        else:
            return left
```


## 36. Valid Sudoku

暴力解法
```python
def is_good(lst):
    tmp=[i for i in lst if i!='.']
    return len(tmp)==len(set(tmp))

class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        for line in board:
            if not is_good(line):
                return False

        for i in range(9):
            col=[board[j][i] for j in range(9)]
            if not is_good(col):
                return False

        for i in range(3):
            for j in range(3):
                block=[board[3*i+i1][3*j+j1] for i1 in range(3) for j1 in range(3)]
                if not is_good(block):
                    return False
        return True
```


改进：可以用一个整数来表示列表，例如 `[...,1,0,1,0]` 表示2和4 存在，简写成 `1010...`。
- 一个新数 3 是否在已有呢？取决于 `...1010 & (1<<3)` 是否为0
- 如何更新呢？ `...1010 | (1<<3)`
- 答案如下：

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        row, col, box = [0] * 9, [0] * 9, [0] * 9
        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':
                    continue
                box_idx = (i // 3) * 3 + (j // 3)
                num = 1 << (ord(board[i][j]) + 48)
                if row[i] & num or col[j] & num or box[box_idx] & num:
                    return False
                row[i] |= num
                col[j] |= num
                box[box_idx] |= num

        return True
```


## 37. Sudoku Solver

练递归的好题！


用 set 来做，这个最易懂（跟我总结的公式有差别）

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:

        nums = {"1", "2", "3", "4", "5", "6", "7", "8", "9"}
        row = [set() for _ in range(9)]
        col = [set() for _ in range(9)]
        block = [[set() for _ in range(3)] for _ in range(3)]  # 3*3
        blank = []

        # 初始化，按照行、列、宫 分别存入哈希表
        for i in range(9):
            for j in range(9):
                ch = board[i][j]
                if ch == ".":
                    blank.append((i, j))
                else:
                    row[i].add(ch)
                    col[j].add(ch)
                    block[i//3][j//3].add(ch)

        len_blank=len(blank)
        def dfs(n):
            if n == len_blank:
                return True
            i, j = blank[n]
            rst = nums - row[i] - col[j] - block[i//3][j//3]  # 可行解
            if not rst:
                return False
            for num in rst:
                board[i][j] = num
                row[i].add(num)
                col[j].add(num)
                block[i//3][j//3].add(num)
                if dfs(n+1):
                    return True
                row[i].remove(num)
                col[j].remove(num)
                block[i//3][j//3].remove(num)

        dfs(0)
```





用位运算优化加速
- `row[i], col[j], block[i//3][j//3]` 都是int类型，第k位为1，表示 k+1 出现过
- `(~num) & 0x1ff`，这个数的第 k 位为1，代表 k+1 没出现过，也就是k+1可以填入格子。（`& 0x1ff` 是因为高于9的位没有意义）
- `b & (−b) = b & (~b + 1)` 可以保留最低的 1，其它全变为0
- `digit = bin(digitMask).count("0") - 1` ???用来计算最低位的1在第几位
- `b ^ (b & (-b)) = b & (b - 1)` 可以消去最低位的1，可以以此来枚举下一个 1


官方答案

```py
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        def flip(i: int, j: int, digit: int):
            line[i] ^= (1 << digit)
            column[j] ^= (1 << digit)
            block[i // 3][j // 3] ^= (1 << digit)
          line = [0] * 9


        column = [0] * 9
        block = [[0] * 3 for _ in range(3)]
        valid = [False]
        spaces = list()

        for i in range(9):
            for j in range(9):
                if board[i][j] == ".":
                    spaces.append((i, j))
                else:
                    digit = int(board[i][j]) - 1
                    flip(i, j, digit)

        def dfs(pos: int):
            if pos == len(spaces):
                valid[0] = True
                return

            i, j = spaces[pos]
            mask = ~(line[i] | column[j] | block[i // 3][j // 3]) & 0x1ff
            while mask:
                digitMask = mask & (-mask)
                digit = bin(digitMask).count("0") - 1
                flip(i, j, digit)
                board[i][j] = str(digit + 1)
                dfs(pos + 1)
                flip(i, j, digit)
                mask &= (mask - 1)
                if valid[0]:
                    return
        dfs(0)
```


## 38. Count and Say

简单，一遍过

```py
class Solution:
    def countAndSay(self, n: int) -> str:
        if n==1:
            return '1'

        tmp=self.countAndSay(n-1)
        res=[]
        curr_idx=0
        curr_cnt=0

        curr=tmp[curr_idx]

        for idx,char in enumerate(tmp):
            if char!=curr:
                res.append(str(curr_cnt)+curr)
                curr_cnt=0
                curr=tmp[idx]

            curr_cnt+=1

        res.append(str(curr_cnt)+curr)

        return ''.join(res)
```


## 39. Combination Sum

这题也简单，不过需要注意 `[2,2,3]` 和 `[2,3,2]` 算是同一个解，因此多引入一个变量，以判断和防止重复计入。


```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:

        candidates.sort()
        res_all=[]
        def comb_sum(candidates,last_used,target,res):
            if target<0:
                return
            if target==0:
                res_all.append(res)
                return
            if target>0:
                for candidate in candidates:
                    if candidate<last_used:
                        continue
                    last_used=candidate
                    comb_sum(candidates,last_used,target-candidate,res+[candidate])

        comb_sum(candidates,0,target,list())

        return res_all
```            

## 40. Combination Sum II


```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:

        candidates.sort()
        res_all=[]
        def comb_sum(candidates,target,res):
            if target<0:
                return
            if target==0:
                res_all.append(res)
                return

            if not candidates:
                return

            # if target>0:
            for idx,candidate in enumerate(candidates):
                new_candidates=candidates[idx+1:] if idx<len(candidates)-1 else []
                comb_sum(new_candidates,target-candidate,res+[candidate])

        comb_sum(candidates,target,[])

        # 去重
        res_all=set([tuple(i) for i in res_all])
        res_all=list([list(i) for i in res_all])

        return res_all
```

上面的答案有重复搜索，改为这个

```python
import collections

class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:

        candidates = [[i,j] for i,j in collections.Counter(candidates).items()]
        candidates.sort()

        res_all=[]
        def comb_sum(candidates,target,res):
            if target<0:
                return
            if target==0:
                res_all.append(res)
                return

            if not candidates:
                return

            # if target>0:
            for idx,[candidate,candidate_cnt] in enumerate(candidates):
                if candidate_cnt==0:
                    continue

                new_candidate=candidates[idx:]
                candidates[idx][1]-=1
                comb_sum(new_candidate,target-candidate,res+[candidate])
                candidates[idx][1]+=1


        comb_sum(candidates,target,[])
        return res_all
```


## 41. First Missing Positive

算作弊了

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        nums=list(set(nums))
        nums.sort()
        res=1
        for i in nums:
            if i<=0:
                continue
            if i==res:
                res+=1
                continue
            else:
                return res
        return res
```

## 42. Trapping Rain Water

直接思路
1. 左隔板为 left，寻找右边第一个大于 left 的隔板，记为 right
2. 如果右边都小小于 left，就寻找右边最大的隔板，记为left
3. 赋值 right = left，继续迭代。


想到之前有个隔板题，是从左到右遍历一次，然后从右往左遍历一次。因此想到，先把水填满，然后看看哪些流出去了。


（代码还可以优化）


```python3
class Solution:
    def trap(self, height: List[int]) -> int:
        max_height=max(height)
        total_water=max_height*len(height)-sum(height)
        left_min=-1
        for num in height:
            left_min=max(left_min,num)
            total_water-=(max_height-left_min)

        right_min=-1
        for num in height[::-1]:
            right_min=max(right_min,num)
            total_water-=(max_height-right_min)

        return total_water
```

## 43. Multiply Strings

```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        return str(int(num1)*int(num2))
```


## 44. Wildcard Matching

各种超时
```
"babbbbaabababaabbababaababaabbaabababbaaababbababaaaaaabbabaaaabababbabbababbbaaaababbbabbbbbbbbbbaabbb"
"b**bb**a**bba*b**a*bbb**aba***babbb*aa****aabb*bbb***a"
```

超时的原因是有些地方被反复计算了，用 functools.lru_cache 做缓存（击败5%）

```python
import functools


class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        @functools.lru_cache(maxsize=None, typed=False)
        def is_match(text,pattern):
            if pattern=='':
                return text==''

            if pattern=='*':
                return True

            if text=='':
                return False


            if pattern[0]=='?':
                return is_match(text[1:],pattern[1:])
            elif pattern[0]=='*':
                return is_match(text,pattern[1:]) or is_match(text[1:],pattern)
            else:
                return text[0]==pattern[0] and is_match(text[1:],pattern[1:])

        p_list=[]
        last_is_star=False
        for i in p:
            if i=='*':
                if last_is_star:
                    last_is_star=True
                    continue
                else:
                    p_list.append(i)
                    last_is_star=True
            else:
                p_list.append(i)
                last_is_star=False

        p=''.join(p_list)


        return is_match(s,p)
```


下面这个用了dp方法，不会超时
```py
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)

        dp = [[False] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = True
        for i in range(1, n + 1):
            if p[i - 1] == '*':
                dp[0][i] = True
            else:
                break

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == '*':
                    dp[i][j] = dp[i][j - 1] | dp[i - 1][j]
                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]

        return dp[m][n]
```

## 45. Jump Game II

动态规划基本题目，注意0

```python3
class Solution:
    def jump(self, nums: List[int]) -> int:
        len_nums=len(nums)
        dp=[0]*len_nums

        for i in range(len(nums)-2,-1,-1):
            # print(dp)
            if nums[i]==0:
                dp[i]=100000
            else:
                dp[i]=min(dp[i+1:i+nums[i]+1])+1

        return dp[0]
```

## 46. Permutations

用工具很方便
```
itertools.permutations(nums)
```

工具和递归的效率差不多，
- 对nums做回溯（+递归），sep 左边代表已经填入的，右边代表待填入的




```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:

        def permute_func(sep):
            if sep==len(nums):
                return res.append(nums.copy())

            for idx in range(sep,len(nums)):
                nums[idx],nums[sep]=nums[sep],nums[idx]
                permute_func(sep+1)
                nums[idx],nums[sep]=nums[sep],nums[idx]


        len_nums=len(nums)
        res=[]
        permute_func(0)
        return res
```




## 47. Permutations II

照抄上一题，在结果中去重：

```py
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res=set()
        len_nums=len(nums)
        def permute(sep):
            if sep==len_nums:
                res.add(tuple(nums))

            for idx in range(sep,len_nums):
                nums[idx],nums[sep]=nums[sep],nums[idx]
                permute(sep+1)
                nums[idx],nums[sep]=nums[sep],nums[idx]

        permute(0)
        return [list(i) for i in res ]
```

!!!还有性能更高的做法，待研究


## 48. Rotate Image

第一次不是很容易想到这个：
- 旋转90度不容易，但是
- 上下镜像、左右镜像、主对角线镜像是容易实现的

```python3
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n=len(matrix)


        for i in range(n):
            for j in range(i):
                matrix[i][j],matrix[j][i]=matrix[j][i],matrix[i][j]

        for i in range(n):
            matrix[i]=matrix[i][::-1]
```


## 49. Group Anagrams

简单，sort即可

```python3
import collections

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res=collections.defaultdict(list)
        for term in strs:
            res[''.join(sorted(term))].append(term)
        return list(res.values())
```


## 50. Pow(x, n)


`x**n` (开个玩笑)

```python3
class Solution:
    def myPow(self, x: float, n: int) -> float:
        def my_pow(x,n):
            if n==1:
                return x
            if n==0:
                return 1
            if n==-1:
                return 1/x

            tmp=my_pow(x,n//2)
            return tmp*tmp*my_pow(x,n%2)

        return my_pow(x,n)
```

递归调用会使用栈空间，因此，时间复杂度 $\log n$，空间复杂度 $\log n$

用位运算，可以把空间复杂度降低到 $\log n$，本质上是计算 $2^{k0} \times 2^{k1} \times 2^{k2} \times ...$


```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        def my_pow(n):
            res=1
            val=x
            while n:
                n,k=divmod(n,2)
                if k:
                    res*=val
                val*=val
            return res
        return my_pow(n) if n>=0 else 1/my_pow(-n)
```


## 51. N-Queens

回溯法典型题目，!!! 多练习几遍
```python
class Solution:
    def solveNQueens(self, n: int):
        col = [0] * n
        diagonal_1 = [0] * (2 * n - 1) # 副对角线
        diagonal_2 = [0] * (2 * n - 1) # 对角线
        solution = [[0] * n for i in range(n)]
        res = []
        chars = {0: '.', 1: 'Q'}

        def n_queens(col, diagonal_1, diagonal_2, solution, i):
            if i == n:
                res.append([''.join([chars[i] for i in line]) for line in solution])
                return

            for j in range(n):
                if col[j] or diagonal_1[i + j] or diagonal_2[i - j + n - 1]:
                    continue

                col[j] = diagonal_1[i + j] = diagonal_2[i - j + n - 1] = solution[i][j] = 1
                n_queens(col, diagonal_1, diagonal_2, solution, i + 1)
                col[j] = diagonal_1[i + j] = diagonal_2[i - j + n - 1] = solution[i][j] = 0

        n_queens(col, diagonal_1, diagonal_2, solution, 0)

        return res
```


## 52. N-Queens II

跟上面的题一样

```python
class Solution:
    def totalNQueens(self, n: int) -> int:
        res=[0]

        cols=[0]*n
        diag_1=[0]*(2*n-1)
        diag_2=[0]*(2*n-1)

        def n_queens(cols,diag_1,diag_2,i):
            if i==n:
                res[0]+=1
                return

            for j in range(n):
                if cols[j] or diag_1[i+j] or diag_2[i-j+n-1]:
                    continue
                cols[j]=diag_1[i+j] =diag_2[i-j+n-1]=1
                n_queens(cols,diag_1,diag_2,i+1)
                cols[j]=diag_1[i+j] =diag_2[i-j+n-1]=0

        n_queens(cols,diag_1,diag_2,0)

        return res[0]
```

## 53. Maximum Subarray

好题！

不容易想出来：
- `f(i)` 定义为：第 i 位结尾的最大序列，因此 `f(i) = max(f(i-1)+nums[i], nums[i])`
- 然后求 `max(f(i))` 即可
- 下面的代码中，把 `f(i)` 写到 nums 中，以节省内存空间

```python3
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        for i in range(1,len(nums)):
            if nums[i-1]>0:
                nums[i]=nums[i-1]+nums[i]

        return max(nums)
```



## 54. Spiral Matrix

- 想到像削苹果一样，每次旋转90度，削头
- `list(zip(*matrix))` 是按照主对角线反转，配合 `::-1` 可以达到逆时针旋转。（这一步参考48题）

```python
def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        while matrix:
            # 削头（第一层）
            res += matrix.pop(0)
            # 将剩下的逆时针转九十度，等待下次被削
            matrix = list(zip(*matrix))[::-1]
        return res
```


!!!改进为 one line，非常惊艳！

```python
class Solution:
    def spiralOrder(self, matrix):
        return matrix and list(matrix.pop(0))+self.spiralOrder(list(zip(*matrix))[::-1])
```



如果pop结尾，会快很多。上下颠倒，每次削脚，然后顺时针旋转。

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        matrix.reverse()
        res=[]
        while matrix:
            res.extend(matrix.pop())
            matrix.reverse()
            matrix=list(zip(*matrix))
        return res
```

## 55. Jump Game

普通的dp方法

```
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        dp=[False]*len(nums)
        dp[0]=True
        for idx,num in enumerate(nums):
            if dp[idx]:
                if idx+num+1>=len(nums):
                    return True
                for i in range(idx+1,idx+num+1):
                    dp[i]=True

        return dp[-1]
```

不知道能不能改进

## 56. Merge Intervals

简单，按照字面意思做

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        res=[intervals[0]]

        for i in range(1,len(intervals)):
            if res[-1][1]>=intervals[i][0]:
                if res[-1][1]<intervals[i][1]:
                    res[-1][1]=intervals[i][1]
            else:
                res.append(intervals[i])

        return res
```


##


直白的if-else
```python
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        if not intervals:
            return [newInterval]
        res=[]

        has_insert_new=False
        for interval in intervals:
            if interval[1]<newInterval[0]:
                res.append(interval)
            elif interval[0]>newInterval[1]:
                if not has_insert_new:
                    res.append(newInterval)
                    has_insert_new=True
                res.append(interval)
            else:
                if not has_insert_new:
                    res.append(newInterval)
                    has_insert_new=True
                newInterval[0]=min(newInterval[0],interval[0])
                newInterval[1]=max(newInterval[1],interval[1])

        if not has_insert_new:
            res.append(newInterval)

        return res
```
O(n) 复杂度

感觉直接抄上一题也就 nlog(n) 复杂度


## 58. Length of Last Word

```python
class Solution:
    def lengthOfLastWord(self, s: str) -> int:

        meet_word=False
        res=0
        for idx in range(len(s)-1,-1,-1):
            if s[idx]==' ':
                if meet_word:
                    return res
                else:
                    continue
            else:
                meet_word=True
                res+=1
        return res
```


## 59. Spiral Matrix II

复用 Spiral Matrix I 那个题
- 先用一个矩阵填入连续数字
- 然后展开它，以此确定展开顺序，并记下来
- 按照上一步计算好的展开顺序，对结果矩阵填充

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        matrix=[list(range(i*n,(i+1)*n)) for i in range(n)]


        matrix_copy=matrix.copy()
        spiral=[]
        while matrix_copy:
            spiral.extend(matrix_copy.pop(0))
            matrix_copy=list(zip(*matrix_copy))[::-1]

        helper=dict(zip(spiral,range(1,n*n+1)))

        for i in range(n):
            for j in range(n):
                matrix[i][j]=helper[matrix[i][j]]


        return matrix
```

顺着旋转的思路，可以进一步简化代码

```py
class Solution:
    def generateMatrix(self, n: int):
        res, lo = [], n * n + 1
        while lo > 1:
            lo, hi = lo - len(res), lo
            res = [list(range(lo, hi))] + [list(line) for line in zip(*res[::-1])]
        return res
```


## 60. Permutation Sequence

下面是抄的，太漂亮了

```python
class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        factorial=[1]
        for i in range(1,n):
            factorial.append(factorial[-1]*i)

        res=[]
        k-=1
        nums=list(range(1,n+1))
        for mul in factorial[::-1]:
            div,k=divmod(k,mul)
            res.append(str(nums.pop(div)))

        return ''.join(res)
```


## 73. Set Matrix Zeroes

```python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        rows=[all(line) for line in matrix]
        cols=[all(col) for col in zip(*matrix)]
        len_rows,len_cols=len(rows),len(cols)


        for idx,col in enumerate(cols):
            if col==0:
                for i in range(len_rows):
                    matrix[i][idx]=0

        for idx,row in enumerate(rows):
            if row==0:
                matrix[idx]=[0]*len_cols
```

## 766. Toeplitz Matrix

矩阵基础题。存储每个斜线的情况即可，也可以用位存储。
```python
class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        m,n=len(matrix),len(matrix[0])
        val=[None]*(m+n-1)
        for i in range(m):
            for j in range(n):
                if val[j-i+m-1] is None:
                    val[j-i+m-1]=matrix[i][j]
                else:
                    if  val[j-i+m-1]!=matrix[i][j]:
                        return False
        return True
```

## 867. Transpose Matrix

基础题了

```
return list(zip(*matrix))
```


## 542. 01 Matrix

dp方法
- f(i,j) 定义为 i,j 到 0 的最近距离
- 如果 `matrix[i][j]=0`，那么 `f(i,j) = 0`
- 否则 `f(i,j)=min(f(i-1,j) ,f(i,j-1), f(i+1,j), f(i,j+1))+1`
- 上面的迭代公式需要从4个方向向 i,j 计算
- 实际上可以简化位2个方向



```python
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        h,w=len(mat),len(mat[0])

        dp=[[10000]*w for i in range(h)]
        for i in range(h):
            for j in range(w):
                if mat[i][j]==0:
                    dp[i][j]=0

        for i in range(h):
            for j in range(w):
                if i-1>=0:
                    dp[i][j]=min(dp[i][j],dp[i-1][j]+1)
                if j-1>=0:
                    dp[i][j]=min(dp[i][j],dp[i][j-1]+1)

        for i in range(h-1,-1,-1):
            for j in range(w-1,-1,-1):
                if i+1<h:
                    dp[i][j]=min(dp[i][j],dp[i+1][j]+1)
                if j+1<w:
                    dp[i][j]=min(dp[i][j],dp[i][j+1]+1)
        return dp
```

## 1975. Maximum Matrix Sum

这题简单：
- 负号可以任意沿行/列移动
- 每行偶数个负数字可以抵消，列也是
- 如果全部偶数个负数，返回和
- 如有有奇数个负数，转化为有1个负数，找到绝对值最小的那个即可



```python
class Solution:
    def maxMatrixSum(self, matrix: List[List[int]]) -> int:
        h,w=len(matrix),len(matrix[0])
        neg_is_odds=True
        for i in range(h):
            for j in range(w):
                if matrix[i][j]<0:
                    neg_is_odds=not neg_is_odds

        res=0
        for i in range(h):
            for j in range(w):
                res+=abs(matrix[i][j])

        if neg_is_odds:
            return res
        else:
            min_num=100001
            for i in range(h):
                for j in range(w):
                    if min_num>abs(matrix[i][j]):
                        min_num = abs(matrix[i][j])
            return res-2*min_num

```


## 面试题 01.07. Rotate Matrix LCCI

经典的旋转题，都会背了

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        res=list(zip(*matrix[::-1]))
        n=len(matrix)
        for i in range(n):
            for j in range(n):
                matrix[i][j]=res[i][j]
```

## 519. Random Flip Matrix

思路：
- 维护一个 dict，每个已经被筛选到的，映射到还没有被筛选到的
- 下次如果还选到它，就选择它映射到的
- `ranint(idx)` 中的 `idx--`，以减少搜索区域

```python
import random

class Solution:

    def __init__(self, m: int, n: int):
        self.m = m
        self.n = n
        self.idx = m * n
        self.map = {}

    def flip(self) -> List[int]:
        self.idx -= 1
        x = random.randint(0, self.idx)
        new = self.map.get(x, x)
        self.map[x] = self.map.get(self.idx, self.idx)
        return divmod(new,self.n)

    def reset(self) -> None:
        self.idx = self.m * self.n
        self.map.clear()
```


不过话说用随机性出题就很屑，卡bug就行

```python
class Solution:
    def __init__(self, m: int, n: int):
        self.mn = m*n
        self.n = n
        self.idx = 0

    def flip(self) -> List[int]:
        self.idx+=1
        if self.idx>=self.mn:
            self.idx=0
        return divmod(self.idx,self.n)

    def reset(self) -> None:
        pass
```

## 566. Reshape the Matrix

作弊

```python
class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        if r*c==len(mat)*len(mat[0]):
            return np.array(mat).reshape(r,c).tolist()
        return mat
```


正经做也简单

```py

class Solution:
    def matrixReshape(self, mat, r: int, c: int):
        h, w = len(mat), len(mat[0])
        if h * w != r * c:
            return mat

        res = [[None] * c for i in range(r)]
        for idx in range(h * w):
            new_i, new_j = divmod(idx, c)
            old_i, old_j = divmod(idx, w)
            res[new_i][new_j] = mat[old_i][old_j]

        return res
```

## 1572. 矩阵对角线元素的和

简单，一步过

```python
class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        res=0
        n=len(mat)
        for i in range(n):
            res+=mat[i][i]
            if i!=n-i-1:
                res+=mat[i][n-i-1]

        return res
```

## 面试题 01.08. Zero Matrix LCCI

```python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        h,w=len(matrix),len(matrix[0])
        row_not_0=[all(row) for row in matrix]
        col_not_0=[all(col) for col in zip(*matrix)]
        for idx,val in enumerate(row_not_0):
            if not val:
                matrix[idx]=[0]*w

        for idx,val in enumerate(col_not_0):
            if not val:
                for i in range(h):
                    matrix[i][idx]=0
```


## 885. Spiral Matrix III

!!! 此题是旋转类的典型题

和1/2差别是：
- 1从外环向内旋转，提取
- 2也是从外环向内旋转，填入
- 3从内向外旋转。似乎下面的方法在1/2里面也能用，但1/2的旋转矩阵法就不那么通用了



```python
class Solution:
    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
        res=[]
        direction=[(0,1),(1,0),(0,-1),(-1,0)] # 顺时针
        left,right,upper,bottom=cStart-1,cStart+1,rStart-1,rStart+1 # 边界
        x,y,num,direct=rStart,cStart,0,0
        while num<rows*cols:
            if x>=0 and x<rows and y>=0 and y<cols:
                res.append([x,y])
                num+=1

            # 遇到边界
            if direct==0 and y==right:
                direct=1
                right+=1
            elif direct==1 and x==bottom:
                direct=2
                bottom+=1
            elif direct==2 and y==left:
                direct=3
                left-=1
            elif direct==3 and x==upper:
                direct=0
                upper-=1
            x+=direction[direct][0]
            y+=direction[direct][1]

        return res
```


## 74. Search a 2D Matrix

二分法基础题，做一遍熟悉一下公式

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        h,w=len(matrix),len(matrix[0])
        left,right=0,h*w-1

        while left<right:
            mid =(left+right)//2
            i,j=divmod(mid,w)
            if matrix[i][j]<target:
                left=mid+1
            elif matrix[i][j]>target:
                right=mid-1
            elif matrix[i][j]==target:
                return True

        mid=left

        i,j=divmod(mid,w)
        # print(mid,i,j)
        return matrix[i][j]==target
```


## 240. Search a 2D Matrix II




这个题一开始想用二分法，做了很久之后发现二分法不成立。下面是抄的（感觉这思路耦合性很大）


从左下角开始
- 数值小，则往右
- 数值大，则往上


```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix:
            return False
        if not matrix[0]:
            return False

        h,w=len(matrix),len(matrix[0])
        i,j=h-1,0
        while i>=0 and j<w:
            if matrix[i][j]>target:
                i-=1
            elif matrix[i][j]<target:
                j+=1
            else:
                return True
        return False
```


## 面试题 10.09. Sorted Matrix Search LCCI

与 240. Search a 2D Matrix II 一样的题

## 1329. Sort the Matrix Diagonally

非常直白，不知道还有没有更好的方法


```python
class Solution:
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        h,w=len(mat),len(mat[0])
        res=[[None]*w for i in range(h)]
        for k in range(-(h-1),w):
            if k<=0:
                tmp_lst=list()
                i1,j1=-k,0

                while i1<h and j1<w:
                    tmp_lst.append(mat[i1][j1])
                    i1+=1
                    j1+=1

                tmp_lst.sort()
                i1,j1=-k,0
                l=0

                while i1<h and j1<w:
                    res[i1][j1]=tmp_lst[l]
                    l+=1
                    i1+=1
                    j1+=1

            if k>0:
                tmp_lst=list()
                i1,j1=0,k

                while i1<h and j1<w:
                    tmp_lst.append(mat[i1][j1])
                    i1+=1
                    j1+=1

                tmp_lst.sort()
                i1,j1=0,k
                l=0
                while i1<h and j1<w:
                    res[i1][j1]=tmp_lst[l]
                    l+=1
                    i1+=1
                    j1+=1
        return res
```



## 861. Score After Flipping Matrix

思路：
- 先反转行，使得第一列全1
- 然后对每列，反转使1多于0
- 进一步的，有些步骤不需要真的反转矩阵。

```py
class Solution:
    def matrixScore(self, grid: List[List[int]]) -> int:
        h,w=len(grid),len(grid[0])
        for i in range(h):
            if grid[i][0]==0:
                for j in range(w):
                    grid[i][j]=1-grid[i][j]

        res=sum(grid[i][0] for i in range(h))

        for col in range(1,w):
            num_of_one=sum(grid[i][col] for i in range(h))
            if num_of_one<=h//2:
                for i in range(h):
                    grid[i][col]=1-grid[i][col]

            res=res<<1
            res+=(sum(grid[i][col] for i in range(h)))

        return res
```

其实第二步，矩阵不用真的反转

```py
class Solution:
    def matrixScore(self, grid: List[List[int]]) -> int:
        h,w=len(grid),len(grid[0])
        for i in range(h):
            if grid[i][0]==0:
                for j in range(w):
                    grid[i][j]=1-grid[i][j]

        res=h

        for col in range(1,w):
            num_of_one=sum(grid[i][col] for i in range(h))
            res=res<<1
            res+=(max(num_of_one,h-num_of_one))

        return res
```


## 1632. Rank Transform of a Matrix

并查集+拓扑排序，之后做


https://leetcode-cn.com/problems/rank-transform-of-a-matrix/submissions/



## 1380. Lucky Numbers in a Matrix

不想用暴力搜索，所以推导一下得到更好的解法。

1. 可以证明，结果必然是唯一的
2. 那么结果必然是行最小和列最大的交集


```
class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        min_row={min(row) for row in matrix}
        max_col={max(col) for col in zip(*matrix)}
        return list(min_row&max_col)
```


##

!!!BFS 类似level order 的做法一定要会背。另外要知道这种方法是从 queue 而来的


```
class Solution:
    def shortestPathBinaryMatrix(self, grid) -> int:
        if grid[0][0] != 0:
            return -1

        h, w = len(grid), len(grid[0])

        if grid[h - 1][w - 1] != 0:
            return -1

        for i in range(h):
            for j in range(w):
                if grid[i][j] == 1:
                    grid[i][j] = None

        queue = [(0, 0)]
        grid[0][0] = 1
        level = 1

        while queue:
            new_queue = []
            for idx_i, idx_j in queue:
                if idx_i == h - 1 and idx_j == w - 1:
                    return level

                for diff_i, diff_j in ((1, 1), (-1, -1), (1, -1), (-1, 1), (0, 1), (1, 0), (0, -1), (-1, 0)):
                    new_i, new_j = idx_i + diff_i, idx_j + diff_j
                    if 0 <= new_i < h and 0 <= new_j < w and grid[new_i][new_j] == 0:
                        grid[new_i][new_j] = level
                        new_queue.append((new_i, new_j))

            queue = new_queue
            level += 1
        return -1
```

改矩阵的方法感觉不太美观，可以用一个 visited 变量来记录是否已经访问到。不过那样内存消耗就多了一点


##

bfs
- 还是需要用set来存放 visited，而不是直接判断 res，否则容易超时

```py
class Solution:
    def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int):
        queue, res,visited = {(rCenter, cCenter)}, [(rCenter, cCenter)],{(rCenter, cCenter)}

        while queue:
            # print(queue)
            new_queue = set()
            for idx_i, idx_j in queue:
                for diff_i, diff_j in ((-1, 0), (1, 0), (0, 1), (0, -1)):
                    new_i, new_j = idx_i + diff_i, idx_j + diff_j
                    if 0 <= new_i < rows and 0 <= new_j < cols and (new_i, new_j) not in visited:
                        new_queue.add((new_i, new_j))
            queue = new_queue
            res.extend(queue)
            visited.update(queue)

        return res

```

方法2:直接全部计算，然后sort，速度更快（以为这样很慢的）

```
class Solution:
    def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int):
        dist_dict = dict()
        for i in range(rows):
            for j in range(cols):
                dist_dict[(i, j)] = abs(i - rCenter) + abs(j - cCenter)

        return sorted(dist_dict, key=lambda x: dist_dict[x])
```


简化一下，也就两行，哈哈哈

```py
class Solution:
    def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int):
        dist_dict = {(i, j): abs(i - rCenter) + abs(j - cCenter) for i in range(rows) for j in range(cols)}
        return sorted(dist_dict, key=lambda x: dist_dict[x])
```


## 1253. Reconstruct a 2-Row Binary Matrix

BFS总是超时，所以用直白方法输出一个解


```py

class Solution:
    def reconstructMatrix(self, upper: int, lower: int, colsum):

        if upper + lower != sum(colsum):
            return []

        num_2, num_1, num_0, len_res = colsum.count(2), colsum.count(1), colsum.count(0), len(colsum)

        if upper - num_2 < 0 or lower - num_2 < 0:
            return []

        upper_num_1 = upper - num_2
        lower_num_1 = lower - num_2

        if upper_num_1 < 0 or lower_num_1 < 0 or upper_num_1 + lower_num_1 + num_2 + num_0 != len_res:
            return []

        res = []

        for i in colsum:
            if i == 2:
                res.append([1, 1])
            elif i == 0:
                res.append([0, 0])
            elif i == 1:
                if upper_num_1 > 0:
                    res.append([1, 0])
                    upper_num_1 -= 1
                else:
                    res.append([0, 1])

        return list(zip(*res))
```


## 1582. Special Positions in a Binary Matrix

很直白

```py
class Solution:
    def numSpecial(self, mat: List[List[int]]) -> int:
        h,w=len(mat),len(mat[0])
        col_is_good=[None]*w

        res=0
        for i,row in enumerate(mat):
            if sum(row)==1:
                j=row.index(1)

                if col_is_good is None:
                    continue

                if sum(mat[i_1][j] for i_1 in range(h))>1:
                    col_is_good[j]=False
                    continue

                res+=1
        return res
```


## 378. Kth Smallest Element in a Sorted Matrix

```python
import heapq


class Solution:
    def kthSmallest(self, matrix, k: int) -> int:
        n = len(matrix)
        heap = matrix[0] + [matrix[i][0] for i in range(1, n)]
        heapq.heapify(heap)

        for i in range(1, n):

            k_smallest = heapq.nsmallest(k, heap)

            if len(k_smallest) == k and matrix[i][i] > k_smallest[-1]:
                return k_smallest[k - 1]

            for val in matrix[i][i:]:
                heapq.heappush(heap, val)
            for i1 in range(i + 1, n):
                heapq.heappush(heap, matrix[i1][i])

        k_smallest = heapq.nsmallest(k, heap)

        return k_smallest[k - 1]
```

## 1337. The K Weakest Rows in a Matrix

直接用 heapq

```py
import heapq

class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        res = heapq.nsmallest(k, iterable=[(i, sum(mat[i])) for i in range(len(mat))], key=lambda x: x[1])
        return list(zip(*res))[0]
```


## 1252. Cells with Odd Values in a Matrix

以下情况：
1. 初始为偶数：如果一行只有一个，那么这一个仍是偶数，其它都变成奇数。
2. 如果一行有2个，这两个是奇数，其它仍然是偶数。
3. 也就是说，如果一行有奇数个，有数的全是偶数，其它全是奇数。一行有偶数个，有数的是奇数，其它全是偶数。

（以上作废，是我想复杂了）直白的做就行了


```
class Solution:
    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
        res=[[0]*n for i in range(m)]
        for (idx_i,idx_j) in indices:
            for i in range(m):
                res[i][idx_j]=1-res[i][idx_j]
            for j in range(n):
                res[idx_i][j]=1-res[idx_i][j]

        return sum(sum(row) for row in res)
```


## 1351. Count Negative Numbers in a Sorted Matrix


```python
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        return sum(sum(i < 0 for i in row) for row in grid)
```


## 1594. Maximum Non Negative Product in a Matrix

0. 求全局值，所以用bfs而不是dfs
1. 有个边界条件是格子里面可以为0，因此如果按照无0做的结果是空，并且有0，那么有个保底解是0
2. 结果要取模
3. queue要用set


```python
class Solution:
    def maxProductPath(self, grid) -> int:
        h, w = len(grid), len(grid[0])

        queue = {(0, 0)}
        val = {(0, 0): [grid[0][0]]}

        def get_max(point_val, next_point, next_point_val):
            tmp = [i * next_point for i in point_val] + next_point_val
            tmp_min, tmp_max = min(tmp), max(tmp)
            if tmp_min < 0:
                if tmp_max >= 0:
                    return [tmp_min, tmp_max]
                if tmp_max < 0:
                    return [tmp_min]
            return [tmp_max]

        while queue:
            new_queue = set()
            for point in queue:
                for diff in ((1, 0), (0, 1)):
                    next_point = point[0] + diff[0], point[1] + diff[1]
                    if 0 <= next_point[0] < h and 0 <= next_point[1] < w:
                        val[next_point] = get_max(val[point], grid[next_point[0]][next_point[1]],
                                                  val[next_point] if next_point in val else list())


                        new_queue.add(next_point)
            queue = new_queue

        max_last_val = max(val[(h - 1, w - 1)])

        if max_last_val >= 0:
            return max_last_val%(10**9+7)
        else:

            for i in range(h):
                for j in range(w):
                    if grid[i][j] == 0:
                        return 0

            return -1
```


## 1605. Find Valid Matrix Given Row and Column Sums

```
class Solution:
    def restoreMatrix(self, rowSum, colSum):

        def get_matrix(rowSum, colSum):
            h, w = len(rowSum), len(colSum)
            if h == 0:
                return []
            num = rowSum[0]
            row = [0] * w
            i = 0
            while num > 0:
                # 贪心填充一行
                if num <= colSum[i]:
                    row[i] = num
                    colSum[i] -= num
                    num = 0
                else:
                    row[i] = colSum[i]
                    num -= colSum[i]
                    colSum[i] = 0
                i += 1

            return [row] + get_matrix(rowSum[1:], colSum)

        return get_matrix(rowSum, colSum)

```


## 1886. Determine Whether Matrix Can Be Obtained By Rotation

旋转类的基本题了，一次成型

```
class Solution:
    def findRotation(self, mat, target) -> bool:
        def rotate(mat):
            return list(zip(*mat))[::-1]

        target = [tuple(row) for row in target]
        mat_new = mat
        for i in range(4):
            mat_new = rotate(mat_new)
            if mat_new == target:
                return True

        return False
```


## 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix


！！！好题，想到这些：
1. 如果某个解存在，那么其顺序任意调换不会影响结果
2. 某一个格子翻转两次等于不翻转。
3. 因此每个格子翻转1次或0次一定能得到答案。计算1的数量就能得到结果
4. DFS 可解了，但是有 $2^n$ 复杂度
5. 想到剪枝：如果某个格子附近都已经遍历过，但这个格子没有归0，那么这个分支不可能为解，剔除即可
6. 发现第二行开始，都被剪成1种可能性了，这样的话只需要回溯第一行，$2^w$复杂度




```py
class Solution:
    def minFlips(self, mat) -> int:
        h, w = len(mat), len(mat[0])
        n = h * w
        res = [None]

        def flip(i, j):
            for diff_i, diff_j in ((0, -1), (0, 0), (0, 1), (-1, 0), (1, 0)):
                new_i, new_j = i + diff_i, j + diff_j
                if 0 <= new_i < h and 0 <= new_j < w:
                    mat[new_i][new_j] ^= 1

        def dfs(cnt, flip_cnt):
            if res[0] is not None:
                return

            if cnt == n:
                if sum(sum(row) for row in mat) == 0:
                    res[0] = flip_cnt
                return

            idx_i, idx_j = divmod(cnt, w)
            if idx_i == 0:
                # 第一个可能路径：不反转
                dfs(cnt + 1, flip_cnt)

                if res[0] is not None:
                    return

                # 第二个可能路径：翻转。这里用回溯法
                flip(idx_i, idx_j)
                dfs(cnt + 1, flip_cnt + 1)
                flip(idx_i, idx_j)

            else:
                if mat[idx_i - 1][idx_j] == 0:
                    dfs(cnt + 1, flip_cnt)
                else:
                    flip(idx_i, idx_j)
                    dfs(cnt + 1, flip_cnt + 1)
                    flip(idx_i, idx_j)

        dfs(0, 0)
        return res[0] if res[0] is not None else -1
```

## 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows


暴力吧
- 为了剪枝，每次迭代只取前k个即可（我咋没想到）
