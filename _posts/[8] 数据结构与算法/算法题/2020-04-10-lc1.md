---
layout: post
title: 【LeetCode】100～200题
categories:
tags: 0x81_数据结构与算法
keywords:
description:
order: 595
---


## 100. Same Tree

递归基础题，需要练

```py
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        if p.val!=q.val:
            return False
        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)
```


## 101. Symmetric Tree

跟上一个题一模一样

```py
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def is_symm(left,right):
            if left is None and right is None:
                return True
            if left is None or right is None:
                return False
            if left.val!=right.val:
                return False
            return is_symm(left.left,right.right) and is_symm(left.right,right.left)

        if root is None:
            return True
        return is_symm(root.left,root.right)
```

## 102. Binary Tree Level Order Traversal

经典的 level order，也就是 BFS

```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        queue,res=[root],[]
        while queue:
            new_queue=[]
            res_tmp=[]
            for node in queue:
                if node is None:
                    continue
                res_tmp.append(node.val)
                new_queue.append(node.left)
                new_queue.append(node.right)
            queue=new_queue
            if res_tmp:
                res.append(res_tmp)
        return res
```

因为返回值 res[level] 这种格式，因此 DFS 也挺方便


## 103. Binary Tree Zigzag Level Order Traversal

先 level order ，然后奇数位倒置


```
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        res=[]
        queue=[root]

        while queue:
            new_queue=[]
            res_tmp=[]
            for node in queue:
                if node is None:
                    continue
                res_tmp.append(node.val)
                new_queue.append(node.left)
                new_queue.append(node.right)

            if res_tmp:
                res.append(res_tmp)
            queue=new_queue


        for i in range(len(res)):
            if i%2==1:
                res[i]=res[i][::-1]

        return res
```

## 104. Maximum Depth of Binary Tree

dfs+cache

```
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        res=[0]

        def dfs(node,num):
            if node is None:
                res[0]=max(res[0],num)
                return

            dfs(node.left,num+1)
            dfs(node.right,num+1)

        dfs(root,0)
        return res[0]
```

## 105～106

- Construct Binary Tree from Preorder and Inorder Traversal
- Construct Binary Tree from Inorder and Postorder Traversal

感觉要背下来

##

```
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        res=[]
        queue=[root]
        while queue:
            new_queue=[]
            res_tmp=[]
            for node in queue:
                if node is None:
                    continue
                res_tmp.append(node.val)
                queue.append(node.left)
                queue.append(node.right)

            queue=new_queue
            if res_tmp:
                res.append(res_tmp)

        return res[::-1]
```

## 108.


108.Convert Sorted Array to Binary Search Tree，基本题目了，不用背也会


```py
class Solution:
    def sorted2BST(self, nums):
        if not nums:
            return None
        mid = len(nums) // 2
        return TreeNode(val=nums[mid], left=self.sorted2BST(nums[:mid]), right=self.sorted2BST(nums[mid + 1:]))
```

109.Convert Sorted List to Binary Search Tree

答案也不贴了，用几个基本元素拼起来就行了



## 110. Balanced Binary Tree

一开始觉得是这样的：把所有节点的深度列出来，然后最大深度和最小深度相差1即可。但这样过不了测试，反例 `[1,2,3,4,5,6,null,8]` 被判断为否，测试用例应当为 True。

平衡二叉树的正式定义为：左子树和右子树深度相差不超过1，跟上面的理解有些差距



```py
# 错误解法
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        levels=[]
        def dfs(node,level):
            if node is None:
                levels.append(level)
                return

            dfs(node.left,level+1)
            dfs(node.right,level+1)


        dfs(root,0)

        return max(levels)<=min(levels)+1:
```


正确解法
```py
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        res=[True]

        def dfs(node):
            if res[0] is False:
                return
            if node is None:
                return 0

            left_depth=dfs(node.left)
            # None 代表已经全局判断为 False 了，无须再计算level
            if left_depth is None:
                return
            right_depth=dfs(node.right)
            if right_depth is None:
                return
            if abs(left_depth-right_depth)>1:
                res[0]=False
                return
            else:
                return max(left_depth,right_depth)+1

        dfs(root)
        return res[0]
```


## 111. Minimum Depth of Binary Tree

这题也是对定义理解问题，是叶子节点的level

dfs

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0


        res=[100000]

        def dfs(node,level):
            if node is None:
                return
            if node.left is None and node.right is None:
                res[0]=min(res[0],level)
                return
            else:
                dfs(node.left,level+1)
                dfs(node.right,level+1)

        dfs(root,1)
        return res[0]
```


## 112. Path Sum

就dfs
```
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        res=[]
        def dfs(node,path_sum):
            if node is None:
                return
            if node.left is None and node.right is None: # 到达叶子节点
                res.append(path_sum+node.val)

            dfs(node.left,path_sum+node.val)
            dfs(node.right,path_sum+node.val)

        dfs(root,0)
        return targetSum in res
```


忘了还能剪枝

```py
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        res=[False]
        def dfs(node,path_sum):
            if res[0]:
                return
            if node is None:
                return
            if node.left is None and node.right is None: # 到达叶子节点
                if path_sum+node.val==targetSum:
                    res[0]=True


            dfs(node.left,path_sum+node.val)
            dfs(node.right,path_sum+node.val)

        dfs(root,0)
        return res[0]
```


## 113. Path Sum II


还是 dfs

```py
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res=[]

        if root is None:
            return res

        def dfs(node,path,path_sum):
            if node is None:
                return
            if node.left is None and node.right is None:
                if path_sum+node.val==targetSum:
                    res.append(path+[node.val])
                    return

            dfs(node.left,path+[node.val],path_sum+node.val)
            dfs(node.right,path+[node.val],path_sum+node.val)

        dfs(root,[],0)
        return res
```
