---
layout: post
title: 【LeetCode】trie 前缀树
categories:
tags: 0x81_刷题
keywords:
description:
order: 595
visible: n
---



相关集合
- 书 https://leetcode-cn.com/leetbook/detail/trie/
- 题 https://leetcode-cn.com/tag/trie/problemset/


## 677. Map Sum Pairs


```python
import collections


class TrieNode:
    def __init__(self):
        self.children = collections.defaultdict(TrieNode)
        self.val = 0

class MapSum:

    def __init__(self):
        self.root = TrieNode()


    def insert(self, key: str, val: int) -> None:
        curr = self.root
        for char in key:
            curr=curr.children[char]

        curr.val=val


    def sum(self, prefix: str) -> int:
        curr=self.root
        for char in prefix:
            curr=curr.children[char]
            if curr is None:
                return 0

        res=0
        queue=[curr]
        while queue:
            new_queue=[]
            for item in queue:
                new_queue.extend(item.children.values())
                res+=item.val
            queue=new_queue
        return res
```


## 648. Replace Words

在模版上改一改
```py
import collections


class TrieNode:
    def __init__(self):
        # 如果字符是有限的，这里可以用 list 来存储。不用做hash更快
        self.children = collections.defaultdict(TrieNode)
        self.is_word = False
        self.whole_word=None


class Trie:

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        curr = self.root
        for char in word:
            curr = curr.children[char]
            # 要求只记录最短的，长的就不往里面塞了
            if curr.is_word:
                return
        curr.is_word = True
        curr.whole_word=word

    def search(self, word: str) -> bool:
        curr = self.root
        for char in word:
            curr = curr.children.get(char)
            if curr is None:
                return False
        return curr.is_word

    def startsWith(self, prefix: str) -> bool:
        curr = self.root
        for char in prefix:
            curr = curr.children.get(char)
            if curr is None:
                return False
        return True

    def in_start(self, sentence):
        curr = self.root
        for char in sentence:
            if char not in curr.children:
                return False
            curr = curr.children.get(char)
            if curr.is_word:
                return True
        return False

    def extract_prefix(self,sentence):
        curr = self.root
        for char in sentence:
            if char not in curr.children:
                return sentence
            curr = curr.children.get(char)
            if curr.is_word:
                return curr.whole_word
        return sentence





class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie=Trie()
        for word in dictionary:
            trie.insert(word)

        res=[]
        for s in sentence.split(' '):
            res.append(trie.extract_prefix(s))

        return ' '.join(res)
```        


## 211. Design Add and Search Words Data Structure


BFS

```py
class TrieNode:
    def __init__(self):
        self.children = dict()
        self.is_word = False

    def __repr__(self):
        return str(self.children.keys())


class WordDictionary:
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word: str) -> None:
        curr = self.root
        for char in word:
            if char not in curr.children:
                curr.children[char] = TrieNode()
            curr = curr.children[char]
        curr.is_word = True

    def search(self, word: str) -> bool:
        queue, idx = [self.root], 0
        while queue and idx < len(word):
            new_queue = []
            if word[idx] == '.':
                for curr in queue:
                    new_queue.extend(curr.children.values())
            else:
                for curr in queue:
                    if word[idx] in curr.children:
                        new_queue.append(curr.children[word[idx]])

            if not new_queue:
                return False

            queue = new_queue
            idx += 1

        if idx < len(word):
            return False
        for curr in queue:
            if curr.is_word:
                return True
        return False
```


dfs版本，不过效率低于 BFS

```py
class TrieNode:
    def __init__(self):
        self.children = dict()
        self.is_word = False


class WordDictionary:
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word: str) -> None:
        curr = self.root
        for char in word:
            if char not in curr.children:
                curr.children[char] = TrieNode()
            curr = curr.children[char]
        curr.is_word = True

    def search(self, word: str) -> bool:
        res = [False]

        def dfs(node, idx):
            if res[0]:
                return

            if idx == len(word):
                if node.is_word:
                    res[0] = True
                return

            if word[idx] == '.':
                for child in node.children.values():
                    dfs(child, idx + 1)
            else:
                if word[idx] in node.children:
                    dfs(node.children[word[idx]], idx + 1)

        dfs(self.root, 0)
        return res[0]
```
