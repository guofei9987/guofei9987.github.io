---
layout: post
title: 相似图片算法
categories: 开源
tags:
keywords:
description:
repo_name: img_similar
---






## 图片 Hash 类算法






### aHash（均值哈希算法，Average Hash Method）

是一种基于指纹的算法，可以用来快速检索


算法步骤
1. 缩小图片信息。
    - 像素：把图片缩放为 8x8 ，共 64 个像素
    - 颜色：把图片转为 64 级灰度
2. 计算图片的平均值
3. 比较64个像素值 和 平均值，大于等于记为1，否则记为0
4. 如此得到一个 长度为 64 的二进制，它就是这个图片的指纹


检索过程：
- 只需要对比指纹
- 使用 Hamming distance
- 如果不同的数量小于 5，说明很相似。如果多于10，说明两个图片不同


代码参考：http://www.ruanyifeng.com/blog/2011/07/imgHash.txt


算法特点
- 不受图片大小缩放、亮度攻击影响
- 对图片内容攻击，会让算法失效。例如图片上加些文字。
- 常用场景：根据缩略图，找对应哪个原图


### dHash（差值哈希算法）

算法步骤
1. 缩小图片信息
    - 像素：把图片缩放为 8x9 = 72 个像素
    - 颜色：把图片转为 64 级灰度
2. 同行相邻对比，像素值⼤于后⼀个像素值记作1，否则记作0
3. 如此得到一个 长度为 64 的二进制，它就是这个图片的指纹




### pHash（Perceptual hash algorithm，感知hash）

算法步骤
1. 缩小图片信息
    - 像素：把图片缩放为小图（大于 8x8，32x32）
    - 颜色：把图片转为 64 级灰度
2. 做 DCT，得到 32x32 大小的矩阵，它代表频域
3. 保留左上 8x8，这部分代表低频区域
4. 做 aHash







3个算法的比较
- 性能：`dHash = aHash > pHash`
- 抗攻击： aHash 可以完美应对缩放攻击、亮度攻击等，但如果添加了一些内容，会无能为力。但是 pHash 可以应对这种情况
- dHash 效果很多时候好于 aHash

|方案|性能|特点|
|--|--|--|
|aHash|高|
|dHash|高|
|pHash|稍低|抗平移、内容改变|




## SSIM（结构相似度）

是什么
- 是一种衡量两幅图像相似度的指标
- 从一幅图像中提取3个关键特征：亮度、对比度、结构
- 人类对像素的绝对亮度/颜色不敏感，但对边缘和纹理的位置非常敏感。 SSIM 通过主要关注边缘和纹理相似性来模仿人类感知。




$SSIM(x,y) = \dfrac{(2u_xu_y + c_1)(2\sigma_{xy}+c_2)}{(\mu_x^2+\mu_y^2+c_1)(\sigma_x^2+\sigma_y^2+c_2)}$


范围是 -1 到 1，当两张图片一模一样时，SSIM 的值为 1


## 直方图


算法步骤大致可以分为两步，
1. 根据源图像与候选图像的像素数据，生成各自直方图数据。
2. 使用第一步输出的直方图结果，运用巴氏系数（Bhattacharyya coefficient）算法，计算出相似程度值。


第一步直方图的计算有3种方式
- 对于灰度图像，初始化一个大小为256的直方图数组H，然后根据像素值完成频率分布统计
- RGB直方图方法1：三维直方图。
    - 3个颜色层各自做直方图，`bins = n`
    - 然后拼接起来，得到 `n + n + n` 长度的一个向量
- RGB直方图方法2：单一直方图。
    - 对一个像素，根据 bins 得到一个索引值。假设16等份，某像素点为 (0, 4, 13)，那么 `index = R + G*16 + B*16*16` 
    - `res[index] += 1`，最终得到一个 `n1 * n2 * n3` 长度的向量



第二步：巴氏系数计算， $\sum \sqrt {p_1 p_2}$



## SIFT（尺度不变特征转换，Scale-invariant feature transform）


SIFT 特征是基于物体上的一些局部外观的兴趣点而与影像的大小和旋转无关。对于光线、噪声、些微视角改变的容忍度也相当高。

SIFT算法的特点有：

1. SIFT特征是图像的局部特征，其对旋转、尺度缩放、亮度变化保持不变性，对视角变化、仿射变换、噪声也保持一定程度的稳定性；
2. 独特性（Distinctiveness）好，信息量丰富，适用于在海量特征数据库中进行快速、准确的匹配；
3. 多量性，即使少数的几个物体也可以产生大量的SIFT特征向量；
4. 高速性，经优化的SIFT匹配算法甚至可以达到实时的要求；
5. 可扩展性，可以很方便的与其他形式的特征向量进行联合。

SIFT算法可以解决的问题：
目标的自身状态、场景所处的环境和成像器材的成像特性等因素影响图像配准/目标识别跟踪的性能。而SIFT算法在一定程度上可解决：

1. 目标的旋转、缩放、平移（RST）
2. 图像仿射/投影变换（视点viewpoint）
3. 光照影响（illumination）
4. 目标遮挡（occlusion）
5. 杂物场景（clutter）
6. 噪声


SIFT算法的实质是在不同的尺度空间上查找关键点(特征点)，并计算出关键点的方向。SIFT所查找到的关键点是一些十分突出，不会因光照，仿射变换和噪音等因素而变化的点，如角点、边缘点、暗区的亮点及亮区的暗点等。 


Lowe将SIFT算法分解为如下四步：

1. 尺度空间极值检测：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于尺度和旋转不变的兴趣点。
2. 关键点定位：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。
3. 方向确定：基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。
4. 关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化。


## 参考资料

https://github.com/MashiMaroLjc/Learn-to-identify-similar-images

- [https://github.com/MashiMaroLjc/Learn-to-identify-similar-images](https://github.com/MashiMaroLjc/Learn-to-identify-similar-images)
- [https://github.com/nivance/image-similarity](https://github.com/nivance/image-similarity)




https://wenku.baidu.com/view/f4a9530a29f90242a8956bec0975f46527d3a79e.html?_wkts_=1679477730923&bdQuery=%E5%88%86%E7%89%87%E5%93%88%E5%B8%8C+%E7%9B%B8%E4%BC%BC%E5%BA%A6