---
layout: post
title: 【Java】入门笔记
categories:
tags: Python语法
keywords:
description:
order: 1014
---

## 知识点

Java特点
- Write once, run anywhere，跨平台能力
- 垃圾收集（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下不需要自己操心内存的分配和回收


- Java 程序执行过程。`.java`（代码）-(编译)->`.class`字节码文件-->`虚拟机`解释执行
- JDK： Java 开发工具包。包括两个组件：
    - 开发工具集，如Javac（编译器，把源程序转为字节码），
    - JRE（Java Runtime Environment）。包括JVM（Java Virtual Machine，Java虚拟机，是Java平台无关性的关键），Java核心类库和支持文件。


Java平台
- Java SE：Java 标准版，用来开发桌面程序。
- Java EE：Java 企业版，多了Web程序开发。
- Java ME：Java 微型版，用来移动设备开发。用的越来也少了。


## HelloWorld

```java
// HelloWorld.java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println(args[0]);
    }
}
```

```bash
javac HelloWorld.java # 用来生成 *.class 字节码
java HelloWorld Hello World # 执行代码，会输出 Hello，这是因为 Wrold 对应 args[1]
```


## 进阶知识点
对于 Java 平台的理解，可以从很多方面简明扼要地谈一下，例如：Java 语言特性，包括泛型、Lambda 等语言特性；基础类库，包括集合、IO/NIO、网络、并发、安全等基础类库。

JVM 的一些基础概念和机制，比如 Java 的类加载机制，常用版本 JDK（如 JDK 8）内嵌的 Class-Loader，例如 Bootstrap、 Application 和 Extension Class-loader；类加载大致过程：加载、验证、链接、初始化（这里参考了周志明的《深入理解 Java 虚拟机》，非常棒的 JVM 上手书籍）；自定义 Class-Loader 等。还有垃圾收集的基本原理，最常见的垃圾收集器，如 SerialGC、Parallel GC、 CMS、 G1 等，对于适用于什么样的工作负载最好也心里有数。这些都是可以扩展开的领域，我会在后面的专栏对此进行更系统的介绍。

当然还有 JDK 包含哪些工具或者 Java 领域内其他工具等，如编译器、运行时环境、安全工具、诊断和监控工具等。这些基本工具是日常工作效率的保证，对于我们工作在其他语言平台上，同样有所帮助，很多都是触类旁通的。


几个板块：
- Java 基础：Java 语言基本特性和机制
- Java 进阶：并发编程、Java 虚拟机等领域展开
- Java 应用开发扩展：从数据库编程、主流开源框架、分布式开发等，
- Java 安全基础：应用安全问题和处理方法
- Java 性能基础：掌握相关工具、方法论与基础实践。






## 工具安装

- JDK 去 oracle 官网下载。https://www.oracle.com/downloads/
- IDE 去 jetbrain 官网下载 IntelliJ IDEA https://www.jetbrains.com/
- 打开IDE，右键 new->Module, 然后开始编程



## 代码规范

- 大小写敏感
- 类名：每个单词的首字母大写，例如 MyFirstJavaClass 。
- 方法名：小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
- 变量名：规范同方法名
- 源文件名：源文件名必须和类名相同后缀为.java。
- 主方法入口：所有的Java 程序由public static void main(String[] args)方法开始执行。
- 注释方法类似 C

## 基本

```java
public class Puppy{
    int puppyAge;
    public Puppy(String name){
        // 这个构造器仅有一个参数：name
        System.out.println("Passed Name is :" + name );
    }

    public void setAge( int age ){
        puppyAge = age;
    }

    public int getAge( ){
        System.out.println("Puppy's age is :" + puppyAge );
        return puppyAge;
    }

    public static void main(String []args){
        /* 创建对象 */
        Puppy myPuppy = new Puppy( "tommy" );
        /* 通过方法来设定age */
        myPuppy.setAge( 2 );
        /* 调用另一个方法获取age */
        myPuppy.getAge( );
        /*你也可以像下面这样访问成员变量 */
        System.out.println("Variable Value :" + myPuppy.puppyAge );
    }
}
```

程序入口是main

## 数据类型

### 基本数据类型


6种数字类型，1种字符类型，1种布尔类型


|数据类型|说明|字节|最小值|最大值|默认值|例子|
|--|--|--|--|--|--|--|--|
|byte|8位，有符号，以二进制补码表示，整数|1|-128（-2^7）|127（2^7-1）|0|byte a = 100，byte b = -50|
|short|16位、有符号的以二进制补码表示的整数|2|-32768（-2^15）|32767（2^15 - 1）|0|short s = 1000，short r = -20000|
|int|32位、有符号的以二进制补码表示的整数|4|-2,147,483,648（-2^31）|2,147,483,647（2^31 - 1）|0|int a = 100000, int b = -200000|
|long|64位、有符号的以二进制补码表示的整数|8|约 -9E18（-2^63）|约 9E18（2^63 -1）|0L|long a = 100000L，long b = -200000L|
|float|单精度、32位、符合IEEE 754标准的浮点数，不能用来表示精确的值，如货币|4|||0.0f|float f1 = 234.5F,float f1 = 234.5|
|double|双精度、64位、符合IEEE 754标准的浮点数，不能表示精确的值，如货币|8|||0.0d|double d1 = 123.4, double d1 = 123D|
|boolean|只有两个取值：true和false|1|||false|boolean one = true|
|char|单一的16位Unicode字符|2|’\u0000’（即为0）|’\uffff’（即为65,535）||char letter = 'A'; char ch = 65;|

在赋值或初始化时，可以把“小的”类型赋值给“大的”类型，反过来不行。

进制
- 八进制：0开头，如037，056
- 十六进制：0x或0X开头，如 0x12ab
- 进制也可以指定类型，如 0x123L


### 常量

指不能改变的量
```java
final double PI = 3.1415927;
```

### 数组

```java
// DataType.java
public class DataType {
    public int a=1;
    public String b="dataType";

}


public class Main {

    public static void main(String[] args) {
        int arraySize = 5;
        DataType[] myArray = new DataType[arraySize]; // 定义了一个空 array
        System.out.println(myArray.getClass());

        // 第一种循环
        for (int i = 0; i < myArray.length; i++) {
            myArray[i] = new DataType(); // 填充这个空 array
        }


        // 数组作为输入和输出
        DataType[] myArray1 = myArrayFunc(myArray);

        // 第二种循环： foreach 循环
        for (DataType element : myArray1) {
            System.out.println(element.a);
        }


    }

    // 数组作为函数输入值 + 数组作为函数返回值
    public static DataType[] myArrayFunc(DataType[] inputs) {
        return inputs;
    }

}
```

以上代码展示了
- 如何创建一个 array
- 如何填充一个 array
- 两种循环方法
- array 如何作为函数的输入，如何作为函数的输出

```Java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Arrays;

public class Main {

    public static void main(String[] args) {
        int[] myArray1 = new int[5];
        int[] myArray2 = new int[5];
        for (int i = 0; i < 5; i++) {
            myArray1[i] = i;
            myArray2[i] = i;
        }

        // Arrays.equals 用来判断两个 array 是否完全相等
        boolean totalEqual = Arrays.equals(myArray1, myArray2);
        System.out.println(totalEqual);

        // Arrays.fill 用来用指定类型填充 array
        Arrays.fill(myArray1, 1);
        for (int elements : myArray1) {
            System.out.println(elements);
        }

        // Arrays.sort 用来升序排列
        Arrays.sort(myArray2);
        for (int elements : myArray2) {
            System.out.println(elements);
        }
    }
}
```

以上代码展示了一些 array 方法

### ArrayList


```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


public class Main {
    public static void main(String[] args) {
        List<Integer> myArray = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            myArray.add(i);
        }
        System.out.println(myArray);

        Iterator<Integer> nameIterator = myArray.iterator();

        // remove
        while (nameIterator.hasNext()) {
            Integer a = nameIterator.next();
            System.out.println(a);
            if (a == 3) {
                nameIterator.remove();
            }
            System.out.println(myArray);
        }

        // forEachRemaining()方法对集合中尚未由迭代器访问的每个元素执行操作。
        // 迭代器是一次性对象。不能重置。要再次遍历，需要创建一个新的Iterator。
        Iterator<Integer> nameIterator2 = myArray.iterator();
        nameIterator2.forEachRemaining(System.out::println);
    }
}
```

以上代码展示了
- 2种借用 iterator 的遍历方法
- remove 方法

### Set

```java
import java.util.HashSet; // HashSet
import java.util.LinkedHashSet; // 有序的 HashSet
import java.util.Set;

Set<String> s1 = new HashSet<>();

s1.add("About")
s1.remove("About")
```

集合操作
```java
// 并集，结果存到 s1
s1.add(s2);
// 交集，结果存到 s1
s1.retainAll(s2);
// 差集，结果存到 s1
s1.removeAll(s2);

// boolean 类型，是否是子集
s2.containsAll(s1)
```



## 循环

```java
while( 布尔表达式 ) {
	//循环内容
}

do {
       //代码语句
}while(布尔表达式);



for(初始化; 布尔表达式; 更新) {
    //代码语句
}


// 增强for语句：
for(声明语句 : 表达式)
{
   //代码句子
}

// 例子：
public class Test {

   public static void main(String args[]){
      int [] numbers = {10, 20, 30, 40, 50};

      for(int x : numbers ){
         System.out.print( x );
         System.out.print(",");
      }
      System.out.print("\n");
      String [] names ={"James", "Larry", "Tom", "Lacy"};
      for( String name : names ) {
         System.out.print( name );
         System.out.print(",");
      }
   }
}
```


break 用来跳出循环，continue 用来直接进入下次循环

## 分支结构

```java
if(布尔表达式)
{
   //如果布尔表达式为true将执行的语句
}


if(布尔表达式){
   //如果布尔表达式的值为true
}else{
   //如果布尔表达式的值为false
}


if(布尔表达式 1){
   //如果布尔表达式 1的值为true执行代码
}else if(布尔表达式 2){
   //如果布尔表达式 2的值为true执行代码
}else if(布尔表达式 3){
   //如果布尔表达式 3的值为true执行代码
}else {
   //如果以上布尔表达式都不为true执行代码
}
```

switch 语句

```java
switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
```


## 面向对象

一段例子
```java
// A.java
public class A {
    private int i;
    protected int j;

    public void func1() {
        System.out.println("Class A");

    }
}



// B.java
public class B extends A {
    public int z;

    public void func2(){
        super.func1(); // 注意这个 super 方法
        System.out.println("Class B");

    }

}

// C.java
public class C {

    public static void main(String []args){
        A a=new A();
        B b=new B();

        System.out.println("Hello world!");
        System.out.println(a instanceof A);
        System.out.println(b instanceof B);
        b.func1();

    }
}
```

- 重写 (Override)：子类可以写一个同名的方法，覆盖掉父类的同名方法。
    - 参数列表与被重写方法的参数列表必须完全相同。
    - 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
    - 子类方法的访问权限必须大于或等于父类方法的访问权限。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
    - 声明为 final 的方法不能被重写。
    - 声明为 static 的方法不能被重写，但是能够被再次声明。
    - 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
    - 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
    - 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
    - 构造方法不能被重写。
    - 如果不能继承一个方法，则不能重写这个方法。
    - 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 重载 (overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。


```Java
// 一个重载的例子
public class D {
    public void func(int a) {
        System.out.println("int");
    }

    public void func(String a) {
        System.out.println("String");
    }

    public static void main(String[] args) {
        D d = new D();
        d.func(1);
        d.func("1");
    }
}
```


## 参考资料

https://www.w3cschool.cn/java/
