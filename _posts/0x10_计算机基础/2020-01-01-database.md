---
layout: post
title: 数据库原理
categories: 学习中
tags: 
keywords:
description:
order: 105
---


## 初步

数据库：将信息规范化、电子化，而形成的库，以便快速有效的存储、检索、统计、管理


数据库系统，包括：
- 数据库（DB，Database）
- 数据库管理系统（DBMS，Database Management System）
- 数据库应用（DBAP，Database Application）
- 数据库管理员（DBA，Database Administrator）
- 计算机基本系统 


![caption: 数据库系统](/a/computer/database/overview.gif)



数据库管理系统，应该有什么功能？（用户角度）
- 数据库定义
    - DBMS 提供 **数据定义语言**（DDL，Data Definition Language）给用户
    - 用户使用 DDL 描述表格式
    - DBMS 按照用户描述，创建数据库和其中的 Table
- 数据库操纵
    - DBMS 提供 **数据操纵语言**（DML，Data Manipulation Language）
    - 用户使用 DML 描述所要进行的增、删、改、查等操作
    - DBMS 按照用户描述，执行这些操作
- 数据库使用
    - DBMS 提供 **数据控制语言**（DCL，Data Control Language）
    - 用户使用 DCL 描述其对数据库要实施的控制（用户访问权限）
    - DBMS 按照用户的描述，实际进行控制
- 数据库维护
    - DBMS 提供一系列程序给用户，这些程序提供了对数据库维护的各种功能
    - 用户使用这些程序对数据库维护
    - 数据库维护程序，一般由 DBA 使用和掌握



数据库管理系统，应该有什么功能？（系统角度）
- 语言编译器。把数据库语言，翻译成 DBMS 可执行的命令。如 DDL 编译器，DML 编译器，DCL 编译器
- 查询优化、查询实现。提高检索速度
- 数据库的存取、索引。提供在磁盘、磁带上的搞笑存取手段
- 通信控制。网络环境下的数据库操作与数据传输手段
- 事务管理。高可靠性，避免并发操作错误
- 故障恢复。数据库自动回复到故障发生前正确状态的手段。如备份、运行日志
- 安全性控制。避免非授权用户访问数据库
- 完整性控制。提供数据、数据操作正确性检查手段
- 数据字典管理。管理用户定义的信息
- 应用程序接口（API）：提供应用程序使用 DBMS 特定功能的手段
- 数据库数据装载、重组
- 数据库性能分析。统计运行过程中的各种性能数据，以便优化。


典型的 DBMS：
- Oracle
- MS SQL
- ...


## 数据库系统的结构抽象


DBMS 管理数据的三个层次
- External level（User level）。某一用户能够看到的数据，是全局数据的某一部分
- Conceptual level（Logic level）。全局角度理解的数据
- Internal level（Physical level）。存储在介质上的数据，含路径、存储方式、索引方式等

数据和模式的区别
- 数据（View/Data）。是数据本身。
- 模式（Schema）。数据的结构性信息。例如： `table_student(id char(8), name char(10))`


**三级模式**（对应上面的3个层次）
- External Schema。同义词：用户模式、外模式、局部模式
- Conceptual Schema。模式默认指的是 Conceptual Schema。同义词：全局模式、概念模式、逻辑模式
- Internal Schema。同义词：内模式、存储模式


**两层映像**
- E-C Mapping。External Schema 到 Conceptual Schema 的映射
- C-I Mapping。Conceptual Schema 到 Internal Schema 的映射

为什么要这样设计？
- 逻辑数据独立性。Conceptual Schema 变化时，可以不改变 External Schema，只需要改动 E-C Mapping
- 物理数据独立性。Internal Schema 变化时，可以不改变 Conceptual Schema，只需要改动 C-I Mapping



**数据模型**：
- 规定统一描述方式，包括数据结构、操作、约束。
- “数据模型”是“数据模式”的抽象，“数据模式”是数据本身的抽象
- 3种经典数据模型：
    - **关系模型**：表的形式组织数据
    - **层次模型**：树的形式组织数据 
    - **网状模型**：图的形式组织数据


数据库的演变
- 从文件系统到数据库
    - 文件系统的优点：用户（程序）不必考虑物理细节
    - 缺点：数据与程序耦合，需要在程序中定义数据的组织。
    - 因此需要一个专门的 DBMS 专门处理数据
- 从层次模型、网状模型，到关系数据库
    - 层次模型、网状模型，数据是用指针联系起来的，只能逐一操作。
    - 关系数据库不依赖指针、路径，理论基础完善
- 关系数据库到对象数据库
    - 关系第一范式：每个单元格只能有1个值
    - **对象关系数据库**：使用数据结构/面向对象特点，来封装那些不满足关系第一范式的数据（一个单元格有多行/多列的情况）。
    - **XML数据库**：半结构化数据库，把数据和数据的语义合并存储。是一种树型的数据组织形式。
- **ODBC**（Open Database Connection）/（Java 对应的是 JDBC）：一种数据库标准，可以让应用程序用统一的方式访问不同的数据库
- 新型数据库。在不同的领域，有不同的数据库。例如：与实时技术结合的实时数据库，与工程文件结合的工程数据库，与图像结合的图像数据库



## 关系数据库


关系模型三要素
- 基本结构：Relation/Table
- 操作（Relation Operator）
    - 基本操作：并（Union）、差（Difference）、广义积（Product）、选择（Selection）、投影（Projection）
    - 扩展操作：交（intersection）、连接（join）、除（Division）
- 完整性约束：实体完整性、参照完整性、用户自定义完整性


关系数据库：操作的对象是集合，一次一集合（Set-at-a-time）。层次模式、网状模型：操作对象是一次一记录（Record-at-a-time）


-----------------

一些定义

**Domain（域）**：列的取值范围集合，例如，性别这个字段的域就是 `{男, 女}`
    - **Cardinality（基数）**：集合的元素个数


**Cartesian Product（笛卡尔积）**，所有可能性的集合：
- 一组域 $D_1,D_2,...,D_n$ 的 笛卡尔积是：
- $D_1 \times D_2 \times ... \times D_n =\{ (d_1,d_2,...,d_n)\} \mid d_i \in D_i, i=1,...,n$
- 每个元素 $(d_1,d_2,...,d_n)$ 叫做 **n-元组（n-tuple）**
- 元组的每个值 $d_i$ 叫做 **分量（component）**

**关系（Relation）**：$D_1 \times D_2 \times ... \times D_n$ 的一个子集

**Schema** 用 $R(A_1:D_1, A_2:D_2,...,A_n:D_n)$ 表示
- 其中 R 是关系的名字
- $A_i$ 是属性名字
- $D_i$ 是域
- n 是关系的 **degree（度、目）**
- 例如 `Student(S# char(8), Sname char(10), Ssex char(2), Sage integer)`


关系的特性
- 列是同质的：数据类型相同（来自同一个域）
- 列名必须不同（$A_i$ 不同）
- 列位置可互换，行位置可互换。不靠位置索引号确定行/列。行/列互换后，仍然是同一个关系。
- 理论上，关系任意两个元组不能完全相同（因为它是集合）。实践上不一定完全遵守。
- 属性不可再分：**关系第一范式**
- **Candidate Key（候选码、候选键）**：关系中的一组属性，其值可以唯一标识一个元组。例如 `学生(S#,Sname,Sage,Sclass)` 中的 `S#` 是候选码；`选课记录(S#,C#,Sname,Cname,Grade)` 中的 `(S#,C#)` 是候选码。
    - 当然，候选码可以有多种，可以选定其中的一个作为 **主码**，例如上面选课记录中的 `(S#,C#)`
    - 任何候选码中都有的属性叫做 **主属性**，例如上面的 `C#` 和 `S#`，其它都是 **非主属性**
    - 最简单的：候选码只有一个属性。最极端的：全部属性都是主属性（成为全码 All-Key）
- **Foreign Key**（外码/外键）：关系R的一个属性组，它不是R的候选码，但它是另一关系 S 的候选码。
    - 例如：“合同”关系中的“客户号”不是候选码，但它是“客户”关系中的候选码
    - 两个关系靠 外码 连接起来


![caption: 符合第一范式](/a/computer/database/1nf.svg)

![caption: 不符合第一范式](/a/computer/database/1nf2.svg)


**完整性**
- **实体完整性**：主码的值不能为空值
- **参照完整性**：如果 R1的外码 Fk 与 R2 的主码 Fk 对应，那么 R1 的每个元组的 Fk 值，要么等于 R2 某元组的 Pk 值，要么为空。
    - 举例来说，“学生”表的外码“班级号”，与“班级”表的主码“班级号”对应，那么每个学生的“班级号”，要么在“班级”表中有，要么为空（为空可能是还没给他分班）。换句话说，一个学生不可能被分到一个不存在的班里。
- **用户自定义完整性**：用户要求某个字段在约束范围内。例如年龄要大于0小于200；例如性别只有男/女



--------------

## 关系代数

关系代数：以集合为中心的运算，操作的对象是集合，操作的结果也是集合
- 关系代数基本操作：并、差、积、选择、投影
- 关系代数扩展操作：交、theta-连接、自然连接
- 关系代数复杂扩展操作：除、外连接


------------------

**并（union）**

前提：关系 R 和关系 S 有相容性。

关系 R 和关系 S 有 **相容性**，假设 `R(A1, A2,... An)`，`S(B1, B2,..., Bm)`
    : 1. R 和 S 的属性数目相同，即 n = m
      2. 对于任意的 i，Ai 和 Bi 的域相同

举例，这两个关系是相容的：`STUDENT(SID char(10), Sname char(8), Age char(3))` 和 `PROFESSOR(PID char(10), Pname char(8), Age char(3))`


并操作的定义：R和S是相容的，那么 $R \cup S = \{ t \mid t\in R \lor t \in S\}$


解释：实际上就是 SQL 中的 **UNION**

-------------------

**差**（Difference）

定义：前提是 R 和 S 是相容的，那么 $R - S = \{ t \mid t\in R \lor t \not\in S\}$


-------------------

**笛卡尔积**（Cartesian Product）

定义：R 和 S 中元组的所有可能的组合

用数学语言定义：$R \times S = \{ (a_1, a_2,..., a_n, b_1, b_2,..., b_n) \mid (a_1, a_2,..., a_n) \in R \land (b_1, b_2,..., b_n) \in S\}$


性质
- 可交换，$R \times S = S \times R$
- 如果 R 和 S 的属性个数为 n 和 m，那么 $R \times S$ 的属性个数为 n + m
- 如果 R 和 S 的基数分别为 x 和 y，那么 $R \times S$ 的基数为 `n * m`


-----------------------

**选择**（Select）

$\sigma_{con} (R) = \{ t \mid t \in R \land \mathrm{con}(t) = \mathrm{true} \}$
- 其中 con 是由一系列逻辑运算符、比较表达式组成的表达式


解释：就是 SQL 语句中的 WHERE

------------------------

**投影**（Project）

定义：选出 R 中的一些属性，然后形成新的关系

数学描述: 假设 $R(A_1, A_2, ..., A_n)$，那么 $\pi_{A_{i_1},A_{i_2},...A_{i_k}} = \{(t[A_{i_1}], t[A_{i_2}],..., t[A_{i_k}]) \mid t \in R\}$
- 其中：
- $\{A_{i_1},A_{i_2},...A_{i_k}\} \subseteq \{ A_1, A_2, ... , A_n\}$


---------------------

**交**（Intersection）

定义：前提是 R 和 S 是相容的，那么 $R \cap S = \{ t \mid t\in R \land t \in S\}$


性质：$R \cap S = R - (R- S) = S - (S - R)$


-----------------------

**theta-连接**（theta-join， θ-join）

$R \mathop{\bowtie}\limits_{A \theta B} S = \sigma_{t[A] \theta s[B]}(R \times S)$

- 用语言描述就是：先做笛卡尔积，然后找出满足 $\theta$ 条件的那些元组（“选择”），形成一个新的关系
- A 和 B 必须有可比性
- $\theta$ 可以是 `>, >=, <, <=, =, !=`


![caption: θ-连接](/a/computer/database/theta_join.svg)


说明：
1. 笛卡尔积是数学上的，在程序实现上不会先做笛卡尔积
2. 最常见的是等值连接 $R \mathop{\bowtie}\limits_{A = B} S = \sigma_{t[A] = s[B]}(R \times S)$



------------------------



$R \bowtie S$

$R \div S$




## 其它

ACID特性

- 原子性(Atomicity)。整个事务中的所有操作要么全部commit成功，要么全部失败rollback，对于一个事务来说，不可能只执行其中的一部分SQL操作，这就是事务的原子性。
- 一致性(Consistency)数据库总是从一个一致性的状态转换到另外一个一致性的状态。在前面的例子中， 一致性确保了，即使在执行第三、四条语句之间时系统崩潰，信用卡账户也不会损 失100块，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中，保证数据一致性。
- 隔离性(Isolation)一个事务所做的修改在最终提交以前，对其他事务是不可见的。
- 持久性(Durability)一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。


## 参考资料



哈尔滨工业大学：https://www.icourse163.org/learn/HIT-1001516002?tid=1475425441


陆军工程大学：数据库原理与应用 [https://www.icourse163.org/course/PAEU-1003647009](https://www.icourse163.org/course/PAEU-1003647009)



