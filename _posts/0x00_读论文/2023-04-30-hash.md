---
layout: post
title: 【论文学习】Hash 类算法
categories:
tags: 0x00_读论文
keywords:
description:
order: 9
---

## Finding Similar Files in a Large File System

https://www.cs.princeton.edu/courses/archive/spr05/cos598E/bib/manber94finding.pdf
1993

目的：大量文件中寻找相似的那些。
- 这里引入的是指纹类算法，使运行时间变成线性的。
- 文本相似的概念在这里定义为词本身的相似。近义词不视为相似
- fingerprints 和 checksum 只适用于精确相等的测试。我们的目标是检测相似性
- 但我们又不能使用固定部分（例如文件中间的10%），因为插入和删除会让这部分完全不同


方案1
- 设定 “锚” anchors，然后找到这个锚后面的 50 个字符，
- 如果锚没出现，或者出现在修改过的地方，会有问题
- 因此需要设定多个锚，这样可以用多模式匹配去寻找

方案2：计算所有可能长度的子串的指纹
- 不能简单的把文本分成长度为 50 的组，因为如果把开头位置偏移 1 字节，所有指纹都会变化
- 我们需要考虑所有的 50-byte 的子串


如何计算？设计了这样一个迭代式：

如果一个 “50-byte 子串” 表示为 “$t_1t_2...t_n$”
hash值就是：$F_1=(t_1\cdot p^{49} +t_2\cdot p^{48}+...+t_{50}) \mod M$  

偏移1个字节的 hash 值不需要再遍历 50 次，而是用这个来迭代：  
$F_2=(p\cdot F_1 + t_{51} - t1\cdot p^{49}) \mod M$  


一般取 p 为素数，$M = 2^{30}$



建议方案2，因为锚需要有通用性，但实际上只能随机选择。对《华尔街日报》好用的锚，可能不适用于医学文章。一种语言的锚也不适用于另一种语言

方案2:
- 需要禁止指纹重叠，识别出指纹后，移动到末尾。例如50个空格得到了指纹，而文章中有70个连续空格，就不要再生成21个重复指纹了。

如何查询？
- 一个文档可以提取多个指纹，建立 Query 数据库（例如 HashMap 或树结构），把每种指纹和文章id对应起来
- 如此输出1个相似度百分比，这个数字可能大于1，因为计数可能重复

另外还可以记录整个文件的 checksum 和 大小，以作为辅助使用


总结，这个论文是做了这些事：
- 生成指纹。